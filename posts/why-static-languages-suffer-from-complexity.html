<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="hirrolot’s Blog" />
  <title>Why Static Languages Suffer From Complexity</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="../style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Caveat&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Luxurious+Roman&display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="../myself.png" type="image/x-icon">
  <script src="../script.js"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Why Static Languages Suffer From Complexity</h1>
<p class="author">hirrolot’s Blog</p>
<p class="date">Jan 19, 2022</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#record-type-array">Record type – Array</a></li>
<li><a href="#sum-type-tree">Sum type – Tree</a></li>
<li><a href="#value-associated-type">Value – Associated type</a></li>
<li><a href="#recursion-type-level-induction">Recursion – Type-level induction</a></li>
<li><a href="#type-level-logic-reified">Type-level logic reified</a></li>
<li><a href="#the-unfortunate-consequences-of-being-static">The unfortunate consequences of being static</a></li>
<li><a href="#idris-the-way-out">Idris: The way out?</a></li>
<li><a href="#zig-simpler-but-too-systems">Zig: Simpler, but too systems</a></li>
<li><a href="#final-words">Final words</a></li>
<li><a href="#references">References</a></li>
</ul>
</nav>
<div class="introduction">
<p><img src="../media/why-static-languages-suffer-from-complexity/preview.jpg" /></p>
<p>People in the programming language design community strive to make their languages more expressive, with a strong type system, mainly to increase ergonomics by avoiding code duplication in final software; however, the more expressive their languages become, the more abruptly duplication penetrates the language itself.</p>
<p>This is what I call <strong>statics-dynamics biformity</strong>: whenever you introduce a new linguistic abstraction to your language, it may reside either on the statics level, on the dynamics level, or on the both levels. In the first two cases, where the abstraction is located only on one particular level, you introduce <em>inconsistency</em> to your language; in the latter case, you inevitably introduce the <em>feature biformity</em>.</p>
<p>For our purposes, the <strong>statics level</strong> is where all linguistic machinery is being performed at compile-time. Similarly, the <strong>dynamics level</strong> is where code is being executed at run-time. Thence the typical control flow operators, such as <code>if</code>/<code>while</code>/<code>for</code>/<code>return</code>, data structures, and procedures, are dynamic, whereas static type system features and syntactical macros, are static. In essence, the majority of static linguistic abstractions have their correspondence in the dynamic space and vice versa:</p>
<table>
<thead>
<tr class="header">
<th>Dynamics</th>
<th>Statics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Array</td>
<td>Record type/Tuple/<a href="https://beachape.com/frunk/frunk/hlist/index.html">Heterogeneous list</a></td>
</tr>
<tr class="even">
<td>Tree (data structure)</td>
<td>Sum type/<a href="https://beachape.com/frunk/frunk/coproduct/index.html">Coproduct</a></td>
</tr>
<tr class="odd">
<td>Value</td>
<td>Generic/<a href="https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html">Associated type</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></td>
</tr>
<tr class="even">
<td>Loop/recursion</td>
<td>Type-level induction</td>
</tr>
<tr class="odd">
<td>If-then-else/Pattern matching</td>
<td>Multiple trait implementations</td>
</tr>
<tr class="even">
<td>Function signature</td>
<td><code>trait F&lt;In...&gt; { type Out; }</code></td>
</tr>
<tr class="odd">
<td>Function implementation</td>
<td><code>impl F&lt;...&gt; for T { type Out = ...; }</code></td>
</tr>
<tr class="even">
<td>Function call</td>
<td><code>&lt;T as F&lt;...&gt;&gt;::Out</code></td>
</tr>
</tbody>
</table>
<p>In the following sections, before elaborating on the problem further, let me demonstrate to you how to implement logically equivalent programs using both the static and dynamic approaches. Most of the examples are written in Rust but can be applied to any other general-purpose programming language with enough expressive type system; keep in mind that this writeup is language-agnostic and is concerned with the <em>philosophy</em> of <a href="https://en.wikipedia.org/wiki/Programming_language_theory">PLT</a> in general rather than with particular PL implementations. If you feel busy, feel free to jump right to the <a href="#the-unfortunate-consequences-of-being-static">main section</a> about the problem explanation.</p>
</div>
<h2 id="record-type-array">Record type – Array</h2>
<p>Consider your everyday manipulation with record types (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=945f3a2f34937369495b3733718598a5">playground</a>):</p>
<p class="code-annotation">
<code>automobile-static.rs</code>
</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Automobile <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    wheels<span class="op">:</span> <span class="dt">u8</span><span class="op">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    seats<span class="op">:</span> <span class="dt">u8</span><span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    manufacturer<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> my_car <span class="op">=</span> Automobile <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        wheels<span class="op">:</span> <span class="dv">4</span><span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        seats<span class="op">:</span> <span class="dv">4</span><span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        manufacturer<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;X&quot;</span>)<span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;My car has {} wheels and {} seats, and it was made by {}.&quot;</span><span class="op">,</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        my_car<span class="op">.</span>wheels<span class="op">,</span> my_car<span class="op">.</span>seats<span class="op">,</span> my_car<span class="op">.</span>manufacturer</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The same can be done using arrays (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1dc3af0998b22c401a0042b081f441e1">playground</a>):</p>
<p class="code-annotation">
<code>automobile-dynamic.rs</code>
</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::any::</span><span class="bu">Any</span><span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>repr<span class="at">(</span><span class="dt">usize</span><span class="at">)]</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> MyCar <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    Wheels<span class="op">,</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    Seats<span class="op">,</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    Manufacturer<span class="op">,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> my_car<span class="op">:</span> [<span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="bu">Any</span><span class="op">&gt;;</span> <span class="dv">3</span>] <span class="op">=</span> [<span class="dt">Box</span><span class="pp">::</span>new(<span class="dv">4</span>)<span class="op">,</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="dv">4</span>)<span class="op">,</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="st">&quot;X&quot;</span>)]<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;My car has {} wheels and {} seats, and it was made by {}.&quot;</span><span class="op">,</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        my_car[<span class="pp">MyCar::</span>Wheels <span class="kw">as</span> <span class="dt">usize</span>]</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="pp">downcast_ref::</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>()</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        my_car[<span class="pp">MyCar::</span>Seats <span class="kw">as</span> <span class="dt">usize</span>]<span class="op">.</span><span class="pp">downcast_ref::</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>()<span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        my_car[<span class="pp">MyCar::</span>Manufacturer <span class="kw">as</span> <span class="dt">usize</span>]</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="pp">downcast_ref::</span><span class="op">&lt;&amp;</span><span class="ot">&#39;static</span> <span class="dt">str</span><span class="op">&gt;</span>()</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>unwrap()</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Yes, if we specify an incorrect type to <code>.downcast_ref</code>, we will get a panic. But the very <strong>logic</strong> of the program remains the same, only we elevate type checking to run-time.</p>
<p>Going further, we can encode static <code>Automobile</code> as a heterogenous list:</p>
<p class="code-annotation">
<code>automobile-hlist.rs</code>
</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">frunk::</span><span class="op">{</span>hlist<span class="op">,</span> HList<span class="op">};</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Wheels(<span class="dt">u8</span>)<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Seats(<span class="dt">u8</span>)<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Manufacturer(<span class="dt">String</span>)<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Automobile <span class="op">=</span> <span class="pp">HList!</span>[Wheels<span class="op">,</span> Seats<span class="op">,</span> Manufacturer]<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> my_car<span class="op">:</span> Automobile <span class="op">=</span> <span class="pp">hlist!</span>[Wheels(<span class="dv">4</span>)<span class="op">,</span> Seats(<span class="dv">4</span>)<span class="op">,</span> Manufacturer(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;X&quot;</span>))]<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;My car has {} wheels and {} seats, and it was made by {}.&quot;</span><span class="op">,</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        my_car<span class="op">.</span><span class="pp">get::</span><span class="op">&lt;</span>Wheels<span class="op">,</span> _<span class="op">&gt;</span>()<span class="op">.</span><span class="dv">0</span><span class="op">,</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        my_car<span class="op">.</span><span class="pp">get::</span><span class="op">&lt;</span>Seats<span class="op">,</span> _<span class="op">&gt;</span>()<span class="op">.</span><span class="dv">0</span><span class="op">,</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        my_car<span class="op">.</span><span class="pp">get::</span><span class="op">&lt;</span>Manufacturer<span class="op">,</span> _<span class="op">&gt;</span>()<span class="op">.</span><span class="dv">0</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This version enforces exactly the same type checks as <code>automobile-static.rs</code>, but additionally provides <a href="https://docs.rs/frunk/0.4.0/frunk/hlist/struct.HCons.html#implementations">methods</a> for manipulating with <code>type Automobile</code> as with ordinary collections! E.g., we may want to reverse our automobile:<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">assert_eq!</span>(</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    my_car<span class="op">.</span>into_reverse()<span class="op">,</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">hlist!</span>[Manufacturer(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;X&quot;</span>))<span class="op">,</span> Seats(<span class="dv">4</span>)<span class="op">,</span> Wheels(<span class="dv">4</span>)]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p>Or we may want to zip our car with their car:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> their_car <span class="op">=</span> <span class="pp">hlist!</span>[Wheels(<span class="dv">6</span>)<span class="op">,</span> Seats(<span class="dv">4</span>)<span class="op">,</span> Manufacturer(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Y&quot;</span>))]<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="pp">assert_eq!</span>(</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    my_car<span class="op">.</span>zip(their_car)<span class="op">,</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">hlist!</span>[</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        (Wheels(<span class="dv">4</span>)<span class="op">,</span> Wheels(<span class="dv">6</span>))<span class="op">,</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        (Seats(<span class="dv">4</span>)<span class="op">,</span> Seats(<span class="dv">4</span>))<span class="op">,</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        (Manufacturer(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;X&quot;</span>))<span class="op">,</span> Manufacturer(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Y&quot;</span>)))</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p>… And so forth.</p>
<p>However, sometimes we may want to apply type-level computation to ordinary <code>struct</code>s and <code>enum</code>s, but we cannot do it because we are unable to extract the very structure of a type definition (fields and types/variants and their function signatures) from a corresponding type name, especially if this type is external to our crate and we cannot put a derive macro onto it.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> To resolve the issue, Frunk developers decided to create such a procedural macro that examines the internal structure of a type definition by implementing the <a href="https://docs.rs/frunk/latest/frunk/generic/trait.Generic.html"><code>Generic</code></a> trait for it; it has the <code>type Repr</code> associated type, which, when implemented, equals to some form of a manipulatable heterogenous list. Still, all other types (well, transparent ones, such as <a href="https://en.wikipedia.org/wiki/Data_transfer_object">DTOs</a>) that do not have this derive macro, are left unexaminable, owing to the aforementioned limitations of Rust.</p>
<p><img src="../media/why-static-languages-suffer-from-complexity/rust-meme.png" /></p>
<h2 id="sum-type-tree">Sum type – Tree</h2>
<p>One may find sum types good to represent an AST node (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e5031b0c2888fe9ea336789ee1cdf049">playground</a>):</p>
<p class="code-annotation">
<code>ast-static.rs</code>
</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::ops::</span><span class="bu">Deref</span><span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Expr <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    Const(<span class="dt">i32</span>)<span class="op">,</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Add</span>(<span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;,</span> <span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Sub</span>(<span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;,</span> <span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Mul</span>(<span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;,</span> <span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Div</span>(<span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;,</span> <span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">Expr::</span><span class="op">*;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> eval(expr<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> expr<span class="op">.</span>deref() <span class="op">{</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        Const(x) <span class="op">=&gt;</span> <span class="op">*</span>x<span class="op">,</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Add</span>(lhs<span class="op">,</span> rhs) <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs) <span class="op">+</span> eval(<span class="op">&amp;</span>rhs)<span class="op">,</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Sub</span>(lhs<span class="op">,</span> rhs) <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs) <span class="op">-</span> eval(<span class="op">&amp;</span>rhs)<span class="op">,</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Mul</span>(lhs<span class="op">,</span> rhs) <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs) <span class="op">*</span> eval(<span class="op">&amp;</span>rhs)<span class="op">,</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Div</span>(lhs<span class="op">,</span> rhs) <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs) <span class="op">/</span> eval(<span class="op">&amp;</span>rhs)<span class="op">,</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> expr<span class="op">:</span> Expr <span class="op">=</span> <span class="bu">Add</span>(</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        Const(<span class="dv">53</span>)<span class="op">.</span>into()<span class="op">,</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Sub</span>(</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Div</span>(Const(<span class="dv">155</span>)<span class="op">.</span>into()<span class="op">,</span> Const(<span class="dv">5</span>)<span class="op">.</span>into())<span class="op">.</span>into()<span class="op">,</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>            Const(<span class="dv">113</span>)<span class="op">.</span>into()<span class="op">,</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>into()<span class="op">,</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> eval(<span class="op">&amp;</span>expr<span class="op">.</span>into()))<span class="op">;</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The same can be done using tagged trees (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6da60ed991ab6e6511c4572549047f62">playground</a>):</p>
<p class="code-annotation">
<code>ast-dynamic.rs</code>
</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::any::</span><span class="bu">Any</span><span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Tree <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    tag<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    value<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="bu">Any</span><span class="op">&gt;,</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    nodes<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">Box</span><span class="op">&lt;</span>Tree<span class="op">&gt;&gt;,</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> AST_TAG_CONST<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> AST_TAG_ADD<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> AST_TAG_SUB<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> AST_TAG_MUL<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> AST_TAG_DIV<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> eval(expr<span class="op">:</span> <span class="op">&amp;</span>Tree) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> lhs <span class="op">=</span> expr<span class="op">.</span>nodes<span class="op">.</span>get(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> rhs <span class="op">=</span> expr<span class="op">.</span>nodes<span class="op">.</span>get(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> expr<span class="op">.</span>tag <span class="op">{</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        AST_TAG_CONST <span class="op">=&gt;</span> <span class="op">*</span>expr<span class="op">.</span>value<span class="op">.</span><span class="pp">downcast_ref::</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>()<span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        AST_TAG_ADD <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs<span class="op">.</span>unwrap()) <span class="op">+</span> eval(<span class="op">&amp;</span>rhs<span class="op">.</span>unwrap())<span class="op">,</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        AST_TAG_SUB <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs<span class="op">.</span>unwrap()) <span class="op">-</span> eval(<span class="op">&amp;</span>rhs<span class="op">.</span>unwrap())<span class="op">,</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        AST_TAG_MUL <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs<span class="op">.</span>unwrap()) <span class="op">*</span> eval(<span class="op">&amp;</span>rhs<span class="op">.</span>unwrap())<span class="op">,</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        AST_TAG_DIV <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs<span class="op">.</span>unwrap()) <span class="op">/</span> eval(<span class="op">&amp;</span>rhs<span class="op">.</span>unwrap())<span class="op">,</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">=&gt;</span> <span class="pp">panic!</span>(<span class="st">&quot;Out of range&quot;</span>)<span class="op">,</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> expr <span class="op">=</span> <span class="co">/* Construction omitted... */</span><span class="op">;</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> eval(<span class="op">&amp;</span>expr))<span class="op">;</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Similarly to how we did with <code>struct Automobile</code>, we can represent <code>enum Expr</code> as <a href="https://beachape.com/frunk/frunk/coproduct/enum.Coproduct.html"><code>frunk::Coproduct</code></a>. This is left as an exercise to the reader.</p>
<h2 id="value-associated-type">Value – Associated type</h2>
<p>We may want to negate a boolean value using the standard operator <code>!</code> (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=0dea07f96037bce0e82a2c93c77898b0">playground</a>):</p>
<p class="code-annotation">
<code>negate-dynamic.rs</code>
</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">!</span><span class="cn">true</span><span class="op">,</span> <span class="cn">false</span>)<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">!</span><span class="cn">false</span><span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The same can be done through associated types<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=e101a1a384390a1d502aa514b21f9954">playground</a>):</p>
<p class="code-annotation">
<code>negate-static.rs</code>
</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::marker::</span>PhantomData<span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Bool <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Value<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> True<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> False<span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Bool <span class="kw">for</span> True <span class="op">{</span> <span class="kw">type</span> Value <span class="op">=</span> True<span class="op">;</span> <span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Bool <span class="kw">for</span> False <span class="op">{</span> <span class="kw">type</span> Value <span class="op">=</span> False<span class="op">;</span> <span class="op">}</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Negate<span class="op">&lt;</span>Cond<span class="op">&gt;</span>(PhantomData<span class="op">&lt;</span>Cond<span class="op">&gt;</span>)<span class="op">;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Bool <span class="kw">for</span> Negate<span class="op">&lt;</span>True<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Value <span class="op">=</span> False<span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Bool <span class="kw">for</span> Negate<span class="op">&lt;</span>False<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Value <span class="op">=</span> True<span class="op">;</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ThisIsFalse<span class="op">:</span> <span class="op">&lt;</span>Negate<span class="op">&lt;</span>True<span class="op">&gt;</span> <span class="kw">as</span> Bool<span class="op">&gt;</span><span class="pp">::</span>Value <span class="op">=</span> False<span class="op">;</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ThisIsTrue<span class="op">:</span> <span class="op">&lt;</span>Negate<span class="op">&lt;</span>False<span class="op">&gt;</span> <span class="kw">as</span> Bool<span class="op">&gt;</span><span class="pp">::</span>Value <span class="op">=</span> True<span class="op">;</span></span></code></pre></div>
<p>In fact, the <a href="https://sdleffler.github.io/RustTypeSystemTuringComplete/">Turing completeness of Rust’s type system</a> is built upon this principle combined with type induction (which we shall see a bit later). Every time you see an ordinary value in terms of Rust, know that it has its formal correspondence on the type-level, in the computational sense. Every time you write some algorithm, it has its correspondence on the type-level, using conceptually equivalent constructions! If you are interested in <em>how</em>, the above article provides a <strong>mathematical proof</strong>: first, the author implements a so-called language Smallfuck using <em>dynamics</em>: a sum type, pattern matching, recursion, and then using <em>statics</em>: logic on traits, associated types, etc.</p>
<h2 id="recursion-type-level-induction">Recursion – Type-level induction</h2>
<p>Let me show you one more example. But hold on tight this time (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=4b13a54fa1a41d928508546ef741700e">playground</a>)!</p>
<p class="code-annotation">
<code>peano-dynamic.rs</code>
</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::ops::</span><span class="bu">Deref</span><span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="op">,</span> <span class="bu">Debug</span><span class="op">,</span> <span class="bu">PartialEq</span><span class="at">)]</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Nat <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    Z<span class="op">,</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    S(<span class="dt">Box</span><span class="op">&lt;</span>Nat<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> add(lhs<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Box</span><span class="op">&lt;</span>Nat<span class="op">&gt;,</span> rhs<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Box</span><span class="op">&lt;</span>Nat<span class="op">&gt;</span>) <span class="op">-&gt;</span> Nat <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> lhs<span class="op">.</span>deref() <span class="op">{</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Nat::</span>Z <span class="op">=&gt;</span> rhs<span class="op">.</span>deref()<span class="op">.</span>clone()<span class="op">,</span> <span class="co">// I</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Nat::</span>S(next) <span class="op">=&gt;</span> <span class="pp">Nat::</span>S(<span class="dt">Box</span><span class="pp">::</span>new(add(next<span class="op">,</span> rhs)))<span class="op">,</span> <span class="co">// II</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> one <span class="op">=</span> <span class="pp">Nat::</span>S(<span class="pp">Nat::</span>Z<span class="op">.</span>into())<span class="op">;</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> two <span class="op">=</span> <span class="pp">Nat::</span>S(one<span class="op">.</span>clone()<span class="op">.</span>into())<span class="op">;</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> three <span class="op">=</span> <span class="pp">Nat::</span>S(two<span class="op">.</span>clone()<span class="op">.</span>into())<span class="op">;</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(add(<span class="op">&amp;</span>one<span class="op">.</span>into()<span class="op">,</span> <span class="op">&amp;</span>two<span class="op">.</span>into())<span class="op">,</span> three)<span class="op">;</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is the <a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano encoding</a> of a natural number. In the <code>add</code> function, we use recursion to compute a sum and pattern matching to find out where to stop.</p>
<p>As recursion corresponds to type induction and pattern matching corresponds to multiple implementations, the same can be done at compile-time (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d4c34d5ca2d4ea81c704aeb22a443e0f">playground</a>):</p>
<p class="code-annotation">
<code>peano-static.rs</code>
</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::marker::</span>PhantomData<span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Z<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S<span class="op">&lt;</span>Next<span class="op">&gt;</span>(PhantomData<span class="op">&lt;</span>Next<span class="op">&gt;</span>)<span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> <span class="bu">Add</span><span class="op">&lt;</span>Rhs<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Result<span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">// I</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>Rhs<span class="op">&gt;</span> <span class="bu">Add</span><span class="op">&lt;</span>Rhs<span class="op">&gt;</span> <span class="kw">for</span> Z <span class="op">{</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Result <span class="op">=</span> Rhs<span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co">// II</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>Lhs<span class="op">:</span> <span class="bu">Add</span><span class="op">&lt;</span>Rhs<span class="op">&gt;,</span> Rhs<span class="op">&gt;</span> <span class="bu">Add</span><span class="op">&lt;</span>Rhs<span class="op">&gt;</span> <span class="kw">for</span> S<span class="op">&lt;</span>Lhs<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Result <span class="op">=</span> S<span class="op">&lt;&lt;</span>Lhs <span class="kw">as</span> <span class="bu">Add</span><span class="op">&lt;</span>Rhs<span class="op">&gt;&gt;</span><span class="pp">::</span><span class="dt">Result</span><span class="op">&gt;;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> One <span class="op">=</span> S<span class="op">&lt;</span>Z<span class="op">&gt;;</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Two <span class="op">=</span> S<span class="op">&lt;</span>One<span class="op">&gt;;</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Three <span class="op">=</span> S<span class="op">&lt;</span>Two<span class="op">&gt;;</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> THREE<span class="op">:</span> <span class="op">&lt;</span>One <span class="kw">as</span> <span class="bu">Add</span><span class="op">&lt;</span>Two<span class="op">&gt;&gt;</span><span class="pp">::</span><span class="dt">Result</span> <span class="op">=</span> S(PhantomData)<span class="op">;</span></span></code></pre></div>
<p>Here, <code>impl ... for Z</code> is the base case (termination case), and <code>impl ... for S&lt;Lhs&gt;</code> is the induction step (recursion case) – similar to how we did with pattern matching using <code>match</code>. Likewise, as in the first example, the induction works by reducing the first argument to <code>Z</code>: <code>&lt;Lhs as Add&lt;Rhs&gt;&gt;::Result</code> works just like <code>add(next, rhs)</code> – it invokes pattern matching once again to drive the computation further. Note that the two trait implementations indeed belong to the same logical function implementation; they look detached because we perform pattern matching on our type-level number (<code>Z</code> and <code>S&lt;Next&gt;</code>). This is somewhat similar to what we are used to see in Haskell, where each pattern matching case looks like a separate function definition:</p>
<p class="code-annotation">
<code>peano-static.hs</code>
</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Exception</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Z</span> <span class="op">|</span> <span class="dt">S</span> <span class="dt">Nat</span> <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>add <span class="dt">Z</span> rhs <span class="ot">=</span> rhs <span class="co">-- I</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>add (<span class="dt">S</span> next) rhs <span class="ot">=</span> <span class="dt">S</span>(add next rhs) <span class="co">-- II</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>one <span class="ot">=</span> <span class="dt">S</span> <span class="dt">Z</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>two <span class="ot">=</span> <span class="dt">S</span> one</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>three <span class="ot">=</span> <span class="dt">S</span> two</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> assert ((add one two) <span class="op">==</span> three) <span class="op">$</span> <span class="fu">pure</span> ()</span></code></pre></div>
<h2 id="type-level-logic-reified">Type-level logic reified</h2>
<p><img src="../media/why-static-languages-suffer-from-complexity/chad-meme.png" /></p>
<p>The purpose of this writeup is only to convey the intuition behind the statics-dynamics biformity and not to provide a formal proof – for the latter, please refer to an awesome library called <a href="https://crates.io/crates/type-operators"><code>type-operators</code></a> (by the same person who implemented Smallfuck on types). In essence, it is an algorithmic macro eDSL that boils down to type-level manipulation with traits: you can define algebraic data types and perform data manipulations on them similar to how you normally do in Rust, but in the end, the whole code will dwell on the type-level. For more details, see the <a href="https://github.com/sdleffler/type-operators-rs/blob/master/src/lib.rs">translation rules</a> and an <a href="https://github.com/sdleffler/type-operators-rs/blob/master/README.md">excellent guide</a> by the same author. Another noteworthy project is <a href="https://github.com/Ashymad/fortraith">Fortraith</a>, which is a “compile-time compiler that compiles Forth to compile-time trait expressions”:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="pp">forth!</span>(</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> factorial (n <span class="op">--</span> n) <span class="dv">1</span> swap fact0 <span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">:</span> fact0 (n n <span class="op">--</span> n) dup <span class="dv">1</span> <span class="op">=</span> <span class="kw">if</span> drop <span class="kw">else</span> dup rot <span class="op">*</span> swap pred fact0 then <span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">5</span> factorial <span class="op">.</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p>The above code translates a simple factorial implementation to computation on traits and associated types. Later, you obtain a result as follows:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;{}&quot;</span><span class="op">,</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;&lt;</span>Empty <span class="kw">as</span> five<span class="op">&gt;</span><span class="pp">::</span><span class="dt">Result</span> <span class="kw">as</span> factorial<span class="op">&gt;</span><span class="pp">::</span><span class="dt">Result</span> <span class="kw">as</span> top<span class="op">&gt;</span><span class="pp">::</span><span class="dt">Result</span><span class="pp">::</span>eval()</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p>Having considered everything above, it is crystal clear that the <strong>logic</strong> part remains the same, no matter how you call it: be it statics or dynamics.</p>
<h2 id="the-unfortunate-consequences-of-being-static">The unfortunate consequences of being static</h2>
<blockquote>
<p>Are you quite sure that all those bells and whistles, all those wonderful facilities of your so called powerful programming languages, belong to the solution set rather than the problem set?</p>
</blockquote>
<p class="quote-author">
<a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger Dijkstra</a> <span class="citation" data-cites="dijkstra-pl-quote">(Edsger Dijkstra, n.d.)</span>
</p>
<p>Programming languages nowadays do not focus on the logic. They focus on the mechanisms inferior to logic; they call boolean negation the most simple operator that must exist from the very beginning but <a href="https://github.com/rust-lang/rfcs/issues/1834">negative trait bounds</a> are considered a debatable concept with “a lot of issues.” The majority of mainstream PLs support the tree data structure in their standard libraries, but sum types <a href="https://bitbashing.io/std-visit.html">stay unimplemented for decades</a>. I cannot imagine a single language without the <code>if</code> operator, but only a few PLs accommodate full-fledged trait bounds, not to mention pattern matching. This is <strong>inconsistency</strong> – it compels software enginners design low-quality APIs that either go dynamic and expose a very few compile-time checks or go static and try to circumvent the fundamental limitations of a host language, thereby making their usage more and more abstruse. Combining statics and dynamics in a single working solution is also complicated since you cannot invoke dynamics in a static context. In terms of <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function colours</a>, dynamics is coloured red, whereas statics is blue.</p>
<p>In addition to this inconsistency, we have the feature <strong>biformity</strong>. In such languages as C++, Haskell, and Rust, this biformity amounts to the most perverse forms; you can think of any so-called “expressive” programming language as of two or more smaller languages put together: C++ the language and C++ templates/macros, Rust the language and type-level Rust + declarative macros, etc. With this approach, each time you write something at a meta-level, you cannot reuse it in the host language and vice versa, thus violating the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY principle</a> (as we shall see in a minute). Additionally, biformity increases the learning curve, hardens language evolution, and finally ends up in such a feature bloat that only the initiated can figure out what is happening in the code. Take a look at any production code in Haskell and you will immediately see those numerous GHC <code>#LANGUAGE</code> clauses, each of which signifies a separate language extension:</p>
<p class="code-annotation">
<code>feature-bloat.hs</code>
</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns               #-}</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE CPP                        #-}</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ConstraintKinds            #-}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DefaultSignatures          #-}</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveAnyClass             #-}</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric              #-}</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DerivingStrategies         #-}</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances          #-}</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE NamedFieldPuns             #-}</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds                  #-}</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards            #-}</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables        #-}</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances       #-}</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ViewPatterns               #-}</span></span></code></pre></div>
<p class="adapted-from">
Adapted from <a href="https://github.com/haskell/haskell-language-server/blob/ee0a0cc78352c961f641443eea89a26b9e1d3974/hls-plugin-api/src/Ide/Types.hs">haskell/haskell-language-server</a>.
</p>
<p>When a host language does not provide enough static capabilities needed for convenient development, some programmers go especially insane and create whole new compile-time metalanguages and eDSLs atop of existing ones. Thus, <strong>inconsistency has the treacherous property of transforming into biformity</strong>:</p>
<ul>
<li>
<p>[<strong>C++</strong>] We have <a href="https://en.wikipedia.org/wiki/Template_metaprogramming">template metaprogramming</a> libraries, such as <a href="https://github.com/boostorg/hana">Boost/Hana</a> and <a href="https://github.com/boostorg/mpl">Boost/MPL</a>, which copy the functionality of C++ to be used at a meta-level:</p>
<p class="code-annotation">
<code>take_while.cpp</code>
</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">BOOST_</span>HANA_CONSTANT_CHECK<span class="op">(</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    hana<span class="op">::</span>take_while<span class="op">(</span>hana<span class="op">::</span>tuple_c<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;,</span> hana<span class="op">::</span>less<span class="op">.</span>than<span class="op">(</span><span class="dv">2_c</span><span class="op">))</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">==</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    hana<span class="op">::</span>tuple_c<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">&gt;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
<p class="adapted-from">
Adapted from <a href="https://github.com/boostorg/hana/blob/998033e9dba8c82e3c9496c274a3ad1acf4a2f36/example/take_while.cpp">hana/example/take_while.cpp</a>.
</p>
<p class="code-annotation">
<code>filter.cpp</code>
</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> is_integral <span class="op">=</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    hana<span class="op">::</span>compose<span class="op">(</span>hana<span class="op">::</span>trait<span class="op">&lt;</span><span class="bu">std::</span>is_integral<span class="op">&gt;,</span> hana<span class="op">::</span><span class="va">typeid_</span><span class="op">);</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    hana<span class="op">::</span>filter<span class="op">(</span>hana<span class="op">::</span>make_tuple<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="fl">4.0</span><span class="op">),</span> is_integral<span class="op">)</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">==</span> hana<span class="op">::</span>make_tuple<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">),</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    hana<span class="op">::</span>filter<span class="op">(</span>hana<span class="op">::</span>just<span class="op">(</span><span class="dv">3</span><span class="op">),</span> is_integral<span class="op">)</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">==</span> hana<span class="op">::</span>just<span class="op">(</span><span class="dv">3</span><span class="op">),</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="ex">BOOST_</span>HANA_CONSTANT_CHECK<span class="op">(</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    hana<span class="op">::</span>filter<span class="op">(</span>hana<span class="op">::</span>just<span class="op">(</span><span class="fl">3.0</span><span class="op">),</span> is_integral<span class="op">)</span> <span class="op">==</span> hana<span class="op">::</span>nothing<span class="op">);</span></span></code></pre></div>
<p class="adapted-from">
Adapted from <a href="https://github.com/boostorg/hana/blob/998033e9dba8c82e3c9496c274a3ad1acf4a2f36/example/filter.cpp">hana/example/filter.cpp</a>.
</p>
<p class="code-annotation">
<code>iter_fold.cpp</code>
</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> vector_c<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">&gt;</span> numbers<span class="op">;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> iter_fold<span class="op">&lt;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    numbers<span class="op">,</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    begin<span class="op">&lt;</span>numbers<span class="op">&gt;::</span>type<span class="op">,</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">if_</span><span class="op">&lt;</span>less<span class="op">&lt;</span>deref<span class="op">&lt;</span>_1<span class="op">&gt;,</span> deref<span class="op">&lt;</span>_2<span class="op">&gt;&gt;,</span> _2<span class="op">,</span> _1<span class="op">&gt;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;::</span>type max_element_iter<span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="ex">BOOST_</span>MPL_ASSERT_RELATION<span class="op">(</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    deref<span class="op">&lt;</span>max_element_iter<span class="op">&gt;::</span>type<span class="op">::</span>value<span class="op">,</span> <span class="op">==,</span> <span class="dv">7</span><span class="op">);</span></span></code></pre></div>
<p class="adapted-from">
Adapted from <a href="https://www.boost.org/doc/libs/1_78_0/libs/mpl/doc/refmanual/iter-fold.html">the docs of MPL</a>.
</p>
</li>
<li>
<p>[<strong>C</strong>] My own compile-time metaprogramming framework <a href="https://github.com/hirrolot/metalang99">Metalang99</a> does the same by (ab)using the C preprocessor. It came to such extent that I was forced to <a href="https://github.com/hirrolot/metalang99/blob/master/include/metalang99/eval/rec.h">re-implement recursion</a> through the combination of a Lisp-like trampoline and <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">Continuation-Passing Style (CPS)</a> techniques. In the end, I had a cornucopia of list manipulation functions in the standard library, such as <a href="https://metalang99.readthedocs.io/en/latest/list.html#c.ML99_listMap"><code>ML99_listMap</code></a>, <a href="https://metalang99.readthedocs.io/en/latest/list.html#c.ML99_listIntersperse"><code>ML99_listIntersperse</code></a>, and <a href="https://metalang99.readthedocs.io/en/latest/list.html#c.ML99_listFoldr"><code>ML99_listFoldr</code></a>, which arguably makes Metalang99, as a pure data transformation language, more expressive than C itself.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
</li>
<li>
<p>[<strong>Rust</strong>] In the first example of inconsistency (<code>Automobile</code>), we used a heterogenous list from the <a href="https://docs.rs/frunk/latest/frunk/index.html">Frunk</a> library. It is of no difficulty to see that Frunk <a href="https://github.com/lloydmeta/frunk/blob/master/core/src/hlist.rs">duplicates</a> some of the functionality of collections and iterators just to elevate them to type-level. It could be cool to apply <code>Iterator::map</code> or <code>Iterator::intersperse</code> to heterogenous lists, but we cannot. Even worse, if we nevertheless want to perform declarative type-level data transformations, we have to maintain the 1-to-1 correspondence between the iterator adaptors and those of type-level; each time a new utility is implemented for iterators, we have one utility missing in <code>hlist</code>.</p>
</li>
<li>
<p>[<strong>Rust</strong>] <a href="https://docs.rs/typenum/latest/typenum/">Typenum</a> is yet another popular type-level library: it allows performing integral calculations at compile-time, by encoding integers as generics.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> By doing this, the part of the language responsible for integers finds its counterpart in the statics, thereby introducing even more biformity.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> We cannot just parameterise some type with <code>(2 + 2) * 5</code>, we have to write something like <code>&lt;&lt;P2 as Add&lt;P2&gt;&gt;::Output as Mul&lt;P5&gt;&gt;::Output</code>! The best thing you could do is to write a macro that does the dirty job for you, but it would only be syntax sugar – you would anyway see hordes of compile-time errors with the aforementioned traits.</p>
</li>
</ul>
<p><img src="../media/why-static-languages-suffer-from-complexity/tmp-meme.png" /></p>
<p>Sometimes, software engineers find their languages too primitive to express their ideas even in dynamic code. But they do not give up:</p>
<ul>
<li>[<strong>Golang</strong>] <a href="https://github.com/kubernetes/kubernetes">Kubernetes</a>, one of the largest codebases in Golang, has its own <a href="https://medium.com/@arschles/go-experience-report-generics-in-kubernetes-25da87430301">object-oriented type system</a> implemented in the <a href="https://pkg.go.dev/k8s.io/apimachinery/pkg/runtime"><code>runtime</code> package</a>.</li>
</ul>
<ul>
<li>[<strong>C</strong>] The <a href="https://github.com/videolan/vlc">VLC media player</a> has a macro-based <a href="https://github.com/videolan/vlc/blob/271d3552b7ad097d796bc431e946931abbe15658/include/vlc_plugin.h">plugin API</a> used to represent media codecs. Here is how <a href="https://github.com/videolan/vlc/blob/271d3552b7ad097d796bc431e946931abbe15658/modules/codec/opus.c#L57">Opus is defined</a>.</li>
</ul>
<ul>
<li>[<strong>C</strong>] The <a href="https://github.com/qemu/qemu">QEMU machine emulator</a> is built upon their custom <a href="https://github.com/qemu/qemu/tree/master/include/qapi/qmp">object model</a>: <code>QObject</code>, <code>QNum</code>, <code>QNull</code>, <code>QList</code>, <code>QString</code>, <code>QDict</code>, <code>QBool</code>, etc.</li>
</ul>
<p>Recalling the famous <a href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule">Greenspun’s tenth rule</a>, such handmade metalanguages are typically “ad-hoc, informally-specified, bug-ridden, and slow,” with quite vague semantics and awful documentation. The concept of a metalinguistic abstraction simply does not work, albeit the rationale of creating highly declarative, small domain-specific languages sounds so cool at first sight. When a problem domain (or some intermediate machinery) is expressed in terms of a host language, you need to understand how to chain calls together to get things done – this is what we usually call an API; however, when this API is written in another language, then, in addition to the calling sequence, you need to understand the syntax and semantics of that language, which is very unfortunate for two reasons: the mental burden it lays upon developers and a very limited number of developers that can support such metalanguages. From my experience, handmade metalinguistics tend to quickly go out of hand and spread across the whole codebase, thereby making it harder to dig into. Not only reasoning is impaired but also compiler-developer interaction: have you ever tried to use a sophisticated type or macro API? If yes, then you should be perfectly acquainted with inscrutable compiler diagnostics, which can be summarised in the following screenshot:<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<p><img src="../media/whats-the-point-of-the-c-preprocessor-actually/2.jpg" /></p>
<p>This is woefully to say, but it seems that an “expressive” PL nowadays means “Hey there, I have seriously messed up with the number of features, but that is fine!”</p>
<p>Finally, a word has to be said about metaprogramming in a host language. With such templating systems as <a href="https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial">Template Haskell</a> and <a href="https://doc.rust-lang.org/reference/procedural-macros.html">Rust’s procedural macros</a>, we can manipulate an AST<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> of a host language using the same language, which is good in terms of biformity but unpleasant in terms of general language inconsistency. Macros are not functions: we cannot partially apply a macro and obtain a partially applied function (or vice versa), since they are just different concepts – this can turn out to be a pain in the ass if we are to design a generic and easy-to-use library API. Personally, I do think that procedural macros in Rust are a <strong>giant design mistake</strong> that is comparable to <code>#define</code> macros in plain C: aside from pure syntax, the macro system simply has no idea about the language being manipulated; instead of a tool to extend and work with a language gracefully, you get slightly enhanced text substitution and nothing more. E.g., imagine there is an enumeration called <code>Either</code>, whose definition is as follows:</p>
<p class="code-annotation">
<code>either.rs</code>
</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> Either<span class="op">&lt;</span>L<span class="op">,</span> R<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    Left(L)<span class="op">,</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    Right(R)<span class="op">,</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p class="adapted-from">
Adapted from <a href="https://docs.rs/either/latest/either/enum.Either.html">either::Either</a>.
</p>
<p>Now imagine we have an arbitrary trait <code>Foo</code>, and we are willing to implement this trait for <code>Either&lt;L, R&gt;</code>, where <code>L</code> and <code>R</code> both implement <code>Foo</code>. It turns out that we cannot apply a derive macro to <code>Either</code> that implements this trait, even if the name is known because, in order to do this, this macro must know all the signatures of <code>Foo</code>. To make the situation even worse, <code>Foo</code> may be defined in a separate library, meaning that we cannot augment its definition with extra meta-information needed for the derivation for <code>Either&lt;L, R&gt;</code>. While it may seem as a rare scanario, in fact it is not; I highly encourage you to look at <a href="https://docs.rs/tokio-util/latest/tokio_util/">tokio-util</a>’s <a href="https://docs.rs/tokio-util/latest/tokio_util/either/enum.Either.html"><code>Either</code></a>, which is <strong>exactly</strong> the same enumeration but it implements Tokio-specific traits, such as <code>AsyncRead</code>, <code>AsyncWrite</code>, <code>AsyncSeek</code>, etc.<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> Now imagine you have five different <code>Either</code>s in your project that came from different libraries – that would be a true integration headache! While type introspection may be a compromise, it would nonetheless make the language even more complex than it already is.</p>
<h2 id="idris-the-way-out">Idris: The way out?</h2>
<blockquote>
<p>One of the most fundamental features of Idris is that types and expressions are part of the same language – you use the same syntax for both.</p>
</blockquote>
<p class="quote-author">
<a href="https://www.type-driven.org.uk/edwinb/">Edwin Brady</a>, the author of <a href="https://www.idris-lang.org/">Idris</a> <span class="citation" data-cites="type-dd-with-idris">(Edwin Brady, n.d.)</span>
</p>
<p>Let us think a little bit about how to workaround the issue. If we make our languages fully dynamic, we will win biformity and inconsistency,<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> but will imminently lose the pleasure of compile-time validation and will end up debugging our programs at mid-nights. The misery of dynamic type systems is widely known.</p>
<p>The only way to approach the problem is to make a language whose features are both static and dynamic and not to split the same feature into two parts. Thus, the ideal linguistic abstraction is both static and dynamic; however, it is still a single concept and not two logically similar concepts but with different interfaces.<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> A perfect example is <a href="https://en.wikipedia.org/wiki/Compile-time_function_execution">CTFE</a>, colloquially known as <code>constexpr</code>: same code can be executed at compile-time under a static context and at run-time under a dynamic context (e.g., when requesting a user input from <code>stdin</code>.); thus, we do not have to write different code for compile-time (statics) and run-time (dynamics), instead we use the same representation.</p>
<p>One possible solution I have seen is dependent types. With dependent types, we can parameterise types not only with other types but with values, too. In a dependently typed language <a href="https://www.idris-lang.org/">Idris</a>, there is a type called <code>Type</code> – it stands for the “type of all types,” thereby <strong>weakening the dichotomy between type-level and value-level</strong>. Having such a powerful thing at our disposal, we can express <em>typed</em> abstractions that are usually either built into a language compiler/environment or done via macros. Perhaps the most common and descriptive example is a type-safe <code>printf</code> that calculates types of its arguments on the fly, so let give us the pleasure of mastering it in Idris!<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a></p>
<p>First, define an inductive data type <code>Fmt</code> and a way to get it from a format string:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Fmt</span> <span class="fu">=</span> <span class="dt">FArg</span> <span class="dt">Fmt</span> <span class="fu">|</span> <span class="dt">FChar</span> <span class="dt">Char</span> <span class="dt">Fmt</span> <span class="fu">|</span> <span class="dt">FEnd</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="fu">toFmt</span> <span class="ot">:</span> (fmt <span class="ot">:</span> <span class="dt">List</span> <span class="dt">Char</span>) <span class="ot">-&gt;</span> <span class="dt">Fmt</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>toFmt (<span class="ch">&#39;*&#39;</span> <span class="ot">::</span> xs) <span class="fu">=</span> <span class="dt">FArg</span> (toFmt xs)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>toFmt (  x <span class="ot">::</span> xs) <span class="fu">=</span> <span class="dt">FChar</span> x (toFmt xs)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>toFmt [] <span class="fu">=</span> <span class="dt">FEnd</span></span></code></pre></div>
<p>Later, we will use it to generate a type for our <code>printf</code> function. The syntax resembles Haskell a lot and should be comprehensible for a reader.</p>
<p>Now the most interesting part:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">PrintfType</span> <span class="ot">:</span> (fmt <span class="ot">:</span> <span class="dt">Fmt</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="dt">PrintfType</span> (<span class="dt">FArg</span> fmt) <span class="fu">=</span> ({ty <span class="ot">:</span> <span class="dt">Type</span>} <span class="ot">-&gt;</span> <span class="dt">Show</span> ty <span class="ot">=&gt;</span> (obj <span class="ot">:</span> ty) <span class="ot">-&gt;</span> <span class="dt">PrintfType</span> fmt)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="dt">PrintfType</span> (<span class="dt">FChar</span> <span class="fu">_</span> fmt) <span class="fu">=</span> <span class="dt">PrintfType</span> fmt</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="dt">PrintfType</span> <span class="dt">FEnd</span> <span class="fu">=</span> <span class="dt">String</span></span></code></pre></div>
<p>What this function does? It <strong>calculates a type</strong> based on the input argument <code>fmt</code>. As usual, we case-split <code>fmt</code> into three cases and deal with them separately:</p>
<ol type="1">
<li><code>(FArg fmt)</code>. Since <code>FArg</code> indicates that we are to provide a printable argument, this case produces a type signature that takes an additional parameter:
<ol type="1">
<li><code>{ty : Type}</code> means that Idris will deduce a type <code>ty</code> of this argument automatically (<a href="https://docs.idris-lang.org/en/latest/tutorial/miscellany.html#implicit-arguments">implicit argument</a>).</li>
<li><code>Show ty</code> is a type constraint that says that <code>ty</code> should implement <code>Show</code>.</li>
<li><code>(obj : ty)</code> is that printable argument we must provide to <code>printf</code>.</li>
<li><code>PrintfType fmt</code> is a recursive call that deals with the rest of the input <code>fmt</code>. In Idris, inductive types are managed by inductive functions!</li>
</ol></li>
<li><code>(FChar _ fmt)</code>. <code>FChar</code> indicates an ordinary character in a format string, so here we just ignore it and continue with <code>PrintfType fmt</code>.</li>
<li><code>FEnd</code>. This is the end of input. Since we want our <code>printf</code> to produce a <code>String</code>, we return <code>String</code> as an ordinary type.</li>
</ol>
<p>Now say we have a format string <code>"*x*"</code>, or <code>FArg (FChar ('x' (FArg FEnd)))</code>; what type will <code>PrintfType</code> generate? Simple:</p>
<ol type="1">
<li><code>FArg</code>: <code>{ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; PrintfType (FChar ('x' (FArg FEnd)))</code></li>
<li><code>FChar</code>: <code>{ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; PrintfType (FArg FEnd)</code></li>
<li><code>FArg</code>: <code>{ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; {ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; PrintfType FEnd</code></li>
<li><code>FEnd</code>: <code>{ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; {ty : Type} -&gt; Show ty =&gt; (obj : ty) -&gt; String</code></li>
</ol>
<p>Cool, now it is time to write the coveted <code>printf</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">printf</span> <span class="ot">:</span> (fmt <span class="ot">:</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">PrintfType</span> (toFmt <span class="fu">$</span> unpack fmt)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>printf fmt <span class="fu">=</span> printfAux (toFmt <span class="fu">$</span> unpack fmt) [] <span class="kw">where</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">printfAux</span> <span class="ot">:</span> (fmt <span class="ot">:</span> <span class="dt">Fmt</span>) <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">PrintfType</span> fmt</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    printfAux (<span class="dt">FArg</span> fmt) acc <span class="fu">=</span> <span class="fu">\</span>obj <span class="ot">=&gt;</span> printfAux fmt (acc <span class="fu">++</span> unpack (show obj))</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    printfAux (<span class="dt">FChar</span> c fmt) acc <span class="fu">=</span> printfAux fmt (acc <span class="fu">++</span> [c])</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    printfAux <span class="dt">FEnd</span> acc <span class="fu">=</span> pack acc</span></code></pre></div>
<p>As you can see, <code>PrintfType (toFmt $ unpack fmt)</code> occurs in the type signature, meaning that the whole type of <code>printf</code> <em>depends on the input argument</em> <code>fmt</code>! But what does <code>unpack fmt</code> mean? Since <code>printf</code> takes <code>fmt : String</code>, we should convert it to <code>List Char</code> beforehand because we match this string in <code>toFmt</code>; as far as I know, Idris does not allow matching an ordinary <code>String</code> in the same way. Likewise, we do <code>unpack fmt</code> before calling <code>printfAux</code>, since it also takes <code>List Char</code> as a result accumulator.</p>
<p>Let us examine the <code>printfAux</code> implementation:</p>
<ol type="1">
<li><code>(FArg fmt)</code>. Here we return a lambda function that takes <code>obj</code> and calls <code>show</code> on it, then appends to <code>acc</code> by the <code>++</code> operator.</li>
<li><code>(FChar c fmt)</code>. Just append <code>c</code> to <code>acc</code> and call <code>printfAux</code> once again on <code>fmt</code>.</li>
<li><code>FEnd</code>. Since <code>acc</code> is typed <code>List Char</code> but we have to return <code>String</code> (according to the last case of <code>PrintfType</code>), we call <code>pack</code> on it.</li>
</ol>
<p>Finally, test <code>printf</code>:</p>
<p class="code-annotation">
<code>printf.idr</code>
</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>main <span class="fu">=</span> putStrLn <span class="fu">$</span> printf <span class="st">&quot;Mr. John has * contacts in *.&quot;</span> <span class="dv">42</span> <span class="st">&quot;New York&quot;</span></span></code></pre></div>
<p>This prints <code>Mr. John has 42 contacts in "New York".</code>. But what if we do not provide <code>42</code> to <code>printf</code>?</p>
<pre><code>Error: While processing right hand side of main. When unifying:
    ?ty -&gt; PrintfType (toFmt [assert_total (prim__strIndex &quot;Mr. John has * contacts in *.&quot; (prim__cast_IntegerInt (natToInteger (length &quot;Mr. John has * contacts in *.&quot;)) - 1))])
and:
    String
Mismatch
between: ?ty -&gt; PrintfType (toFmt [assert_total (prim__strIndex &quot;Mr. John has * contacts in *.&quot; (prim__cast_IntegerInt (natToInteger (length &quot;Mr. John has * contacts in *.&quot;)) - 1))]) and String.

test:21:19--21:68
 17 |     printfAux (FChar c fmt) acc = printfAux fmt (acc ++ [c])
 18 |     printfAux FEnd acc = pack acc
 19 | 
 20 | main : IO ()
 21 | main = putStrLn $ printf &quot;Mr. John has * contacts in *.&quot; &quot;New York&quot;
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Warning: compiling hole Main.main</code></pre>
<p>Yeah, Idris detects the error and produces a type mismatch! This is basically how you implement type-safe <code>printf</code> with first-class types. If you are curious about the same thing in Rust, take a look at <a href="https://willcrichton.net/notes/type-safe-printf/">Will Crichton’s attempt</a>, which relies heavily on heterogenous lists we have seen above. The downside of this approach now should be perfectly clear to you: in Rust, the language of the type system differs from the main language, but in Idris, it is indeed the same thing – this is why we can freely define type-level functions as regular functions returning a <code>Type</code> and invoke them later in type signatures. Moreover, because Idris is dependently typed, you can even compute a type based on some run-time argument, which is impossible in such languages as <a href="https://ziglang.org/">Zig</a>.</p>
<p><img src="../media/why-static-languages-suffer-from-complexity/printf-meme.png" /></p>
<p>I already anticipate the question: what is the problem of implementing <code>printf</code> with macros? After all, <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a> works just fine in Rust. The problem is macros. Think for yourself: why a programming language needs heavy-duty macros? Because we may want to extend it. Why may we want to extend it? Because a programming language does not fit our needs: we cannot express something using regular linguistic abstractions, and this is why we decide to extend the language with ad-hoc meta-abstractions. In the main section, I provided an argumentation why this approach sucks – because a macro system has no clue about a language being manipulated; in fact, procedural macros in Rust is just a fancy name for the <a href="https://en.wikipedia.org/wiki/M4_(computer_language)">M4 preprocessor</a>. You guys integrated M4 into your language. Of course, this is <a href="whats-the-point-of-the-c-preprocessor-actually.html">better than external M4</a>, but it is nevertheless a method of the 20’th century; proc. macros even cannot manipulate an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree"><em>abstract</em> syntax tree</a>, because <a href="https://docs.rs/syn/latest/syn/enum.Item.html"><code>syn::Item</code></a>, a common structure used to write proc. macros, is indeed known as a <a href="https://en.wikipedia.org/wiki/Parse_tree"><em>concrete</em> syntax tree</a>, or “parse tree.” On the other hand, types are a natural part of a host language, and this is why if we can express a programmatic abstraction using types, we <em>reuse</em> linguistic abstractions instead of resorting to ad-hoc machinery. Ideally, a programming language should have either no macros or only a lightweight form of syntax rewriting rules (like Scheme’s <a href="https://www2.ccs.neu.edu/racket/pubs/lasc1990-sf.pdf"><code>extend-syntax</code></a> or <a href="https://docs.idris-lang.org/en/latest/tutorial/syntax.html">syntax extensions</a> of Idris), in order to keep the language consistent and well-suited to solve expected tasks.</p>
<p>That being said, Idris erases the first biformity “values-generics” by introducing <code>Type</code>, the “type of all types.” By doing so, it also resolves a bunch of other correspondences, such as recursion vs. type-level induction, functions vs. trait machinery, and so forth; this, in turn, allows programming in the same language as much as possible, even when dealing with highly generic code. E.g., you can even represent a list of types as <code>List Type</code>, just like <code>List Nat</code> or <code>List String</code>, and deal with it as usual! It is possible due to a <a href="https://docs.idris-lang.org/en/latest/faq/faq.html#does-idris-have-universe-polymorphism-what-is-the-type-of-type">cumulative hierarchy of universes</a>: simply speaking, <code>Type</code> is of type <code>Type 1</code>, <code>Type 1</code> is of type <code>Type 2</code>, and so on. Since <a href="https://github.com/idris-lang/Idris2/blob/0d58282087a8dce89a036e31e192af13b9199850/libs/prelude/Prelude/Basics.idr#L164"><code>Data.List</code></a>’s generic named <code>a</code> is “implicitly” typed <code>Type</code>, it can be <code>Nat</code> and <code>String</code> as well as <code>Type</code>; in the latter case, <code>a</code> would be deduced as <code>Type 1</code>. Such an infinite sequence of types is needed to avoid a variation of <a href="https://en.wikipedia.org/wiki/Russell%27s_paradox">Russell’s paradox</a> by making an inhabitant “structurally smaller” than its type.</p>
<p>Idris, however, is not a simple language. Our twenty line example of <code>printf</code> already uses a “whole lotta features,” such as inductive data types, dependent pattern matching, implicits, type constraints, to mention a few. Additionally, Idris features <a href="http://docs.idris-lang.org/en/latest/effects/index.html">computational effects</a>, <a href="http://docs.idris-lang.org/en/latest/elaboratorReflection/index.html">elaborator reflection</a>, coinductive data types, and many-many stuff for theorem proving. With such a pleiad of typing facilities, you typically twiddle with your language machinery rather than doing some meaningful work. I can hardly believe that in their current state, dependent types will find massive production use; as for now, in the programming world, they are no more than a fancy thing for PL researchers and random enthusiasts like me. Dependent types alone are just too low-level.</p>
<h2 id="zig-simpler-but-too-systems">Zig: Simpler, but too systems</h2>
<blockquote>
<p>In Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions, and returned from functions.</p>
</blockquote>
<p class="quote-author">
The Zig manual <span class="citation" data-cites="zig-comptime-params">(Zig developers, n.d.)</span>
</p>
<p>Our last patient would be the <a href="https://ziglang.org/">Zig</a> programming language. Here is a compile-time <code>printf</code> implementation in Zig (sorry no highlighting yet):</p>
<p class="code-annotation">
<code>printf.zig</code>
</p>
<pre class="zig"><code>const std = @import(&quot;std&quot;);

fn printf(comptime fmt: []const u8, args: anytype) anyerror!void {
    const stdout = std.io.getStdOut().writer();

    comptime var arg_idx: usize = 0;

    inline for (fmt) |c| {
        if (c == &#39;*&#39;) {
            try printArg(stdout, args[arg_idx]);
            arg_idx += 1;
        } else {
            try stdout.print(&quot;{c}&quot;, .{c});
        }
    }

    comptime {
        if (args.len != arg_idx) {
            @compileError(&quot;Unused arguments&quot;);
        }
    }
}

fn printArg(stdout: std.fs.File.Writer, arg: anytype) anyerror!void {
    if (@typeInfo(@TypeOf(arg)) == .Pointer) {
        try stdout.writeAll(arg);
    } else {
        try stdout.print(&quot;{any}&quot;, .{arg});
    }
}

pub fn main() !void {
    try printf(&quot;Mr. John has * contacts in *.\n&quot;, .{ 42, &quot;New York&quot; });
}</code></pre>
<p>Here, we use a feature called <a href="https://kristoff.it/blog/what-is-zig-comptime/"><code>comptime</code></a>: a <code>comptime</code> function parameter means that it <strong>must</strong> be known at the time of compilation. Not only it allows for aggressive optimisations but also opens a Valhalla of “metaprogramming” facilities, most notably without separate macro-level or type-level sublanguages. The above code needs no further explanation – the mundane logic should be clear to every programmer, unlike <code>printf.idr</code> that seems to look like a fruit of a mad genius’ wet fantasies.</p>
<p>If we omit <code>42</code>, Zig will report a compilation error:</p>
<pre><code>An error occurred:
/tmp/playground2454631537/play.zig:10:38: error: field index 1 outside tuple &#39;struct:33:52&#39; which has 1 fields
            try printArg(stdout, args[arg_idx]);
                                     ^
/tmp/playground2454631537/play.zig:33:15: note: called from here
    try printf(&quot;Mr. John has * contacts in *.\n&quot;, .{ &quot;New York&quot; });
              ^
/tmp/playground2454631537/play.zig:32:21: note: called from here
pub fn main() !void {
                    ^</code></pre>
<p>The only inconvenience I experienced during the development of <code>printf</code> is <a href="https://gist.github.com/hirrolot/504dfe97627895c9f8f82697e27bb142">massive errors…</a> Much like C++ templates. However, I admit that this can be solved (or at least workarounded) by more explicit type constraints. Overall, the design of Zig’s type system seems reasonable: there is a type of all types called <code>type</code>, and using <code>comptime</code>, we can <a href="https://ikrima.dev/dev-notes/zig/zig-metaprogramming/">compute types</a> at compile-time via regular variables, loops, procedures, etc. We can even perform type reflection through the <a href="https://ziglang.org/documentation/master/#typeInfo"><code>@typeInfo</code></a>, <a href="https://ziglang.org/documentation/master/#typeName"><code>@typeName</code></a>, and <a href="https://ziglang.org/documentation/master/#TypeOf"><code>@TypeOf</code></a> built-ins! Yes, we can no longer depend on run-time values, but if you do not need a theorem prover, probably full-blown dependent types are a bit of overkill.</p>
<p><img src="../media/why-static-languages-suffer-from-complexity/types-meme.png" /></p>
<p>Everything is good except that Zig is a systems language. On <a href="https://ziglang.org/">their official website</a>, Zig is described as a “general-purpose programming language,” but I can hardly agree with this statement. Yes, you can write virtually any software in Zig, but should you? My experience in maintaining high-level code in Rust and C99 says <strong>NO</strong>. The first reason is safety: if you make a systems language safe, you will make programmers deal with borrow checker and ownership (or equivalent) issues that have absolutely nothing to do with business logic (believe me, I know the pain); otherwise, if you choose the C-way manual memory management, you will make programmers debugging their code for long hours with the hope that <code>-fsanitize=address</code> would show something meaningful. Moreover, if you want to build new abstractions atop of pointers, you will end up with <code>&amp;str</code>, <code>AsRef&lt;str&gt;</code>, <code>Borrow&lt;str&gt;</code>, <code>Box&lt;str&gt;</code>, and the similar. Come on, I just want a UTF-8 string; most of the time, I do not really care whether it is one of those alternatives.</p>
<p>The second reason is concerned with a language runtime:<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> for a language to be systems, to avoid hidden performance penalties, it should have a minimum runtime – no default GC, no default event loop, etc., but for particular applications, it might be necessary to have a runtime – for asynchronous ones, for instance, so actually you <em>must</em> deal with custom runtime code in some way. Here we encounter a whole new set of problems regarding <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function colours</a>: e.g., having <code>async</code> in your language and having no tools to <em>abstract over</em> synchronous and asynchronous functions means that you divided your language into two parts: synchronous and asynchronous, and say, if you have a generic higher-order library, it will be inevitably marked <code>async</code> to accept all kinds of user callbacks. To resolve the issue, you need to implement some form of <a href="http://docs.idris-lang.org/en/latest/effects/index.html">effect polymorphism</a> (e.g., monads or algebraic effects), which is still a research topic. High-level languages have innately fewer problems to deal with, and this is why most of the software is written in Java, C#, Python, and JavaScript; in Golang, conceptually, every function is <code>async</code>, thus facilitating consistency <em>by default</em>, without resorting to sophisticated type features. On the contrary, Rust is already considered a complex language and still has no standard means to write truly generic asynchronous code.</p>
<p>Zig can still be used in large systems projects like web browsers, interpreters, and operating system kernels – nobody wants these things to freeze unexpectedly. Zig’s low-level programming features would facilitate convenient operation with memory and hardware devices, while its sane approach to metaprogramming (in the right hands) would cultivate understandable code structure. Bringing it to high-level code would just increase the mental burden without considerable benefits.</p>
<blockquote>
<p>Progress is possible only if we train ourselves to think about programs without thinking of them as pieces of executable code.</p>
</blockquote>
<p class="quote-author">
<a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger Dijkstra</a>
</p>
<h2 id="final-words">Final words</h2>
<p>Static languages enforce compile-time checks; this is good. But they suffer from feature biformity and inconsistency – this is bad. Dynamic languages, on the other hand, suffer from these drawbacks to a lesser extent, but they lack compile-time checks. A hypothetical solution should take the best from the both worlds.</p>
<p>Programming languages ought to be rethought.</p>
<h2 class="unnumbered" id="references">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-dijkstra-pl-quote" class="csl-entry" role="doc-biblioentry">
Edsger Dijkstra. n.d. <span>“On the Teaching of Programming, i.e. On the Teaching of Thinking.”</span> <a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD473.html">https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD473.html</a>.
</div>
<div id="ref-type-dd-with-idris" class="csl-entry" role="doc-biblioentry">
Edwin Brady. n.d. <span>“Type-Driven Development with Idris.”</span> Manning Publications Co. <a href="https://www.manning.com/books/type-driven-development-with-idris">https://www.manning.com/books/type-driven-development-with-idris</a>.
</div>
<div id="ref-zig-comptime-params" class="csl-entry" role="doc-biblioentry">
Zig developers. n.d. <span>“Introducing the Compile-Time Concept.”</span> <a href="https://ziglang.org/documentation/0.9.0/#Introducing-the-Compile-Time-Concept">https://ziglang.org/documentation/0.9.0/#Introducing-the-Compile-Time-Concept</a>.
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>In such systems as <a href="https://en.wikipedia.org/wiki/Calculus_of_constructions">Calculus of Constructions</a>, polymorphic functions accept generics as ordinary function parameters of the kind *, or “the kind of all types.”<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Need to augment the field types with <code>#[derive(Debug, PartialEq)]</code>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>In addition to inextensibility, derive macros possess <em>tight coupling</em>: if <code>DeriveX</code> is put onto <code>Foo</code>, then <code>foo.rs</code> inevitably depends on <code>DeriveX</code>. This can complicate migration of components, slow down compilation time, and cause merge conflicts.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>We could even generalise these two implementations of <code>Negate</code> over a generic value <code>Cond</code>, but this is impossible due to a <a href="https://github.com/rust-lang/rust/issues/20400">known bug in the Rust’s type system</a>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>In the C++ community, there is an analogous library <a href="http://boost.org/libs/preprocessor">Boost/Preprocessor</a>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Do you remember our variables-generics correspondence?<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>Some time ago, minimal working <a href="https://github.com/rust-lang/rust/issues/44580">const generics</a> were stabilised. In perspective, they could replace Typenum by using the same integer representation as in ordinary code.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>Got it while working on <a href="https://github.com/teloxide/teloxide">teloxide</a>, IIRC.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>Technically speaking, Rust cannot work with its true AST, but we will come back to it later.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>It is even more of comedy that initially, I wrote a third-party crate called <a href="https://github.com/hirrolot/tokio-either">tokio-either</a>, which just contained that <code>Either</code> with several trait implementations. Only later, the Tokio maintainers <a href="https://github.com/tokio-rs/tokio/pull/2821">decided</a> to move it to tokio-util.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>Terra is a perfect example of a simple dynamic language. In the <a href="https://terralang.org/#simplicity">“Simplicity” section</a>, they show how features of static PLs can be implemented as libraries in dynamic languages.<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>Multiple personality disorder? 🤨<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>The full code can be found at <a href="https://gist.github.com/hirrolot/b5b23af0dcb68cf7e87e72baf6da6ef6">my gist</a>. I use Idris2, which you can download <a href="https://idris2.readthedocs.io/en/latest/tutorial/starting.html">here</a>.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p>For our purposes, a language runtime is some hidden machinery responsible for mapping the semantics of a language (i.e., its abstract machine) to the semantics of a real executor.<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<script src="https://utteranc.es/client.js" repo="hirrolot/hirrolot.github.io" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
</body>
</html>
