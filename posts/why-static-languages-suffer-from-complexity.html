<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="hirrolot’s Blog" />
  <title>Why Static Languages Suffer From Complexity</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Caveat&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Lancelot&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="../myself.png" type="image/x-icon">
  <script src="../script.js"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Why Static Languages Suffer From Complexity</h1>
<p class="author">hirrolot’s Blog</p>
<p class="date">Jan 3, 2022</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#record-types-hash-maps">Record types – Hash maps</a></li>
<li><a href="#sum-types-trees">Sum types – Trees</a></li>
<li><a href="#variables-associated-types">Variables – Associated types</a></li>
<li><a href="#branching-trait-bounds">Branching – Trait bounds</a></li>
<li><a href="#recursion-type-level-induction">Recursion – Type-level induction</a></li>
<li><a href="#the-unfortunate-consequences-of-being-static">The unfortunate consequences of being static</a></li>
<li><a href="#is-there-a-way-out">Is there a way out?…</a></li>
</ul>
</nav>
<div class="introduction">
<p><img src="../media/why-static-languages-suffer-from-complexity/preview.jpg" /></p>
<p>People in the programming language design community strive to make their languages more expressive, with a strong type system, mainly to increase ergonomics by avoiding code duplication in final software; however, the more expressive their languages become, the more abruptly duplication penetrates the language itself.</p>
<p>This is what I call <strong>statics-dynamics biformity</strong>: whenever you introduce a new linguistic abstraction to your language, it may reside either on the statics level, on the dynamics level, or on the both levels. In the first two cases, where the abstraction is located only on one particular level, you introduce <em>inconsistency</em> to your language; in the latter case, you inevitably introduce the <em>feature biformity</em>.</p>
<p>For our purposes, the <strong>statics level</strong> is where all linguistic machinery is being performed at compile-time. Similarly, the <strong>dynamics level</strong> is where code is being executed at run-time. Thence the typical control operators, such as <code>if</code>/<code>while</code>/<code>for</code>/<code>return</code>, data structures, and procedures, are dynamic, whereas static type system features and syntactical macros are static. In essence, the majority of static linguistic abstractions have their correspondence in the dynamic space and vice versa:</p>
<table>
<thead>
<tr class="header">
<th>Dynamics</th>
<th>Statics</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Variables</td>
<td>Generics/<a href="https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html">Associated types</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></td>
</tr>
<tr class="even">
<td><code>if</code></td>
<td><a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Trait bounds</a></td>
</tr>
<tr class="odd">
<td>Loop/recursion</td>
<td>Type-level induction</td>
</tr>
<tr class="even">
<td><code>HashMap&lt;String, &amp;dyn Any&gt;</code></td>
<td>Record types</td>
</tr>
<tr class="odd">
<td>Tree (data structure)</td>
<td>Sum types</td>
</tr>
<tr class="even">
<td>Pattern matching</td>
<td>Multiple trait implementations</td>
</tr>
</tbody>
</table>
<p>In the following sections, before elaborating on the problem further, let me demonstrate to you how to implement logically equivalent programs using the static and dynamic approaches. All the examples are written in Rust, but can be applied to any other general-purpose programming language with enough expressive type system. If you feel busy, feel free to jump right to the <a href="#the-unfortunate-consequences-of-being-static">main section</a> about the problem explanation.</p>
</div>
<h2 id="record-types-hash-maps">Record types – Hash maps</h2>
<p>Consider your everyday manipulation with record types (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=945f3a2f34937369495b3733718598a5">playground</a>):</p>
<p class="code-annotation">
<code>automobile-static.rs</code>
</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Automobile <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    wheels<span class="op">:</span> <span class="dt">u8</span><span class="op">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    seats<span class="op">:</span> <span class="dt">u8</span><span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    manufacturer<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> my_car <span class="op">=</span> Automobile <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        wheels<span class="op">:</span> <span class="dv">4</span><span class="op">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        seats<span class="op">:</span> <span class="dv">4</span><span class="op">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        manufacturer<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;X&quot;</span>)<span class="op">,</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;My car has {} wheels and {} seats, and it was made by {}.&quot;</span><span class="op">,</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        my_car<span class="op">.</span>wheels<span class="op">,</span> my_car<span class="op">.</span>seats<span class="op">,</span> my_car<span class="op">.</span>manufacturer</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now take a look at the same program, but written using a hash map instead of a record type (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b1aed9ece0c6e075843314aed299e585">playground</a>):</p>
<p class="code-annotation">
<code>automobile-dynamic.rs</code>
</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::any::</span><span class="bu">Any</span><span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> my_car<span class="op">:</span> HashMap<span class="op">&lt;&amp;</span><span class="ot">&#39;static</span> <span class="dt">str</span><span class="op">,</span> <span class="op">&amp;</span><span class="kw">dyn</span> <span class="bu">Any</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">HashMap::</span>new()<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    my_car<span class="op">.</span>insert(<span class="st">&quot;wheels&quot;</span><span class="op">,</span> <span class="op">&amp;</span><span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    my_car<span class="op">.</span>insert(<span class="st">&quot;seats&quot;</span><span class="op">,</span> <span class="op">&amp;</span><span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    my_car<span class="op">.</span>insert(<span class="st">&quot;manufacturer&quot;</span><span class="op">,</span> <span class="op">&amp;</span><span class="st">&quot;X&quot;</span>)<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;My car has {} wheels and {} seats, and it was made by {}.&quot;</span><span class="op">,</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        my_car<span class="op">.</span>get(<span class="st">&quot;wheels&quot;</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>unwrap()</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="pp">downcast_ref::</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>()</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        my_car<span class="op">.</span>get(<span class="st">&quot;seats&quot;</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>unwrap()</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="pp">downcast_ref::</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>()</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        my_car</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>get(<span class="st">&quot;manufacturer&quot;</span>)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>unwrap()</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="pp">downcast_ref::</span><span class="op">&lt;&amp;</span><span class="ot">&#39;static</span> <span class="dt">str</span><span class="op">&gt;</span>()</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>unwrap()</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Yes, if we specify an incorrect type somewhere near <code>.get</code>, we will get a panic. But the very <strong>logic</strong> of the program remains the same, only we elevate type checking to run-time.</p>
<h2 id="sum-types-trees">Sum types – Trees</h2>
<p>One may find sum types good to represent an AST node (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e5031b0c2888fe9ea336789ee1cdf049">playground</a>):</p>
<p class="code-annotation">
<code>ast-static.rs</code>
</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::ops::</span><span class="bu">Deref</span><span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Expr <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    Const(<span class="dt">i32</span>)<span class="op">,</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Add</span>(<span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;,</span> <span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Sub</span>(<span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;,</span> <span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Mul</span>(<span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;,</span> <span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Div</span>(<span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;,</span> <span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">Expr::</span><span class="op">*;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> eval(expr<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Box</span><span class="op">&lt;</span>Expr<span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> expr<span class="op">.</span>deref() <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        Const(x) <span class="op">=&gt;</span> <span class="op">*</span>x<span class="op">,</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Add</span>(lhs<span class="op">,</span> rhs) <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs) <span class="op">+</span> eval(<span class="op">&amp;</span>rhs)<span class="op">,</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Sub</span>(lhs<span class="op">,</span> rhs) <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs) <span class="op">-</span> eval(<span class="op">&amp;</span>rhs)<span class="op">,</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Mul</span>(lhs<span class="op">,</span> rhs) <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs) <span class="op">*</span> eval(<span class="op">&amp;</span>rhs)<span class="op">,</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Div</span>(lhs<span class="op">,</span> rhs) <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs) <span class="op">/</span> eval(<span class="op">&amp;</span>rhs)<span class="op">,</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> expr<span class="op">:</span> Expr <span class="op">=</span> <span class="bu">Add</span>(</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        Const(<span class="dv">53</span>)<span class="op">.</span>into()<span class="op">,</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Sub</span>(</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Div</span>(Const(<span class="dv">155</span>)<span class="op">.</span>into()<span class="op">,</span> Const(<span class="dv">5</span>)<span class="op">.</span>into())<span class="op">.</span>into()<span class="op">,</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>            Const(<span class="dv">113</span>)<span class="op">.</span>into()<span class="op">,</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>into()<span class="op">,</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    )<span class="op">;</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> eval(<span class="op">&amp;</span>expr<span class="op">.</span>into()))<span class="op">;</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The same can be done using tagged trees (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6da60ed991ab6e6511c4572549047f62">playground</a>):</p>
<p class="code-annotation">
<code>ast-dynamic.rs</code>
</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::any::</span><span class="bu">Any</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Tree <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    tag<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    value<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="bu">Any</span><span class="op">&gt;,</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    nodes<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">Box</span><span class="op">&lt;</span>Tree<span class="op">&gt;&gt;,</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> AST_TAG_CONST<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> AST_TAG_ADD<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> AST_TAG_SUB<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> AST_TAG_MUL<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> AST_TAG_DIV<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> eval(expr<span class="op">:</span> <span class="op">&amp;</span>Tree) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> lhs <span class="op">=</span> expr<span class="op">.</span>nodes<span class="op">.</span>get(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> rhs <span class="op">=</span> expr<span class="op">.</span>nodes<span class="op">.</span>get(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> expr<span class="op">.</span>tag <span class="op">{</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        AST_TAG_CONST <span class="op">=&gt;</span> <span class="op">*</span>expr<span class="op">.</span>value<span class="op">.</span><span class="pp">downcast_ref::</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>()<span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        AST_TAG_ADD <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs<span class="op">.</span>unwrap()) <span class="op">+</span> eval(<span class="op">&amp;</span>rhs<span class="op">.</span>unwrap())<span class="op">,</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        AST_TAG_SUB <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs<span class="op">.</span>unwrap()) <span class="op">-</span> eval(<span class="op">&amp;</span>rhs<span class="op">.</span>unwrap())<span class="op">,</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        AST_TAG_MUL <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs<span class="op">.</span>unwrap()) <span class="op">*</span> eval(<span class="op">&amp;</span>rhs<span class="op">.</span>unwrap())<span class="op">,</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        AST_TAG_DIV <span class="op">=&gt;</span> eval(<span class="op">&amp;</span>lhs<span class="op">.</span>unwrap()) <span class="op">/</span> eval(<span class="op">&amp;</span>rhs<span class="op">.</span>unwrap())<span class="op">,</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">=&gt;</span> <span class="pp">panic!</span>(<span class="st">&quot;Out of range&quot;</span>)<span class="op">,</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> expr <span class="op">=</span> <span class="co">/* Construction omitted... */</span><span class="op">;</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> eval(<span class="op">&amp;</span>expr))<span class="op">;</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="variables-associated-types">Variables – Associated types</h2>
<p>We may want to negate a boolean value using the standard operator <code>!</code> (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=0dea07f96037bce0e82a2c93c77898b0">playground</a>):</p>
<p class="code-annotation">
<code>negate-dynamic.rs</code>
</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">!</span><span class="cn">true</span><span class="op">,</span> <span class="cn">false</span>)<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">!</span><span class="cn">false</span><span class="op">,</span> <span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The same can be done through associated types (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=e101a1a384390a1d502aa514b21f9954">playground</a>):</p>
<p class="code-annotation">
<code>negate-static.rs</code>
</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::marker::</span>PhantomData<span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Bool <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Value<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> True<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> False<span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Bool <span class="kw">for</span> True <span class="op">{</span> <span class="kw">type</span> Value <span class="op">=</span> True<span class="op">;</span> <span class="op">}</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Bool <span class="kw">for</span> False <span class="op">{</span> <span class="kw">type</span> Value <span class="op">=</span> False<span class="op">;</span> <span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Negate<span class="op">&lt;</span>Cond<span class="op">&gt;</span>(PhantomData<span class="op">&lt;</span>Cond<span class="op">&gt;</span>)<span class="op">;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Bool <span class="kw">for</span> Negate<span class="op">&lt;</span>True<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Value <span class="op">=</span> False<span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Bool <span class="kw">for</span> Negate<span class="op">&lt;</span>False<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Value <span class="op">=</span> True<span class="op">;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ThisIsFalse<span class="op">:</span> <span class="op">&lt;</span>Negate<span class="op">&lt;</span>True<span class="op">&gt;</span> <span class="kw">as</span> Bool<span class="op">&gt;</span><span class="pp">::</span>Value <span class="op">=</span> False<span class="op">;</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> ThisIsTrue<span class="op">:</span> <span class="op">&lt;</span>Negate<span class="op">&lt;</span>False<span class="op">&gt;</span> <span class="kw">as</span> Bool<span class="op">&gt;</span><span class="pp">::</span>Value <span class="op">=</span> True<span class="op">;</span></span></code></pre></div>
<p>(We could even generalise these two implementations of <code>Negate</code> over a generic value <code>Cond</code>, but this is impossible due to a <a href="https://github.com/rust-lang/rust/issues/20400">known bug in the Rust’s type system</a>.)</p>
<h2 id="branching-trait-bounds">Branching – Trait bounds</h2>
<p>If-then-else is much like trait bounds (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=4ce6bda628caf7147a46df9f97864043">playground</a>):</p>
<p class="code-annotation">
<code>kosher-dynamic.rs</code>
</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> FOO<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> BAR<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> is_kosher(x<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        FOO <span class="op">=&gt;</span> <span class="cn">true</span><span class="op">,</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">=&gt;</span> <span class="cn">false</span><span class="op">,</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert!</span>(is_kosher(FOO))<span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ERROR:</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert!</span>(is_kosher(BAR))<span class="op">;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This time, let us make a predicate out of a trait and define <code>Foo</code> and <code>Bar</code> as custom types (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d8953b584f3c885c4b90051a18e79e35">playground</a>):</p>
<p class="code-annotation">
<code>kosher-static.rs</code>
</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Kosher <span class="op">{}</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Foo<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Bar<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Kosher <span class="kw">for</span> Foo <span class="op">{}</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> accept_kosher<span class="op">&lt;</span>T<span class="op">:</span> Kosher<span class="op">&gt;</span>() <span class="op">{}</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">accept_kosher::</span><span class="op">&lt;</span>Foo<span class="op">&gt;</span>()<span class="op">;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ERROR:</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">accept_kosher::</span><span class="op">&lt;</span>Bar<span class="op">&gt;</span>()<span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>With <a href="https://github.com/rust-lang/rfcs/issues/1834">negative trait bounds</a>, we could even handle the case where <code>T</code> does <em>not</em> implement <code>Kosher</code>, thereby expressing the “else” thing.</p>
<h2 id="recursion-type-level-induction">Recursion – Type-level induction</h2>
<p>Let me show you one more example. But hold on tight this time (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=4b13a54fa1a41d928508546ef741700e">playground</a>)!</p>
<p class="code-annotation">
<code>peano-dynamic.rs</code>
</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::ops::</span><span class="bu">Deref</span><span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="op">,</span> <span class="bu">Debug</span><span class="op">,</span> <span class="bu">PartialEq</span><span class="at">)]</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Nat <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    Z<span class="op">,</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    S(<span class="dt">Box</span><span class="op">&lt;</span>Nat<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> add(lhs<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Box</span><span class="op">&lt;</span>Nat<span class="op">&gt;,</span> rhs<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Box</span><span class="op">&lt;</span>Nat<span class="op">&gt;</span>) <span class="op">-&gt;</span> Nat <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> lhs<span class="op">.</span>deref() <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Nat::</span>Z <span class="op">=&gt;</span> rhs<span class="op">.</span>deref()<span class="op">.</span>clone()<span class="op">,</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Nat::</span>S(next) <span class="op">=&gt;</span> <span class="pp">Nat::</span>S(<span class="dt">Box</span><span class="pp">::</span>new(add(next<span class="op">,</span> rhs)))<span class="op">,</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> one <span class="op">=</span> <span class="pp">Nat::</span>S(<span class="pp">Nat::</span>Z<span class="op">.</span>into())<span class="op">;</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> two <span class="op">=</span> <span class="pp">Nat::</span>S(one<span class="op">.</span>clone()<span class="op">.</span>into())<span class="op">;</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> three <span class="op">=</span> <span class="pp">Nat::</span>S(two<span class="op">.</span>clone()<span class="op">.</span>into())<span class="op">;</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(add(<span class="op">&amp;</span>one<span class="op">.</span>into()<span class="op">,</span> <span class="op">&amp;</span>two<span class="op">.</span>into())<span class="op">,</span> three)<span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This is the <a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano encoding</a> of a natural number. In the <code>add</code> function, we use recursion to compute a sum and pattern matching to find out where to stop.</p>
<p>As recursion corresponds to type induction and pattern matching corresponds to multiple implementations, the same can be done at compile-time (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d4c34d5ca2d4ea81c704aeb22a443e0f">playground</a>):</p>
<p class="code-annotation">
<code>peano-static.rs</code>
</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::marker::</span>PhantomData<span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Z<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S<span class="op">&lt;</span>Next<span class="op">&gt;</span>(PhantomData<span class="op">&lt;</span>Next<span class="op">&gt;</span>)<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> <span class="bu">Add</span><span class="op">&lt;</span>Rhs<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Result<span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>Rhs<span class="op">&gt;</span> <span class="bu">Add</span><span class="op">&lt;</span>Rhs<span class="op">&gt;</span> <span class="kw">for</span> Z <span class="op">{</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Result <span class="op">=</span> Rhs<span class="op">;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>Lhs<span class="op">:</span> <span class="bu">Add</span><span class="op">&lt;</span>Rhs<span class="op">&gt;,</span> Rhs<span class="op">&gt;</span> <span class="bu">Add</span><span class="op">&lt;</span>Rhs<span class="op">&gt;</span> <span class="kw">for</span> S<span class="op">&lt;</span>Lhs<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Result <span class="op">=</span> S<span class="op">&lt;&lt;</span>Lhs <span class="kw">as</span> <span class="bu">Add</span><span class="op">&lt;</span>Rhs<span class="op">&gt;&gt;</span><span class="pp">::</span><span class="dt">Result</span><span class="op">&gt;;</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> One <span class="op">=</span> S<span class="op">&lt;</span>Z<span class="op">&gt;;</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Two <span class="op">=</span> S<span class="op">&lt;</span>One<span class="op">&gt;;</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Three <span class="op">=</span> S<span class="op">&lt;</span>Two<span class="op">&gt;;</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> THREE<span class="op">:</span> <span class="op">&lt;</span>One <span class="kw">as</span> <span class="bu">Add</span><span class="op">&lt;</span>Two<span class="op">&gt;&gt;</span><span class="pp">::</span><span class="dt">Result</span> <span class="op">=</span> S(PhantomData)<span class="op">;</span></span></code></pre></div>
<p>Here, <code>impl ... for Z</code> is the base case, and <code>impl ... for S&lt;Lhs&gt;</code> is the induction step. As in the first example, the induction works by reducing the first argument to <code>Z</code>.</p>
<p>You can clearly see the logical resemblance of the both examples – because the <strong>logic</strong> part remains the same, no matter how you call it: be it statics or dynamics.</p>
<h2 id="the-unfortunate-consequences-of-being-static">The unfortunate consequences of being static</h2>
<blockquote>
<p>Are you quite sure that all those bells and whistles, all those wonderful facilities of your so called powerful programming languages, belong to the solution set rather than the problem set?</p>
</blockquote>
<p class="quote-author">
<a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger Dijkstra</a>
</p>
<p>Programming languages nowadays do not focus on the logic. They focus on the mechanisms inferior to logic; they call boolean negation the most simple operator that must exist from the very beginning but <a href="https://github.com/rust-lang/rfcs/issues/1834">negative trait bounds</a> are considered a debatable concept with “a lot of issues.” The majority of mainstream PLs support the tree data structure in their standard libraries, but sum types <a href="https://bitbashing.io/std-visit.html">stay unimplemented for decades</a>. I cannot imagine a single language without the <code>if</code> operator, but only a few PLs accommodate full-fledged trait bounds, not to mention pattern matching. This is <strong>inconsistency</strong> – it compels software enginners design low-quality APIs that either go dynamic and expose a very few compile-time checks or go static and try to circumvent the fundamental limitations of a host language, thereby making their usage more and more abstruse. Combining statics and dynamics in a single working solution is also complicated since you cannot invoke dynamics in a static context. In terms of <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function colors</a>, dynamics is coloured red, whereas statics is blue.</p>
<p>In addition to this inconsistency, we have the feature <strong>biformity</strong>. In such languages as C++, Haskell, and Rust, this biformity amounts to the most perverse forms; you can think of any so-called “expressive” programming language as of two or more smaller languages put together: C++ the language and C++ templates/macros, Rust the language and type-level Rust + declarative macros, etc. With this approach, each time you write something at a meta-level, you cannot reuse it in the host language and vice versa, thus violating the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY principle</a> (as we shall see in a minute). Additionally, biformity increases the learning curve, hardens language evolution, and finally ends up in such a feature bloat that only the initiated can figure out what is happening in the code. Take a look at any production code in Haskell and you will immediately see those numerous GHC <code>#LANGUAGE</code> clauses, each of which signifies a separate language extension:</p>
<p class="code-annotation">
<code>feature-bloat.hs</code>
</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns               #-}</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE CPP                        #-}</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ConstraintKinds            #-}</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DefaultSignatures          #-}</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveAnyClass             #-}</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric              #-}</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DerivingStrategies         #-}</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances          #-}</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE NamedFieldPuns             #-}</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds                  #-}</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards            #-}</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables        #-}</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances       #-}</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ViewPatterns               #-}</span></span></code></pre></div>
<p class="adapted-from">
Adapted from <a href="https://github.com/haskell/haskell-language-server/blob/ee0a0cc78352c961f641443eea89a26b9e1d3974/hls-plugin-api/src/Ide/Types.hs">haskell/haskell-language-server</a>.
</p>
<p>When a host language does not provide enough static capabilities needed for convenient development, some programmers go especially insane and create whole new compile-time metalanguages and eDSLs atop of existing ones. Thus, inconsistency has the treacherous property of transforming into biformity:</p>
<ul>
<li>We have <a href="https://en.wikipedia.org/wiki/Template_metaprogramming">template metaprogramming</a> libraries, such as <a href="https://github.com/boostorg/hana">Boost/Hana</a> and <a href="https://github.com/boostorg/mpl">Boost/MPL</a>, which copy the functionality of C++ to be used at a meta-level.</li>
</ul>
<ul>
<li>My own compile-time metaprogramming framework <a href="https://github.com/hirrolot/metalang99">Metalang99</a> does the same by (ab)using the C preprocessor.</li>
</ul>
<ul>
<li><a href="https://github.com/kubernetes/kubernetes">Kubernetes</a>, one of the largest codebases in Golang, has its own <a href="https://medium.com/@arschles/go-experience-report-generics-in-kubernetes-25da87430301">object-oriented type system</a> implemented in the <a href="https://pkg.go.dev/k8s.io/apimachinery/pkg/runtime"><code>runtime</code> package</a>.</li>
</ul>
<ul>
<li>The <a href="https://github.com/videolan/vlc">VLC media player</a> has a macro-based <a href="https://github.com/videolan/vlc/blob/271d3552b7ad097d796bc431e946931abbe15658/include/vlc_plugin.h">plugin API</a> used to represent media codecs. Here is how <a href="https://github.com/videolan/vlc/blob/271d3552b7ad097d796bc431e946931abbe15658/modules/codec/opus.c#L57">Opus is defined</a>.</li>
</ul>
<p>Recalling the famous <a href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule">Greenspun’s tenth rule</a>, such hand-made metalanguages are typically “ad-hoc, informally-specified, bug-ridden, and slow,” with quite vague semantics and awful documentation. The concept of a metalinguistic abstraction simply does not work, albeit the rationale of creating declarative, small domain-specific languages sounds so cool at first sight. Have you ever tried to use a sophisticated type or macro API? If yes, then you should be perfectly acquainted with inscrutable compiler diagnostics, which can be summarised in the following screenshot:<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p><img src="../media/whats-the-point-of-the-c-preprocessor-actually/2.jpg" /></p>
<p>This is woefully to say, but it seems that an “expressive” PL nowadays means “Hey there, I have seriously messed up with the number of features, but that is fine!”</p>
<p>Finally, a word has to be said about metaprogramming in a host language. With such systems as <a href="https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial">Template Haskell</a> and <a href="https://doc.rust-lang.org/reference/procedural-macros.html">Rust’s procedural macros</a>, we can manipulate an AST of a host language using the same language, which is good in terms of biformity but unpleasant in terms of inconsistency. Macros are not functions: we cannot partially apply a macro and obtain a partially applied function, since they are just different concepts. Personally, I do think that procedural macros in Rust are a giant design mistake that is comparable to <code>#define</code> macros in plain C: aside from pure syntax, the macro system simply has no idea about the language being manipulated. E.g., imagine there is an enumeration called <code>Either</code>, whose definition is as follows:</p>
<p class="code-annotation">
<code>either.rs</code>
</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> Either<span class="op">&lt;</span>L<span class="op">,</span> R<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    Left(L)<span class="op">,</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    Right(R)<span class="op">,</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p class="adapted-from">
Adapted from <a href="https://docs.rs/either/latest/either/enum.Either.html">either::Either</a>.
</p>
<p>Now imagine we have an arbitrary trait <code>Foo</code>, and we are willing to implement this trait for <code>Either&lt;L, R&gt;</code>, where <code>L</code> and <code>R</code> both implement <code>Foo</code>. It turns out that we cannot apply a derive macro to <code>Either</code> that implements this trait, even if the name is known because, in order to do this, this macro must know all the signatures of <code>Foo</code>. To make the situation even worse, <code>Foo</code> may be defined in a separate library, meaning that we cannot augment its definition with extra meta-information needed for the derivation for <code>Either&lt;L, R&gt;</code>. While it may seem as a rare scanario, in fact it is not; I highly encourage you to look at <a href="https://docs.rs/tokio-util/latest/tokio_util/">tokio-util</a>’s <a href="https://docs.rs/tokio-util/latest/tokio_util/either/enum.Either.html"><code>Either</code></a>, which is <strong>exactly</strong> the same enumeration but it implements Tokio-specific traits, such as <code>AsyncRead</code>, <code>AsyncWrite</code>, <code>AsyncSeek</code>, etc.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Now imagine you have five different <code>Either</code>s in your project that came from different libraries – that would be a true integration headache! While type introspection may be a compromise, it would nonetheless make the language even more complex than it already is.</p>
<h2 id="is-there-a-way-out">Is there a way out?…</h2>
<p>Let us think a little bit about how to workaround the issue. If we make our languages fully dynamic, we will win biformity and inconsistency,<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> but will imminently lose the pleasure of compile-time validation and will end up debugging our programs at mid-nights. The misery of dynamic type systems is widely known.</p>
<p>The only way to approach the problem is to make a language whose features are both static and dynamic and not to split the same feature into two parts.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> Thus, the ideal linguistic abstraction is both static and dynamic; however, it is still a single concept and not two logically similar concepts but with different interfaces.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> A perfect example is <a href="https://en.wikipedia.org/wiki/Compile-time_function_execution">CTFE</a>, colloquially known as <code>constexpr</code>: same code can be executed at compile-time under a static context and at run-time under a dynamic context (e.g., when requesting a user input from <code>stdin</code>.); thus, we do not have to write different code for compile-time (statics) and run-time (dynamics), instead we use the same representation.</p>
<p>Static languages enforce compile-time checks; this is good. But they suffer from feature biformity and inconsistency – this is bad. Dynamic languages, on the other hand, suffer from these drawbacks to a lesser extent, but they lack compile-time checks. A hypothetical solution should take the best from the both worlds.</p>
<p>Programming languages ought to be rethought.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Generics are sometimes called “type variables,” which highlights their natural correspondence to ordinary variables.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Got it while working on <a href="https://github.com/teloxide/teloxide">teloxide</a>, IIRC.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>It is even more of comedy that initially, I wrote a third-party crate called <a href="https://github.com/hirrolot/tokio-either">tokio-either</a>, which just contained that <code>Either</code> with several trait implementations. Only later, the Tokio maintainers <a href="https://github.com/tokio-rs/tokio/pull/2821">decided</a> to move it to tokio-util.<br><br>As of Jan. 4 2022, tokio-either has 5,394 downloads total.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Terra is a perfect example of a simple dynamic language. In the <a href="https://terralang.org/#simplicity">“Simplicity” section</a>, they show how features of static PLs can be implemented as libraries in dynamic languages.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>To achieve so, we could use <a href="https://www.idris-lang.org/">dependent types</a>. For example, when requesting a field value from a hash map, as in one of the examples above, the <code>get</code> function will request a <em>proof</em> that the field actually exists in that hash map; this way, the check will be performed at compile-time, using the same hash map that we use at run-time. Dependent types, however, are still too low-level to me, and I hardly believe that they will find their production use in their current form. With such powerful typing facilities, you typically twiddle with your type system instead of focusing on business logic.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Multiple personality disorder? 🤨<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<script src="https://utteranc.es/client.js" repo="hirrolot/hirrolot.github.io" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
</body>
</html>
