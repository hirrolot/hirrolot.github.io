<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="hirrolot">
  <title>Compiler Development: Rust or OCaml?</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
  <link href="https://necolas.github.io/normalize.css/8.0.1/normalize.css" rel="stylesheet">

  <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Caveat&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Luxurious+Roman&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Alex+Brush&amp;display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="../myself.png" type="image/x-icon">
  <script src="../script.js"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<a class="header-link" href="#"><h1 class="title">Compiler Development: Rust or OCaml?</h1></a>
<p class="author">hirrolot</p>
<p class="date">Aug 6, 2023</p>
</header>
<div class="introduction">
<p class="discussions">
<a href="https://news.ycombinator.com/item?id=37026757">HN</a> · <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/15jpmxe/compiler_development_rust_or_ocaml/">r/ProgrammingLanguages</a>
· <a href="https://lobste.rs/s/yfyub2/compiler_development_rust_ocaml">Lobsters</a>
</p>
<p>The question of which language suits best for compiler development is
a frequent one amongst language enthusiasts (e.g., see discussions <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/k3zgjy/which_language_to_write_a_compiler_in/">here</a>,
<a href="https://www.reddit.com/r/ProgrammingLanguages/comments/13eztdp/good_languages_for_writing_compilers_in/">here</a>,
and <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/15gz8rb/how_good_is_go_for_writing_a_compiler/">here</a>).
Sadly, most of the commenters either 1) just answer with their language
of choice without any explanation, or 2) provide a vague explanation
without any specific examples to prove their point of view. Both types
of answers serve little to no purpose for the person asking the
question. In this essay, I will try to provide a more detailed
perspective on the topic by comparing two languages: Rust and OCaml.</p>
</div><nav id="TOC" role="doc-toc" style="display: block;"><h4 class="toc-title">Table of Contents</h4>
<ul>
<li><a href="#cps-conversion">CPS conversion</a></li>
<li><a href="#comparing-the-two-implementations">Comparing the two
implementations</a></li>
<li><a href="#type-safety-gadts">Type safety: GADTs</a></li>
<li><a href="#type-flexibility-first-class-modules">Type flexibility:
First-class modules</a></li>
<li><a href="#final-words">Final words</a></li>
<li><a href="#appendix-getting-started-with-ocaml">Appendix: Getting
started with OCaml</a></li>
<li><a href="#references">References</a></li>
</ul>
</nav>






















































































<div class="post-body"><a class="header-link" href="#cps-conversion"><h2 id="cps-conversion">CPS conversion</h2></a><p>Before presenting my actual argument, I will show two analogous
implementations of <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">CPS</a>
conversion <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> for a very simple language, without
making any conclusions. The general approach is borrowed from <a href="https://www.amazon.com/Compiling-Continuations-Andrew-W-Appel/dp/052103311X">“Compiling
with Continuations”</a> by Andrew W. Appel. No worries if you are not
familiar with the idea; the only thing to focus your attention on is
<em>how</em> the idea is implemented in both Rust and OCaml.</p><p>Here is CPS conversion written in Rust <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>:</p><div class="sourceCode" id="cb1"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">use</span> <span class="pp">std::cell::</span>RefCell<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">use</span> <span class="pp">std::ops::</span><span class="bu">Deref</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">use</span> <span class="pp">std::rc::</span>Rc<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">// A variable identifier of the lambda language `Term`.</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">type</span> Var <span class="op">=</span> <span class="dt">String</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co">// The lambda language; direct style.</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">type</span> Term <span class="op">=</span> Rc<span class="op">&lt;</span>TermTree<span class="op">&gt;;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">enum</span> TermTree <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    Var(Var)<span class="op">,</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>    Fix(<span class="dt">Vec</span><span class="op">&lt;</span>(Var<span class="op">,</span> <span class="dt">Vec</span><span class="op">&lt;</span>Var<span class="op">&gt;,</span> Term)<span class="op">&gt;,</span> Term)<span class="op">,</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>    Appl(Term<span class="op">,</span> <span class="dt">Vec</span><span class="op">&lt;</span>Term<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>    Record(<span class="dt">Vec</span><span class="op">&lt;</span>Term<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>    Select(Term<span class="op">,</span> <span class="dt">u32</span>)<span class="op">,</span></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="op">}</span></span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="kw">use</span> <span class="pp">TermTree::</span><span class="op">*;</span></span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="at">)]</span></span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="kw">enum</span> CpsVar <span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="co">// Taken from the lambda term during CPS conversion.</span></span>
<span id="cb1-24"><a href="#cb1-24"></a>    CLamVar(Var)<span class="op">,</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>    <span class="co">// Generated uniquely during CPS conversion.</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>    CGenVar(<span class="dt">u32</span>)<span class="op">,</span></span>
<span id="cb1-27"><a href="#cb1-27"></a><span class="op">}</span></span>
<span id="cb1-28"><a href="#cb1-28"></a></span>
<span id="cb1-29"><a href="#cb1-29"></a><span class="kw">use</span> <span class="pp">CpsVar::</span><span class="op">*;</span></span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a><span class="co">// The resulting CPS term.</span></span>
<span id="cb1-32"><a href="#cb1-32"></a><span class="kw">enum</span> CpsTerm <span class="op">{</span></span>
<span id="cb1-33"><a href="#cb1-33"></a>    CFix(<span class="dt">Vec</span><span class="op">&lt;</span>(CpsVar<span class="op">,</span> <span class="dt">Vec</span><span class="op">&lt;</span>CpsVar<span class="op">&gt;,</span> CpsTerm)<span class="op">&gt;,</span> <span class="dt">Box</span><span class="op">&lt;</span>CpsTerm<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb1-34"><a href="#cb1-34"></a>    CAppl(CpsVar<span class="op">,</span> <span class="dt">Vec</span><span class="op">&lt;</span>CpsVar<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb1-35"><a href="#cb1-35"></a>    CRecord(<span class="dt">Vec</span><span class="op">&lt;</span>CpsVar<span class="op">&gt;,</span> Binder)<span class="op">,</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>    CSelect(CpsVar<span class="op">,</span> <span class="dt">u32</span><span class="op">,</span> Binder)<span class="op">,</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>    CHalt(CpsVar)<span class="op">,</span></span>
<span id="cb1-38"><a href="#cb1-38"></a><span class="op">}</span></span>
<span id="cb1-39"><a href="#cb1-39"></a></span>
<span id="cb1-40"><a href="#cb1-40"></a><span class="kw">use</span> <span class="pp">CpsTerm::</span><span class="op">*;</span></span>
<span id="cb1-41"><a href="#cb1-41"></a></span>
<span id="cb1-42"><a href="#cb1-42"></a><span class="co">// Binds a unique `CpsVar` within `CpsTerm`.</span></span>
<span id="cb1-43"><a href="#cb1-43"></a><span class="kw">type</span> Binder <span class="op">=</span> (CpsVar<span class="op">,</span> <span class="dt">Box</span><span class="op">&lt;</span>CpsTerm<span class="op">&gt;</span>)<span class="op">;</span></span>
<span id="cb1-44"><a href="#cb1-44"></a></span>
<span id="cb1-45"><a href="#cb1-45"></a><span class="co">// Generates a unique CPS variable given the current `i`.</span></span>
<span id="cb1-46"><a href="#cb1-46"></a><span class="kw">fn</span> gensym(i<span class="op">:</span> RefCell<span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> CpsVar <span class="op">{</span></span>
<span id="cb1-47"><a href="#cb1-47"></a>    <span class="kw">let</span> x <span class="op">=</span> CGenVar(i<span class="op">.</span>clone()<span class="op">.</span>into_inner())<span class="op">;</span></span>
<span id="cb1-48"><a href="#cb1-48"></a>    i<span class="op">.</span>replace_with(<span class="op">|&amp;</span><span class="kw">mut</span> i<span class="op">|</span> i <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb1-49"><a href="#cb1-49"></a>    x</span>
<span id="cb1-50"><a href="#cb1-50"></a><span class="op">}</span></span>
<span id="cb1-51"><a href="#cb1-51"></a></span>
<span id="cb1-52"><a href="#cb1-52"></a><span class="co">// Converts `Term` to `CpsTerm`, applying `finish` to the resulting</span></span>
<span id="cb1-53"><a href="#cb1-53"></a><span class="co">// CPS variable.</span></span>
<span id="cb1-54"><a href="#cb1-54"></a><span class="kw">fn</span> convert(gen<span class="op">:</span> RefCell<span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;,</span> finish<span class="op">:</span> <span class="kw">impl</span> <span class="bu">FnOnce</span>(CpsVar) <span class="op">-&gt;</span> CpsTerm<span class="op">,</span> term<span class="op">:</span> Term) <span class="op">-&gt;</span> CpsTerm <span class="op">{</span></span>
<span id="cb1-55"><a href="#cb1-55"></a>    <span class="cf">match</span> term<span class="op">.</span>deref() <span class="op">{</span></span>
<span id="cb1-56"><a href="#cb1-56"></a>        Var(x) <span class="op">=&gt;</span> finish(CLamVar(x<span class="op">.</span>to_string()))<span class="op">,</span></span>
<span id="cb1-57"><a href="#cb1-57"></a>        Fix(defs<span class="op">,</span> m) <span class="op">=&gt;</span> CFix(</span>
<span id="cb1-58"><a href="#cb1-58"></a>            defs<span class="op">.</span>iter()</span>
<span id="cb1-59"><a href="#cb1-59"></a>                <span class="op">.</span>map(<span class="op">|</span>def<span class="op">|</span> convert_def(gen<span class="op">.</span>clone()<span class="op">,</span> def<span class="op">.</span>clone()))</span>
<span id="cb1-60"><a href="#cb1-60"></a>                <span class="op">.</span>collect()<span class="op">,</span></span>
<span id="cb1-61"><a href="#cb1-61"></a>            <span class="dt">Box</span><span class="pp">::</span>new(convert(gen<span class="op">,</span> finish<span class="op">,</span> m<span class="op">.</span>clone()))<span class="op">,</span></span>
<span id="cb1-62"><a href="#cb1-62"></a>        )<span class="op">,</span></span>
<span id="cb1-63"><a href="#cb1-63"></a>        Appl(f<span class="op">,</span> args) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb1-64"><a href="#cb1-64"></a>            <span class="kw">let</span> ret_k <span class="op">=</span> gensym(gen<span class="op">.</span>clone())<span class="op">;</span></span>
<span id="cb1-65"><a href="#cb1-65"></a>            <span class="kw">let</span> ret_k_x <span class="op">=</span> gensym(gen<span class="op">.</span>clone())<span class="op">;</span></span>
<span id="cb1-66"><a href="#cb1-66"></a>            CFix(</span>
<span id="cb1-67"><a href="#cb1-67"></a>                <span class="pp">vec!</span>[(ret_k<span class="op">.</span>clone()<span class="op">,</span> <span class="pp">vec!</span>[ret_k_x<span class="op">.</span>clone()]<span class="op">,</span> finish(ret_k_x))]<span class="op">,</span></span>
<span id="cb1-68"><a href="#cb1-68"></a>                <span class="dt">Box</span><span class="pp">::</span>new(convert(</span>
<span id="cb1-69"><a href="#cb1-69"></a>                    gen<span class="op">.</span>clone()<span class="op">,</span></span>
<span id="cb1-70"><a href="#cb1-70"></a>                    <span class="op">|</span>f_cps<span class="op">|</span> <span class="op">{</span></span>
<span id="cb1-71"><a href="#cb1-71"></a>                        convert_list(</span>
<span id="cb1-72"><a href="#cb1-72"></a>                            gen<span class="op">,</span></span>
<span id="cb1-73"><a href="#cb1-73"></a>                            <span class="op">|</span>args_cps<span class="op">|</span> <span class="op">{</span></span>
<span id="cb1-74"><a href="#cb1-74"></a>                                CAppl(f_cps<span class="op">,</span> args_cps<span class="op">.</span>into_iter()<span class="op">.</span>chain(<span class="pp">vec!</span>[ret_k])<span class="op">.</span>collect())</span>
<span id="cb1-75"><a href="#cb1-75"></a>                            <span class="op">},</span></span>
<span id="cb1-76"><a href="#cb1-76"></a>                            args<span class="op">,</span></span>
<span id="cb1-77"><a href="#cb1-77"></a>                        )</span>
<span id="cb1-78"><a href="#cb1-78"></a>                    <span class="op">},</span></span>
<span id="cb1-79"><a href="#cb1-79"></a>                    f<span class="op">.</span>clone()<span class="op">,</span></span>
<span id="cb1-80"><a href="#cb1-80"></a>                ))<span class="op">,</span></span>
<span id="cb1-81"><a href="#cb1-81"></a>            )</span>
<span id="cb1-82"><a href="#cb1-82"></a>        <span class="op">}</span></span>
<span id="cb1-83"><a href="#cb1-83"></a>        Record(fields) <span class="op">=&gt;</span> convert_list(</span>
<span id="cb1-84"><a href="#cb1-84"></a>            gen<span class="op">.</span>clone()<span class="op">,</span></span>
<span id="cb1-85"><a href="#cb1-85"></a>            <span class="op">|</span>fields_cps<span class="op">|</span> <span class="op">{</span></span>
<span id="cb1-86"><a href="#cb1-86"></a>                <span class="kw">let</span> x <span class="op">=</span> gensym(gen)<span class="op">;</span></span>
<span id="cb1-87"><a href="#cb1-87"></a>                CRecord(fields_cps<span class="op">,</span> (x<span class="op">.</span>clone()<span class="op">,</span> <span class="dt">Box</span><span class="pp">::</span>new(finish(x))))</span>
<span id="cb1-88"><a href="#cb1-88"></a>            <span class="op">},</span></span>
<span id="cb1-89"><a href="#cb1-89"></a>            fields<span class="op">,</span></span>
<span id="cb1-90"><a href="#cb1-90"></a>        )<span class="op">,</span></span>
<span id="cb1-91"><a href="#cb1-91"></a>        Select(m<span class="op">,</span> i) <span class="op">=&gt;</span> convert(</span>
<span id="cb1-92"><a href="#cb1-92"></a>            gen<span class="op">.</span>clone()<span class="op">,</span></span>
<span id="cb1-93"><a href="#cb1-93"></a>            <span class="op">|</span>m_cps<span class="op">|</span> <span class="op">{</span></span>
<span id="cb1-94"><a href="#cb1-94"></a>                <span class="kw">let</span> x <span class="op">=</span> gensym(gen)<span class="op">;</span></span>
<span id="cb1-95"><a href="#cb1-95"></a>                CSelect(m_cps<span class="op">,</span> <span class="op">*</span>i<span class="op">,</span> (x<span class="op">.</span>clone()<span class="op">,</span> <span class="dt">Box</span><span class="pp">::</span>new(finish(x))))</span>
<span id="cb1-96"><a href="#cb1-96"></a>            <span class="op">},</span></span>
<span id="cb1-97"><a href="#cb1-97"></a>            m<span class="op">.</span>clone()<span class="op">,</span></span>
<span id="cb1-98"><a href="#cb1-98"></a>        )<span class="op">,</span></span>
<span id="cb1-99"><a href="#cb1-99"></a>    <span class="op">}</span></span>
<span id="cb1-100"><a href="#cb1-100"></a><span class="op">}</span></span>
<span id="cb1-101"><a href="#cb1-101"></a></span>
<span id="cb1-102"><a href="#cb1-102"></a><span class="co">// Converts `Vec&lt;Term&gt;` to `Vec&lt;CpsVar&gt;` and applies `finish` to it.</span></span>
<span id="cb1-103"><a href="#cb1-103"></a><span class="kw">fn</span> convert_list(</span>
<span id="cb1-104"><a href="#cb1-104"></a>    gen<span class="op">:</span> RefCell<span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;,</span></span>
<span id="cb1-105"><a href="#cb1-105"></a>    finish<span class="op">:</span> <span class="kw">impl</span> <span class="bu">FnOnce</span>(<span class="dt">Vec</span><span class="op">&lt;</span>CpsVar<span class="op">&gt;</span>) <span class="op">-&gt;</span> CpsTerm<span class="op">,</span></span>
<span id="cb1-106"><a href="#cb1-106"></a>    terms<span class="op">:</span> <span class="op">&amp;</span>[Term]<span class="op">,</span></span>
<span id="cb1-107"><a href="#cb1-107"></a>) <span class="op">-&gt;</span> CpsTerm <span class="op">{</span></span>
<span id="cb1-108"><a href="#cb1-108"></a>    <span class="kw">fn</span> go(</span>
<span id="cb1-109"><a href="#cb1-109"></a>        gen<span class="op">:</span> RefCell<span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;,</span></span>
<span id="cb1-110"><a href="#cb1-110"></a>        finish<span class="op">:</span> <span class="kw">impl</span> <span class="bu">FnOnce</span>(<span class="dt">Vec</span><span class="op">&lt;</span>CpsVar<span class="op">&gt;</span>) <span class="op">-&gt;</span> CpsTerm<span class="op">,</span></span>
<span id="cb1-111"><a href="#cb1-111"></a>        <span class="kw">mut</span> acc<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>CpsVar<span class="op">&gt;,</span></span>
<span id="cb1-112"><a href="#cb1-112"></a>        terms<span class="op">:</span> <span class="op">&amp;</span>[Term]<span class="op">,</span></span>
<span id="cb1-113"><a href="#cb1-113"></a>    ) <span class="op">-&gt;</span> CpsTerm <span class="op">{</span></span>
<span id="cb1-114"><a href="#cb1-114"></a>        <span class="cf">match</span> terms<span class="op">.</span>split_first() <span class="op">{</span></span>
<span id="cb1-115"><a href="#cb1-115"></a>            <span class="cn">None</span> <span class="op">=&gt;</span> finish(acc)<span class="op">,</span></span>
<span id="cb1-116"><a href="#cb1-116"></a>            <span class="cn">Some</span>((x<span class="op">,</span> xs)) <span class="op">=&gt;</span> convert(</span>
<span id="cb1-117"><a href="#cb1-117"></a>                gen<span class="op">.</span>clone()<span class="op">,</span></span>
<span id="cb1-118"><a href="#cb1-118"></a>                <span class="op">|</span>x_cps<span class="op">|</span> <span class="op">{</span></span>
<span id="cb1-119"><a href="#cb1-119"></a>                    acc<span class="op">.</span>push(x_cps)<span class="op">;</span></span>
<span id="cb1-120"><a href="#cb1-120"></a>                    go(gen<span class="op">,</span> finish<span class="op">,</span> acc<span class="op">,</span> xs)</span>
<span id="cb1-121"><a href="#cb1-121"></a>                <span class="op">},</span></span>
<span id="cb1-122"><a href="#cb1-122"></a>                x<span class="op">.</span>clone()<span class="op">,</span></span>
<span id="cb1-123"><a href="#cb1-123"></a>            )<span class="op">,</span></span>
<span id="cb1-124"><a href="#cb1-124"></a>        <span class="op">}</span></span>
<span id="cb1-125"><a href="#cb1-125"></a>    <span class="op">}</span></span>
<span id="cb1-126"><a href="#cb1-126"></a>    <span class="kw">let</span> acc <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>with_capacity(terms<span class="op">.</span>len())<span class="op">;</span></span>
<span id="cb1-127"><a href="#cb1-127"></a>    go(gen<span class="op">,</span> finish<span class="op">,</span> acc<span class="op">,</span> terms)</span>
<span id="cb1-128"><a href="#cb1-128"></a><span class="op">}</span></span>
<span id="cb1-129"><a href="#cb1-129"></a></span>
<span id="cb1-130"><a href="#cb1-130"></a><span class="co">// Converts a single function definition to its CPS form.</span></span>
<span id="cb1-131"><a href="#cb1-131"></a><span class="kw">fn</span> convert_def(</span>
<span id="cb1-132"><a href="#cb1-132"></a>    gen<span class="op">:</span> RefCell<span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;,</span></span>
<span id="cb1-133"><a href="#cb1-133"></a>    (f<span class="op">,</span> params<span class="op">,</span> m)<span class="op">:</span> (Var<span class="op">,</span> <span class="dt">Vec</span><span class="op">&lt;</span>Var<span class="op">&gt;,</span> Term)<span class="op">,</span></span>
<span id="cb1-134"><a href="#cb1-134"></a>) <span class="op">-&gt;</span> (CpsVar<span class="op">,</span> <span class="dt">Vec</span><span class="op">&lt;</span>CpsVar<span class="op">&gt;,</span> CpsTerm) <span class="op">{</span></span>
<span id="cb1-135"><a href="#cb1-135"></a>    <span class="kw">let</span> k <span class="op">=</span> gensym(gen<span class="op">.</span>clone())<span class="op">;</span></span>
<span id="cb1-136"><a href="#cb1-136"></a>    (</span>
<span id="cb1-137"><a href="#cb1-137"></a>        CLamVar(f)<span class="op">,</span></span>
<span id="cb1-138"><a href="#cb1-138"></a>        params</span>
<span id="cb1-139"><a href="#cb1-139"></a>            <span class="op">.</span>into_iter()</span>
<span id="cb1-140"><a href="#cb1-140"></a>            <span class="op">.</span>map(CLamVar)</span>
<span id="cb1-141"><a href="#cb1-141"></a>            <span class="op">.</span>chain(<span class="pp">std::iter::</span>once(k<span class="op">.</span>clone()))</span>
<span id="cb1-142"><a href="#cb1-142"></a>            <span class="op">.</span>collect()<span class="op">,</span></span>
<span id="cb1-143"><a href="#cb1-143"></a>        convert(gen<span class="op">,</span> <span class="op">|</span>m_cps<span class="op">|</span> CAppl(k<span class="op">,</span> <span class="pp">vec!</span>[m_cps])<span class="op">,</span> m)<span class="op">,</span></span>
<span id="cb1-144"><a href="#cb1-144"></a>    )</span>
<span id="cb1-145"><a href="#cb1-145"></a><span class="op">}</span></span></code></pre></div><p>The code is 145 lines long, including comments and blank lines.</p><p>The same algorithm in idiomatic OCaml <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>:</p><div class="sourceCode" id="cb2"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">(* A variable identifier of the lambda language [term]. *)</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">type</span> var = <span class="dt">string</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">(* The lambda language; direct style. *)</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">type</span> term =</span>
<span id="cb2-6"><a href="#cb2-6"></a>  | Var <span class="kw">of</span> var</span>
<span id="cb2-7"><a href="#cb2-7"></a>  | Fix <span class="kw">of</span> (var * var <span class="dt">list</span> * term) <span class="dt">list</span> * term</span>
<span id="cb2-8"><a href="#cb2-8"></a>  | Appl <span class="kw">of</span> term * term <span class="dt">list</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>  | Record <span class="kw">of</span> term <span class="dt">list</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>  | Select <span class="kw">of</span> term * <span class="dt">int</span></span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="kw">type</span> cps_var =</span>
<span id="cb2-13"><a href="#cb2-13"></a>  <span class="co">(* Taken from the lambda term during CPS conversion. *)</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>  | CLamVar <span class="kw">of</span> var</span>
<span id="cb2-15"><a href="#cb2-15"></a>  <span class="co">(* Generated uniquely during CPS conversion. *)</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>  | CGenVar <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb2-17"><a href="#cb2-17"></a></span>
<span id="cb2-18"><a href="#cb2-18"></a><span class="co">(* The resulting CPS term. *)</span></span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="kw">type</span> cps_term =</span>
<span id="cb2-20"><a href="#cb2-20"></a>  | CFix <span class="kw">of</span> (cps_var * cps_var <span class="dt">list</span> * cps_term) <span class="dt">list</span> * cps_term</span>
<span id="cb2-21"><a href="#cb2-21"></a>  | CAppl <span class="kw">of</span> cps_var * cps_var <span class="dt">list</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>  | CRecord <span class="kw">of</span> cps_var <span class="dt">list</span> * binder</span>
<span id="cb2-23"><a href="#cb2-23"></a>  | CSelect <span class="kw">of</span> cps_var * <span class="dt">int</span> * binder</span>
<span id="cb2-24"><a href="#cb2-24"></a>  | CHalt <span class="kw">of</span> cps_var</span>
<span id="cb2-25"><a href="#cb2-25"></a></span>
<span id="cb2-26"><a href="#cb2-26"></a><span class="co">(* Binds a unique [cps_var] within [cps_term]. *)</span></span>
<span id="cb2-27"><a href="#cb2-27"></a><span class="kw">and</span> binder = cps_var * cps_term</span>
<span id="cb2-28"><a href="#cb2-28"></a></span>
<span id="cb2-29"><a href="#cb2-29"></a><span class="co">(* Generates a unique CPS variable given the current [i]. *)</span></span>
<span id="cb2-30"><a href="#cb2-30"></a><span class="kw">let</span> gensym i =</span>
<span id="cb2-31"><a href="#cb2-31"></a>  <span class="kw">let</span> x = CGenVar !i <span class="kw">in</span></span>
<span id="cb2-32"><a href="#cb2-32"></a>  i := !i + <span class="dv">1</span>;</span>
<span id="cb2-33"><a href="#cb2-33"></a>  x</span>
<span id="cb2-34"><a href="#cb2-34"></a></span>
<span id="cb2-35"><a href="#cb2-35"></a><span class="co">(* Converts [term] to [cps_term], applying [finish] to the resulting</span></span>
<span id="cb2-36"><a href="#cb2-36"></a><span class="co">   CPS variable. *)</span></span>
<span id="cb2-37"><a href="#cb2-37"></a><span class="kw">let</span> <span class="kw">rec</span> convert gen finish = <span class="kw">function</span></span>
<span id="cb2-38"><a href="#cb2-38"></a>  | Var x -&gt; finish (CLamVar x)</span>
<span id="cb2-39"><a href="#cb2-39"></a>  | Fix (defs, m) -&gt; CFix (<span class="dt">List</span>.map (convert_def gen) defs, convert gen finish m)</span>
<span id="cb2-40"><a href="#cb2-40"></a>  | Appl (f, args) -&gt;</span>
<span id="cb2-41"><a href="#cb2-41"></a>      <span class="kw">let</span> ret_k = gensym gen <span class="kw">in</span></span>
<span id="cb2-42"><a href="#cb2-42"></a>      <span class="kw">let</span> ret_k_x = gensym gen <span class="kw">in</span></span>
<span id="cb2-43"><a href="#cb2-43"></a>      CFix</span>
<span id="cb2-44"><a href="#cb2-44"></a>        ( [ (ret_k, [ ret_k_x ], finish ret_k_x) ],</span>
<span id="cb2-45"><a href="#cb2-45"></a>          f</span>
<span id="cb2-46"><a href="#cb2-46"></a>          |&gt; convert gen (<span class="kw">fun</span> f_cps -&gt;</span>
<span id="cb2-47"><a href="#cb2-47"></a>                 args</span>
<span id="cb2-48"><a href="#cb2-48"></a>                 |&gt; convert_list gen (<span class="kw">fun</span> args_cps -&gt;</span>
<span id="cb2-49"><a href="#cb2-49"></a>                        CAppl (f_cps, args_cps @ [ ret_k ]))) )</span>
<span id="cb2-50"><a href="#cb2-50"></a>  | Record fields -&gt;</span>
<span id="cb2-51"><a href="#cb2-51"></a>      fields</span>
<span id="cb2-52"><a href="#cb2-52"></a>      |&gt; convert_list gen (<span class="kw">fun</span> fields_cps -&gt;</span>
<span id="cb2-53"><a href="#cb2-53"></a>             <span class="kw">let</span> x = gensym gen <span class="kw">in</span></span>
<span id="cb2-54"><a href="#cb2-54"></a>             CRecord (fields_cps, (x, finish x)))</span>
<span id="cb2-55"><a href="#cb2-55"></a>  | Select (m, i) -&gt;</span>
<span id="cb2-56"><a href="#cb2-56"></a>      m</span>
<span id="cb2-57"><a href="#cb2-57"></a>      |&gt; convert gen (<span class="kw">fun</span> m_cps -&gt;</span>
<span id="cb2-58"><a href="#cb2-58"></a>             <span class="kw">let</span> x = gensym gen <span class="kw">in</span></span>
<span id="cb2-59"><a href="#cb2-59"></a>             CSelect (m_cps, i, (x, finish x)))</span>
<span id="cb2-60"><a href="#cb2-60"></a></span>
<span id="cb2-61"><a href="#cb2-61"></a><span class="co">(* Converts [term list] to [cps_var list] and applies [finish] to it. *)</span></span>
<span id="cb2-62"><a href="#cb2-62"></a><span class="kw">and</span> convert_list gen finish =</span>
<span id="cb2-63"><a href="#cb2-63"></a>  <span class="kw">let</span> <span class="kw">rec</span> go acc = <span class="kw">function</span></span>
<span id="cb2-64"><a href="#cb2-64"></a>    | [] -&gt; finish (<span class="dt">List</span>.rev acc)</span>
<span id="cb2-65"><a href="#cb2-65"></a>    | x :: xs -&gt; x |&gt; convert gen (<span class="kw">fun</span> x_cps -&gt; go (x_cps :: acc) xs)</span>
<span id="cb2-66"><a href="#cb2-66"></a>  <span class="kw">in</span></span>
<span id="cb2-67"><a href="#cb2-67"></a>  go []</span>
<span id="cb2-68"><a href="#cb2-68"></a></span>
<span id="cb2-69"><a href="#cb2-69"></a><span class="co">(* Converts a single function definition to its CPS form. *)</span></span>
<span id="cb2-70"><a href="#cb2-70"></a><span class="kw">and</span> convert_def gen (f, params, m) =</span>
<span id="cb2-71"><a href="#cb2-71"></a>  <span class="kw">let</span> k = gensym gen <span class="kw">in</span></span>
<span id="cb2-72"><a href="#cb2-72"></a>  ( CLamVar f,</span>
<span id="cb2-73"><a href="#cb2-73"></a>    <span class="dt">List</span>.map (<span class="kw">fun</span> x -&gt; CLamVar x) params @ [ k ],</span>
<span id="cb2-74"><a href="#cb2-74"></a>    m |&gt; convert gen (<span class="kw">fun</span> m_cps -&gt; CAppl (k, [ m_cps ])) )</span></code></pre></div><p>The code is 74 lines long, including comments and blank lines. This
is ~2.0 times shorter than the Rust version.</p><a class="header-link" href="#comparing-the-two-implementations"><h2 id="comparing-the-two-implementations">Comparing the two
implementations</h2></a><p>Compiler development is characterized by:</p><ol type="1">
<li>a lot of recursively defined data structures,</li>
<li>a lot of complex data transformation.</li>
</ol><p>How do Rust and OCaml handle these two aspects? Below is a brief
summary:</p><ol type="1">
<li>Recursive data structures:
<ol type="1">
<li><strong>OCaml</strong>: recursive data structures are supported
natively.</li>
<li><strong>Rust</strong>: we need to imitate data recursion by wrapping
recursive occurences of <code>TermTree</code> and <code>CpsTerm</code>
into <code>Rc</code>s <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> and <code>Box</code>es.</li>
</ol></li>
<li>Complex data transformation:
<ol type="1">
<li><strong>OCaml</strong>:
<ul>
<li>Recursion is a common practice. OCaml has tail-call optimization and
<a href="https://v2.ocaml.org/manual/tail_mod_cons.html">“Tail Modulo
Constructor (TMC)”</a> optimization.</li>
<li>Pattern matching is made very ergonomic. With <code>function</code>,
we can pattern-match the “last parameter” <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> of
a function without introducing any extra indentation.
(<code>function</code> also lets us omit the last parameter with
oftentimes a dummy name like <code>term</code>; if you think the
parameter name is useful, you can write it in the signature.) Lists can
be matched as simply as <code>| [] -&gt; ...</code> and
<code>| x :: xs -&gt; ...</code> without further hussle.</li>
<li>The majority of standard data structures are immutable. This makes
it easy to reason about the code.</li>
</ul></li>
<li><strong>Rust</strong>:
<ul>
<li>Recursion is uncommon. TCO is <a href="https://stackoverflow.com/questions/59257543/when-is-tail-recursion-guaranteed-in-rust">not
guaranteed</a> (compare it with OCaml’s <a href="https://stackoverflow.com/questions/23186717/verify-that-an-ocaml-function-is-tail-recursive"><code>[@tailcall]</code></a>
and <a href="https://v2.ocaml.org/manual/tail_mod_cons.html"><code>[@tail_mod_cons]</code></a>
annotations).</li>
<li>Pattern matching requires extra indentation and the need to
explicate the matched parameter. There are several ways to “match”
vectors, but they all are more verbose than OCaml’s built-in
syntax.</li>
<li>The majority of standard data structures are mutable, which inclines
us towards the imperative style instead of the applicative style.
Iterators provide us with a hatch to write code in the pipelined
fashion, but first we need to
<code>.iter()</code>/<code>.iter_mut()</code>/<code>.into_iter()</code>
the data structure, perform the work, and then
<code>.collect()</code>.</li>
</ul></li>
</ol></li>
</ol><p>In addition to being syntactically more verbose than OCaml, Rust is a
language without garbage collection. This forces us to make certain
explicit choices about memory management: you can observe the plentitude
of plumbing with boxes, references (both <code>&amp;</code> and
<code>Rc</code>), cloning, etc. Although it provides us with a greater
sense of <em>how</em> the code is executing, it brings very little value
to the algorithm itself.</p><p>Even mutation can be more challenging in Rust:</p><div class="sourceCode" id="cb3"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">fn</span> gensym(i<span class="op">:</span> RefCell<span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> CpsVar <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="kw">let</span> x <span class="op">=</span> CGenVar(i<span class="op">.</span>clone()<span class="op">.</span>into_inner())<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    i<span class="op">.</span>replace_with(<span class="op">|&amp;</span><span class="kw">mut</span> i<span class="op">|</span> i <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    x</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="op">}</span></span></code></pre></div><p>In OCaml, it is just:</p><div class="sourceCode" id="cb4"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">let</span> gensym i =</span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="kw">let</span> x = CGenVar !i <span class="kw">in</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>  i := !i + <span class="dv">1</span>;</span>
<span id="cb4-4"><a href="#cb4-4"></a>  x</span></code></pre></div><p>Why <code>RefCell&lt;u32&gt;</code> instead of
<code>&amp;mut u32</code>? Because Rust requires us to have a single
mutable reference to a value at any given time. This is a very
reasonable requirement in multithreaded code, but we do not use more
than one thread in our algorithm. We need <code>RefCell</code> just to
circumvent this superfluous limitation <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p><p>The last thing to note is the implementation of
<code>convert_list</code> in Rust. Since <code>fn</code>s are inherently
no more than code pointers, we need to pass <code>gen</code> and
<code>finish</code> explicitly on each call to <code>go</code> <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>. In turn, this leads us to
duplicating the types of these variables in the signature of
<code>go</code> (in Rust, there is no type inference of function
parameters). In contrast, OCaml captures <code>gen</code> and
<code>finish</code> automatically.</p><p>While the algorithm presented here is not very complex, it does
already demonstrate the convenience of programming in a language from
the ML family. However, let us see some more examples concerning type
systems of both languages.</p><a class="header-link" href="#type-safety-gadts"><h2 id="type-safety-gadts">Type safety: GADTs</h2></a><p>Resource management aside, OCaml’s type system is generally more
expressive than that of Rust. For example, OCaml supports <a href="https://v2.ocaml.org/manual/gadts-tutorial.html">Generalized
Algebraic Data Types (GADTs)</a> to enforce certain invariants on the
structure of data. Let us imagine an object language of booleans,
integers, and operations upon them:</p><div class="sourceCode" id="cb5"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">enum</span> Term <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>    Bool(<span class="dt">bool</span>)<span class="op">,</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="bu">Not</span>(<span class="dt">Box</span><span class="op">&lt;</span>Term<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>    And(<span class="dt">Box</span><span class="op">&lt;</span>Term<span class="op">&gt;,</span> <span class="dt">Box</span><span class="op">&lt;</span>Term<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    Int(<span class="dt">i32</span>)<span class="op">,</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="bu">Neg</span>(<span class="dt">Box</span><span class="op">&lt;</span>Term<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="bu">Add</span>(<span class="dt">Box</span><span class="op">&lt;</span>Term<span class="op">&gt;,</span> <span class="dt">Box</span><span class="op">&lt;</span>Term<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="kw">enum</span> Value <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>    Bool(<span class="dt">bool</span>)<span class="op">,</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>    Int(<span class="dt">i32</span>)<span class="op">,</span></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="op">}</span></span></code></pre></div><p>How do we write an evaluator for it? Here is a possible solution:</p><div class="sourceCode" id="cb6"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">fn</span> eval(term<span class="op">:</span> <span class="op">&amp;</span>Term) <span class="op">-&gt;</span> Value <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="kw">use</span> <span class="pp">Term::</span><span class="op">*;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="cf">match</span> term <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>        Bool(b) <span class="op">=&gt;</span> <span class="pp">Value::</span>Bool(<span class="op">*</span>b)<span class="op">,</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>        <span class="bu">Not</span>(m) <span class="op">=&gt;</span> <span class="cf">match</span> eval(m) <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>            <span class="pp">Value::</span>Bool(b) <span class="op">=&gt;</span> <span class="pp">Value::</span>Bool(<span class="op">!</span>b)<span class="op">,</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>            _ <span class="op">=&gt;</span> <span class="pp">panic!</span>(<span class="st">"`Not` on a non-boolean value"</span>)<span class="op">,</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>        <span class="op">},</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>        And(m<span class="op">,</span> n) <span class="op">=&gt;</span> <span class="cf">match</span> (eval(m)<span class="op">,</span> eval(n)) <span class="op">{</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>            (<span class="pp">Value::</span>Bool(b1)<span class="op">,</span> <span class="pp">Value::</span>Bool(b2)) <span class="op">=&gt;</span> <span class="pp">Value::</span>Bool(b1 <span class="op">&amp;&amp;</span> b2)<span class="op">,</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>            _ <span class="op">=&gt;</span> <span class="pp">panic!</span>(<span class="st">"`And` on non-boolean values"</span>)<span class="op">,</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>        <span class="op">},</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>        Int(i) <span class="op">=&gt;</span> <span class="pp">Value::</span>Int(<span class="op">*</span>i)<span class="op">,</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>        <span class="bu">Neg</span>(m) <span class="op">=&gt;</span> <span class="cf">match</span> eval(m) <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>            <span class="pp">Value::</span>Int(i) <span class="op">=&gt;</span> <span class="pp">Value::</span>Int(<span class="op">-</span>i)<span class="op">,</span></span>
<span id="cb6-17"><a href="#cb6-17"></a>            _ <span class="op">=&gt;</span> <span class="pp">panic!</span>(<span class="st">"`Neg` on a non-integer value"</span>)<span class="op">,</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>        <span class="op">},</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>        <span class="bu">Add</span>(m<span class="op">,</span> n) <span class="op">=&gt;</span> <span class="cf">match</span> (eval(m)<span class="op">,</span> eval(n)) <span class="op">{</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>            (<span class="pp">Value::</span>Int(i1)<span class="op">,</span> <span class="pp">Value::</span>Int(i2)) <span class="op">=&gt;</span> <span class="pp">Value::</span>Int(i1 <span class="op">+</span> i2)<span class="op">,</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>            _ <span class="op">=&gt;</span> <span class="pp">panic!</span>(<span class="st">"`Add` on non-integer values"</span>)<span class="op">,</span></span>
<span id="cb6-22"><a href="#cb6-22"></a>        <span class="op">},</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>    <span class="op">}</span></span>
<span id="cb6-24"><a href="#cb6-24"></a><span class="op">}</span></span></code></pre></div><p>The solution is simple enough; however, it is not very robust. What
happens if an input to <code>eval</code> is ill-typed? Take the
following example:</p><div class="sourceCode" id="cb7"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="kw">use</span> <span class="pp">Term::</span><span class="op">*;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="kw">let</span> term <span class="op">=</span> <span class="bu">Not</span>(<span class="dt">Box</span><span class="pp">::</span>new(And(<span class="dt">Box</span><span class="pp">::</span>new(Bool(<span class="cn">true</span>))<span class="op">,</span> <span class="dt">Box</span><span class="pp">::</span>new(Int(<span class="dv">42</span>)))))<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="pp">dbg!</span>(eval(<span class="op">&amp;</span>term))<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="op">}</span></span></code></pre></div><p>The program panics with “<code>And</code> on non-boolean values”,
because the second operand of <code>And</code> must necessarily be a
boolean, not an integer.</p><p>To prevent this kind of errors, we can use GADTs in OCaml:</p><div class="sourceCode" id="cb8"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">type</span> _ term =</span>
<span id="cb8-2"><a href="#cb8-2"></a>  | Bool : <span class="dt">bool</span> -&gt; <span class="dt">bool</span> term</span>
<span id="cb8-3"><a href="#cb8-3"></a>  | Not : <span class="dt">bool</span> term -&gt; <span class="dt">bool</span> term</span>
<span id="cb8-4"><a href="#cb8-4"></a>  | And : <span class="dt">bool</span> term * <span class="dt">bool</span> term -&gt; <span class="dt">bool</span> term</span>
<span id="cb8-5"><a href="#cb8-5"></a>  | Int : <span class="dt">int</span> -&gt; <span class="dt">int</span> term</span>
<span id="cb8-6"><a href="#cb8-6"></a>  | Neg : <span class="dt">int</span> term -&gt; <span class="dt">int</span> term</span>
<span id="cb8-7"><a href="#cb8-7"></a>  | Add : <span class="dt">int</span> term * <span class="dt">int</span> term -&gt; <span class="dt">int</span> term</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="kw">let</span> <span class="kw">rec</span> eval : <span class="kw">type</span> a. a term -&gt; a = <span class="kw">function</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>  | Bool b -&gt; b</span>
<span id="cb8-11"><a href="#cb8-11"></a>  | Not m -&gt; <span class="dt">not</span> (eval m)</span>
<span id="cb8-12"><a href="#cb8-12"></a>  | And (m, n) -&gt;</span>
<span id="cb8-13"><a href="#cb8-13"></a>      <span class="kw">let</span> b1, b2 = (eval m, eval n) <span class="kw">in</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>      b1 &amp;&amp; b2</span>
<span id="cb8-15"><a href="#cb8-15"></a>  | Int i -&gt; i</span>
<span id="cb8-16"><a href="#cb8-16"></a>  | Neg m -&gt; -eval m</span>
<span id="cb8-17"><a href="#cb8-17"></a>  | Add (m, n) -&gt;</span>
<span id="cb8-18"><a href="#cb8-18"></a>      <span class="kw">let</span> i1, i2 = (eval m, eval n) <span class="kw">in</span></span>
<span id="cb8-19"><a href="#cb8-19"></a>      i1 + i2</span></code></pre></div><p>Now what happens if we construct an ill-typed term?:</p><div class="sourceCode" id="cb9"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">let</span> () =</span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span class="kw">let</span> _term = Not (And (Bool <span class="kw">true</span>, Int <span class="dv">42</span>)) <span class="kw">in</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>  ()</span></code></pre></div><p>It just will not type-check!:</p><div class="sourceCode" id="cb10"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb10-1"><a href="#cb10-1"></a>File "bin/main.ml", line 22, characters 35-41:</span>
<span id="cb10-2"><a href="#cb10-2"></a>22 |   let _term = Not (And (Bool true, Int 42)) in</span>
<span id="cb10-3"><a href="#cb10-3"></a>                                        ^^^^^^</span>
<span id="cb10-4"><a href="#cb10-4"></a>Error: This expression has type int term</span>
<span id="cb10-5"><a href="#cb10-5"></a>       but an expression was expected of type bool term</span>
<span id="cb10-6"><a href="#cb10-6"></a>       Type int is not compatible with type bool</span></code></pre></div><p>This is possible because we essentially encoded the object language
type system in the definition of <code>term</code>. OCaml knows that
<code>And</code> accepts boolean-typed terms, not integer-typed ones. In
a real-world scenario, we can have an unrestricted <code>term</code>
akin to Rust’s <code>Term</code>, which is produced by parsing and
elaborated further into a proper GADT-style <code>term</code>. The
latter can be handled by <code>eval</code> (or <code>compile</code>,
whatever).</p><a class="header-link" href="#type-flexibility-first-class-modules"><h2 id="type-flexibility-first-class-modules">Type flexibility:
First-class modules</h2></a><p>Another neat feature of OCaml not present in Rust is <a href="https://dev.realworldocaml.org/first-class-modules.html">first-class
modules</a>. Can you imagine a module that is stored in a variable,
passed as a parameter, or returned from a regular function? This is what
first-class modules are about. Suppose that your object language
includes various fixed-size integers, such as
<code>i8</code>/<code>u8</code>, <code>i16</code>/<code>u16</code>, and
so on. With OCaml, you can represent them via (regular) modules:</p><div class="code-annotation-container"><p class="code-annotation">
<code>fixed_ints.mli</code>
</p></div><div class="sourceCode" id="cb11"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">(* [u8], [u16], etc. are defined by us. *)</span></span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="kw">module</span> <span class="kw">type</span> S = <span class="kw">sig</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>  <span class="kw">type</span> t</span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a>  <span class="kw">val</span> add : t -&gt; t -&gt; t</span>
<span id="cb11-7"><a href="#cb11-7"></a>  <span class="kw">val</span> sub : t -&gt; t -&gt; t</span>
<span id="cb11-8"><a href="#cb11-8"></a>  <span class="kw">val</span> mul : t -&gt; t -&gt; t</span>
<span id="cb11-9"><a href="#cb11-9"></a>  <span class="kw">val</span> div : t -&gt; t -&gt; t</span>
<span id="cb11-10"><a href="#cb11-10"></a>  <span class="kw">val</span> rem : t -&gt; t -&gt; t</span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a>  <span class="co">(* Some more operations here. *)</span></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="kw">end</span></span>
<span id="cb11-14"><a href="#cb11-14"></a></span>
<span id="cb11-15"><a href="#cb11-15"></a><span class="kw">module</span> U8 : S <span class="kw">with</span> <span class="kw">type</span> t = u8</span>
<span id="cb11-16"><a href="#cb11-16"></a><span class="kw">module</span> U16 : S <span class="kw">with</span> <span class="kw">type</span> t = u16</span>
<span id="cb11-17"><a href="#cb11-17"></a><span class="kw">module</span> U32 : S <span class="kw">with</span> <span class="kw">type</span> t = u32</span>
<span id="cb11-18"><a href="#cb11-18"></a><span class="kw">module</span> U64 : S <span class="kw">with</span> <span class="kw">type</span> t = u64</span>
<span id="cb11-19"><a href="#cb11-19"></a><span class="kw">module</span> U128 : S <span class="kw">with</span> <span class="kw">type</span> t = u128</span>
<span id="cb11-20"><a href="#cb11-20"></a><span class="kw">module</span> I8 : S <span class="kw">with</span> <span class="kw">type</span> t = i8</span>
<span id="cb11-21"><a href="#cb11-21"></a><span class="kw">module</span> I16 : S <span class="kw">with</span> <span class="kw">type</span> t = i16</span>
<span id="cb11-22"><a href="#cb11-22"></a><span class="kw">module</span> I32 : S <span class="kw">with</span> <span class="kw">type</span> t = i32</span>
<span id="cb11-23"><a href="#cb11-23"></a><span class="kw">module</span> I64 : S <span class="kw">with</span> <span class="kw">type</span> t = i64</span>
<span id="cb11-24"><a href="#cb11-24"></a><span class="kw">module</span> I128 : S <span class="kw">with</span> <span class="kw">type</span> t = i128</span></code></pre></div><p>In the AST, we can represent integer values as follows:</p><div class="sourceCode" id="cb12"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">type</span> generic =</span>
<span id="cb12-2"><a href="#cb12-2"></a>  | U8 <span class="kw">of</span> u8</span>
<span id="cb12-3"><a href="#cb12-3"></a>  | U16 <span class="kw">of</span> u16</span>
<span id="cb12-4"><a href="#cb12-4"></a>  | U32 <span class="kw">of</span> u32</span>
<span id="cb12-5"><a href="#cb12-5"></a>  | U64 <span class="kw">of</span> u64</span>
<span id="cb12-6"><a href="#cb12-6"></a>  | U128 <span class="kw">of</span> u128</span>
<span id="cb12-7"><a href="#cb12-7"></a>  | I8 <span class="kw">of</span> i8</span>
<span id="cb12-8"><a href="#cb12-8"></a>  | I16 <span class="kw">of</span> i16</span>
<span id="cb12-9"><a href="#cb12-9"></a>  | I32 <span class="kw">of</span> i32</span>
<span id="cb12-10"><a href="#cb12-10"></a>  | I64 <span class="kw">of</span> i64</span>
<span id="cb12-11"><a href="#cb12-11"></a>  | I128 <span class="kw">of</span> i128</span></code></pre></div><p>Having so many possible combinations of arithmetical operators
<code>add</code>/<code>sub</code>/<code>mul</code>/<code>div</code>/<code>rem</code>
and variously typed operands, how to implement evaluation sanely?</p><p>Here is an idea:</p><ol type="1">
<li>Define a function <code>pair_exn</code> that maps two
<code>generic</code>s into a first-class module <code>Pair</code>.</li>
<li>Define a module <code>Pair</code> that implements <code>S</code> for
a given pair of integers.</li>
<li>Define a function <code>do_int_bin_op</code> that accepts
<code>Pair</code> as a parameter and performs an operation
<code>op</code> on the pair of integers.</li>
<li>Call <code>do_int_bin_op</code> from <code>eval</code>.</li>
</ol><p>In OCaml:</p><div class="code-annotation-container"><p class="code-annotation">
<code>fixed_ints.mli</code>
</p></div><div class="sourceCode" id="cb13"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">module</span> <span class="kw">type</span> Pair = <span class="kw">sig</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="kw">type</span> t</span>
<span id="cb13-3"><a href="#cb13-3"></a></span>
<span id="cb13-4"><a href="#cb13-4"></a>  <span class="kw">include</span> S <span class="kw">with</span> <span class="kw">type</span> t := t</span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a>  <span class="kw">val</span> pair : t * t</span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="kw">end</span></span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="kw">val</span> pair_exn : generic * generic -&gt; (<span class="kw">module</span> Pair)</span></code></pre></div><p>The implementation of <code>pair</code> would be:</p><div class="code-annotation-container"><p class="code-annotation">
<code>fixed_ints.ml</code>
</p></div><div class="sourceCode" id="cb14"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">let</span> pair_exn =</span>
<span id="cb14-2"><a href="#cb14-2"></a>  <span class="kw">let</span> make (<span class="kw">type</span> a) (<span class="kw">module</span> S : S <span class="kw">with</span> <span class="kw">type</span> t = a) (x, y) =</span>
<span id="cb14-3"><a href="#cb14-3"></a>    (<span class="kw">module</span> <span class="kw">struct</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>      <span class="kw">include</span> S</span>
<span id="cb14-5"><a href="#cb14-5"></a></span>
<span id="cb14-6"><a href="#cb14-6"></a>      <span class="kw">let</span> pair = x, y</span>
<span id="cb14-7"><a href="#cb14-7"></a>    <span class="kw">end</span> : Pair)</span>
<span id="cb14-8"><a href="#cb14-8"></a>  <span class="kw">in</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>  <span class="kw">function</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>  | U8 x, U8 y -&gt; make (<span class="kw">module</span> U8) (x, y)</span>
<span id="cb14-11"><a href="#cb14-11"></a>  | U16 x, U16 y -&gt; make (<span class="kw">module</span> U16) (x, y)</span>
<span id="cb14-12"><a href="#cb14-12"></a>  | U32 x, U32 y -&gt; make (<span class="kw">module</span> U32) (x, y)</span>
<span id="cb14-13"><a href="#cb14-13"></a>  | U64 x, U64 y -&gt; make (<span class="kw">module</span> U64) (x, y)</span>
<span id="cb14-14"><a href="#cb14-14"></a>  | U128 x, U128 y -&gt; make (<span class="kw">module</span> U128) (x, y)</span>
<span id="cb14-15"><a href="#cb14-15"></a>  | I8 x, I8 y -&gt; make (<span class="kw">module</span> I8) (x, y)</span>
<span id="cb14-16"><a href="#cb14-16"></a>  | I16 x, I16 y -&gt; make (<span class="kw">module</span> I16) (x, y)</span>
<span id="cb14-17"><a href="#cb14-17"></a>  | I32 x, I32 y -&gt; make (<span class="kw">module</span> I32) (x, y)</span>
<span id="cb14-18"><a href="#cb14-18"></a>  | I64 x, I64 y -&gt; make (<span class="kw">module</span> I64) (x, y)</span>
<span id="cb14-19"><a href="#cb14-19"></a>  | I128 x, I128 y -&gt; make (<span class="kw">module</span> I128) (x, y)</span>
<span id="cb14-20"><a href="#cb14-20"></a>  | _, _ -&gt; <span class="dt">raise</span> (<span class="dt">invalid_arg</span> <span class="st">"Fixed_ints.pair_exn"</span>)</span>
<span id="cb14-21"><a href="#cb14-21"></a>;;</span></code></pre></div><p>Now we can write <code>eval</code> as follows:</p><div class="sourceCode" id="cb15"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1"></a><span class="co">(* Somewhere within the definition of [eval]. *)</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>| IntBinOp (op, ty, m, n) -&gt;</span>
<span id="cb15-3"><a href="#cb15-3"></a>  <span class="kw">let</span> x = extract_int_exn (eval m) <span class="kw">in</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>  <span class="kw">let</span> y = extract_int_exn (eval n) <span class="kw">in</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>  <span class="kw">let</span> (<span class="kw">module</span> Pair) = Fixed_ints.pair_exn (x, y) <span class="kw">in</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>  do_int_bin_op op (<span class="kw">module</span> Pair)</span></code></pre></div><p><code>extract_int_exn</code> takes a value and extracts an integer
<code>generic</code>, raising an exception if the value is not an
integer.</p><p>Finally, <code>do_int_bin_op</code> is defined as follows:</p><div class="sourceCode" id="cb16"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">let</span> do_int_bin_op op (<span class="kw">module</span> S : Fixed_ints.Pair) =</span>
<span id="cb16-2"><a href="#cb16-2"></a>  <span class="kw">let</span> x, y = S.pair <span class="kw">in</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>  <span class="kw">match</span> op <span class="kw">with</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>  | Add -&gt; S.add x y |&gt; S.to_value</span>
<span id="cb16-5"><a href="#cb16-5"></a>  | Sub -&gt; S.sub x y |&gt; S.to_value</span>
<span id="cb16-6"><a href="#cb16-6"></a>  | Mul -&gt; S.mul x y |&gt; S.to_value</span>
<span id="cb16-7"><a href="#cb16-7"></a>  | Div -&gt; S.div x y |&gt; S.to_value</span>
<span id="cb16-8"><a href="#cb16-8"></a>  | Rem -&gt; S.rem x y |&gt; S.to_value</span>
<span id="cb16-9"><a href="#cb16-9"></a>;;</span></code></pre></div><p><code>S.to_value</code> converts a typed integer back to a value
holding <code>generic</code>.</p><p>With the aid of first-class modules, we were able to implement
evaluation of fixed-size integers without much boilerplate. The best you
could do in Rust is to resort to <code>macro_rules!</code>, which are
notorious for their hard-to-decipher syntax, shallow integration with
the rest of the language, and poor IDE support.</p><a class="header-link" href="#final-words"><h2 id="final-words">Final words</h2></a><p>While Rust excels at resource management, OCaml turns out to be a
more suitable choice for compiler development. We have not covered many
other interesting features of it, such as <a href="https://v2.ocaml.org/releases/4.14/htmlman/polyvariant.html">polymorphic
variants</a>, <a href="https://v2.ocaml.org/manual/bindingops.html">custom binding
operators</a>, and <a href="https://v2.ocaml.org/manual/effects.html">effect handlers</a>. Due
to its completely static and flexible type system, OCaml has been
historically used as a host language for many projects, including the <a href="https://frama-c.com/">Frama-C toolchain</a>, the <a href="https://coq.inria.fr/">Coq theorem prover</a>, and early versions
of the Rust compiler itself.</p><p>OCaml is not without its flaws, though. The standard library and the
overall ecosystem is clearly inferior to that of Rust. The full set of
fixed-size integers found in Rust is not directly available in OCaml,
although it can be implemented with a combination of native OCaml
integers, the <code>Int32</code> and <code>Int64</code> modules from the
standard library, and C FFI. (Pro tip: do not use <a href="https://github.com/andrenth/ocaml-stdint"><code>ocaml-stdint</code></a>,
it is unmaintained and is very buggy as of Aug 6, 2023. <a href="https://github.com/yallop/ocaml-integers"><code>ocaml-integers</code></a>
is a more robust alternative but it lacks support for <code>Int8</code>,
<code>Int16</code>, and 128-bit integers and has problems with
documentation.)</p><p>As Rust is gaining more and more popularity, more and more desperate
developers from GitHub will start their compiler projects in it. I
believe this can be a good decision either if 1) you are trying to learn
Rust by writing “too many compilers” in it, or 2) you do really know
what you are doing. If your intention is in compiler development itself,
OCaml will save you a lot of time and undamaged nerves.</p><p>Other alternatives to consider is Haskell and various Lisp dialects.
If you have already “tamed” Haskell (my congratulations and
condolences), probably learning OCaml just for writing a compiler is not
going to be worth it; if you have not, OCaml is a much more approachable
language. Lisps can be very flexible, but they usually lack static type
safety, opening a wide and horrible door to run-time errors.</p><a class="header-link" href="#appendix-getting-started-with-ocaml"><h2 id="appendix-getting-started-with-ocaml">Appendix: Getting started
with OCaml</h2></a><p>Here is an easy way to get started with OCaml:</p><ol type="1">
<li><a href="https://ocaml.org/install">Install OCaml on Linux, macOS,
*BSD, or Windows &gt;&gt;</a></li>
<li>Install the <a href="https://dune.readthedocs.io/en/stable/overview.html">Dune build
system</a>: <code>opam install dune</code>.</li>
<li>Create a new project:
<code>dune init project my_compiler</code>.</li>
</ol><p>The directory <code>my_compiler</code> will look like this:</p><div class="sourceCode" id="cb17"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb17-1"><a href="#cb17-1"></a>my_compiler/</span>
<span id="cb17-2"><a href="#cb17-2"></a>├── bin</span>
<span id="cb17-3"><a href="#cb17-3"></a>│&nbsp;&nbsp; ├── dune</span>
<span id="cb17-4"><a href="#cb17-4"></a>│&nbsp;&nbsp; └── main.ml</span>
<span id="cb17-5"><a href="#cb17-5"></a>├── _build</span>
<span id="cb17-6"><a href="#cb17-6"></a>│&nbsp;&nbsp; └── log</span>
<span id="cb17-7"><a href="#cb17-7"></a>├── dune-project</span>
<span id="cb17-8"><a href="#cb17-8"></a>├── lib</span>
<span id="cb17-9"><a href="#cb17-9"></a>│&nbsp;&nbsp; └── dune</span>
<span id="cb17-10"><a href="#cb17-10"></a>├── my_compiler.opam</span>
<span id="cb17-11"><a href="#cb17-11"></a>└── test</span>
<span id="cb17-12"><a href="#cb17-12"></a>    ├── dune</span>
<span id="cb17-13"><a href="#cb17-13"></a>    └── my_compiler.ml</span></code></pre></div><ol type="1">
<li><code>bin/</code> is for setup code and CLI.</li>
<li><code>lib/</code> is where most of the code lives.</li>
<li><code>test/</code> is for tests.</li>
</ol><p>I recommend <a href="https://github.com/mirage/alcotest"><code>alcotest</code></a> for
unit tests and <a href="https://github.com/ocaml-ppx/ppx_deriving"><code>ppx_deriving</code></a>
for the deriving functionality (akin to <code>#[derive(...)]</code> from
Rust). Install them as follows:</p><div class="sourceCode" id="cb18"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb18-1"><a href="#cb18-1"></a>$ opam install alcotest</span>
<span id="cb18-2"><a href="#cb18-2"></a>$ opam install ppx_deriving</span></code></pre></div><p>Edit <code>my_compiler/lib/dune</code> as follows:</p><div class="sourceCode" id="cb19"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb19-1"><a href="#cb19-1"></a>(library</span>
<span id="cb19-2"><a href="#cb19-2"></a> (name my_compiler)</span>
<span id="cb19-3"><a href="#cb19-3"></a> (preprocess</span>
<span id="cb19-4"><a href="#cb19-4"></a>  (pps ppx_deriving.show ppx_deriving.eq)))</span></code></pre></div><p>And <code>my_compiler/test/dune</code> as follows:</p><div class="sourceCode" id="cb20"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb20-1"><a href="#cb20-1"></a>(test</span>
<span id="cb20-2"><a href="#cb20-2"></a> (name my_compiler)</span>
<span id="cb20-3"><a href="#cb20-3"></a> (libraries my_compiler alcotest))</span></code></pre></div><ol type="1">
<li>Type <code>dune build</code> to build the project.</li>
<li>Type <code>dune test</code> to run the tests.</li>
<li>Type <code>dune exec my_compiler</code> to execute the binary.</li>
</ol><p>You can now create a file <code>foo.ml</code> with a corresponding
<code>foo.mli</code> in <code>my_compiler/lib</code> and access it as
<code>My_compiler.Foo</code> from <code>bin/</code> and
<code>lib/</code>.</p><p>For test coverage, consider using <a href="https://github.com/aantron/bisect_ppx"><code>bisect_ppx</code></a>.</p><p>If you know Rust, you will find OCaml very familiar. I recommend the
following resources for learning the language:</p><ul>
<li><a href="https://cs3110.github.io/textbook/cover.html">OCaml
Programming: Correct + Efficient + Beautiful</a></li>
<li><a href="https://dev.realworldocaml.org/">Real World OCaml</a></li>
<li><a href="https://v2.ocaml.org/manual/coreexamples.html">The official
tutorial</a> (can be read in an evening!)</li>
</ul><a class="header-link" href="#references"><h2 id="references">References</h2></a><section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1" role="doc-endnote"><p>CPS is the central representation of
the compiler Standard ML of New Jersey.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><em>Update: several people have
suggested to use arenas (regions) instead of the approach I have
demonstrated. I am well aware of the technique; however, I do not think
that arenas would make a significant difference in code clarity and
ergonomics. Flattening an AST has many performance benefits, such as
spatial locality and cheap allocation and deallocation, but they add a
little value to the overall discussion.</em><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>You can access the code itself and
accompanying tests <a href="https://gist.github.com/hirrolot/d16dc5e78639db6e546b5054afefd142">here</a>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><code>Rc</code> was chosen to avoid
expensive cloning of <code>TermTree</code>s in some places.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>To be precise, all functions are
curried in OCaml, so <code>function</code> just “defines” a function
with a single parameter and pattern-matches on it.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p><em>Update: this is actually not true
that this requirement is only needed in multithreaded code. However, I
do still think it is superfluous in the code I have suggested.</em><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>Unfortunately, closures provide us
with no solution here: they cannot be called recursively, at least
without prior hoodoo.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><script src="https://giscus.app/client.js" data-repo="hirrolot/hirrolot.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzMTQ4MzI2NDA=" data-category="Announcements" data-category-id="DIC_kwDOEsP3AM4CSEqw" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="https://hirrolot.github.io/giscus-theme.css" data-lang="en" data-loading="lazy" crossorigin="anonymous" async="">
</script></div></body></html>