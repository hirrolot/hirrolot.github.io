<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="hirrolot">
  <title>Solving SAT via Positive Supercompilation</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
  <link href="https://necolas.github.io/normalize.css/8.0.1/normalize.css" rel="stylesheet">

  <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Caveat&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Luxurious+Roman&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Alex+Brush&amp;display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="../myself.png" type="image/x-icon">
  <script src="../script.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<a class="header-link" href="#"><h1 class="title">Solving SAT via Positive Supercompilation</h1></a>
<p class="author">hirrolot</p>
<p class="date">Feb 1, 2024</p>
</header>
<div class="introduction">
<p class="discussions">
<a href="https://news.ycombinator.com/item?id=39218173">HN</a> · <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/1agb940/solving_sat_via_positive_supercompilation/">r/ProgrammingLanguages</a>
</p>
<p>The <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">boolean
satisfiability problem</a> (“SAT” for short) is arguably the most famous
NP-complete problem in theoretical computer science. According to
Wikipedia, it is “the problem of determining if there exists an <a href="https://en.wikipedia.org/wiki/Interpretation_(logic)">interpretation</a>
that satisfies a given <a href="https://en.wikipedia.org/wiki/Boolean_logic">Boolean</a> <a href="https://en.wikipedia.org/wiki/Well-formed_formula">formula</a>”;
or, in simpler terms, if there is at least one assignment of boolean
variables to TRUE or FALSE such that the whole formula becomes TRUE.</p>
<p>As <a href="https://gist.github.com/VictorTaelin/9061306220929f04e7e6980f23ade615">evidenced
by Victor Taelin</a> recently, 3-SAT (an NP-complete subset of SAT) can
be encoded (and solved!) elegantly in terms of <a href="https://twitter.com/VictorTaelin/status/1732421137127383385">interaction
net superpositions</a>. Hence, it seems that certain very general
computation models, such as <a href="https://en.wikipedia.org/wiki/Interaction_nets">interaction
nets</a>, can subsume SAT if the latter is properly encoded. Inspired by
the idea, I became eager to try SAT solving with perhaps the most
general program transformation and optimization technique known to date:
<em>supercompilation</em>.</p>
<p>The result is mind-blowing: even a dumb supercompiler can solve
arbitrary SAT formulas without the “actual” algorithm! This essay is a
brief report of my findings. First, I will introduce the reader to the
basics of supercompilation, then show the overall idea of solving SAT
with dead code elimination, and finally demonstrate a working prototype
of a supercompiler that acts as a <a href="https://en.wikipedia.org/wiki/Completeness_(logic)">complete</a>
SAT solver.</p>
<p>Without further ado, let me begin.</p>
</div><nav id="TOC" role="doc-toc" style="display: block;"><h4 class="toc-title">Table of Contents</h4>
<ul>
<li><a href="#supercompilation-by-example">Supercompilation by
example</a></li>
<li><a href="#sat-and-dead-code-elimination">SAT and dead code
elimination</a></li>
<li><a href="#supercompilation-of-sat">Supercompilation of SAT</a></li>
<li><a href="#final-words">Final words</a></li>
<li><a href="#references">References</a></li>
</ul>
</nav>




































































































































<div class="post-body"><a class="header-link" href="#supercompilation-by-example"><h2 id="supercompilation-by-example">Supercompilation by example</h2></a><p>Supercompilation is a deep program transformation technique due to <a href="https://en.wikipedia.org/wiki/Valentin_Turchin">V. F. Turchin</a>,
a prominent computer scientist, cybernetician, physicist, and <a href="https://en.wikipedia.org/wiki/Soviet_dissidents">Soviet
dissident</a>.</p><p>He described the concept as follows <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p><blockquote>
<p>A supercompiler is a program transformer of a certain type. The usual
way of thinking about program transformation is in terms of some set of
rules which preserve the functional meaning of the program, and a
step-by-step application of these rules to the initial program. … The
concept of a supercompiler is a product of cybernetic thinking. A
program is seen as a machine. To make sense of it, one must observe its
operation. So a supercompiler does not transform the program by steps;
it controls and observes (SUPERvises) the running of the machine that is
represented by the program; let us call this machine M<sub>1</sub>. In
observing the operation of M<sub>1</sub>, the supercompiler COMPILES a
program which describes the activities of M<sub>1</sub>, but it makes
shortcuts and whatever clever tricks it knows in order to produce the
same effect as M<sub>1</sub>, but faster. The goal of the supercompiler
is to make the definition of this program (machine) M<sub>2</sub>
self-sufficient. When this is acheived, it outputs M<sub>2</sub> in some
intermediate language L<sup>sup</sup> and simply throws away the
(unchanged) machine M<sub>1</sub>.</p>
</blockquote><p><br></p><p>A supercompiler is interesting not only as a program transformer but
also as a very general philosophical concept:</p><blockquote>
<p>The supercompiler concept comes close to the way humans think and
make science. We do not think in terms of rules of formal logic. We
create mental and linguistic models of the reality we observe. How do we
do that? We observe phenomena, generalize observations, and try to
construct a self-sufficient model in terms of these generalizations.
This is also what the supercompiler does. … A supercompiler would run
M<sub>1</sub>, in a general form, with unknown values of variables, and
create a graph of states and transitions between possible configurations
of the computing system. … To make it finite, the supercompiler performs
the operation of generalization on the system configurations in such a
manner that it finally comes to a set of generalized configurations,
called <em>basic</em>, in terms of which the behavior of the system can
be expressed. Thus the new program becomes a self-sufficient model of
the old one.</p>
</blockquote><p><br></p><p>Since the above explanations are hard to comprehend at first sight, I
will try to illustrate supercompilation <em>by example</em>.</p><p>Let the object language of supercompilation be a simple first-order
functional language called <em>SLL</em>, which stands for <em>Simple
Lazy Language</em>. It consists of:</p><ul>
<li><strong>Variables:</strong> just regular symbolic identifiers.
<ul>
<li>Examples: <code>a</code>, <code>b</code>, <code>c</code>.</li>
</ul></li>
<li><strong>Constructors:</strong> symbolic identifiers that wrap their
arguments of arbitrary structure.
<ul>
<li>Examples: <code>Foo(a, b, c)</code>,
<code>Bar(a, Foo(a), c)</code>.</li>
</ul></li>
<li><strong>F-functions:</strong> <em>indifferent</em> functions that
just transform their arguments.
<ul>
<li>Examples:
<ul>
<li><code>foo(a, b, c) = Foo(a, b, Bar(c));</code></li>
<li><code>bar(a, b, c) = foo(Bar(a), b, c);</code></li>
</ul></li>
</ul></li>
<li><strong>G-functions:</strong> <em>curious</em> functions that
pattern-match on their first argument.
<ul>
<li>Examples: see below.</li>
</ul></li>
</ul><p>Suppose that natural numbers are represented as <code>Z</code>,
<code>S(Z)</code>, <code>S(S(Z))</code>, and so on <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.
Then, we can define addition as the following g-function (from <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>):</p><p><span class="math display">\[
\begin{aligned}
add(Z, y) &amp;= y; \\
add(S(x), y) &amp;= S(add(x, y));
\end{aligned}
\]</span></p><p>A supercompiler’s input is a pair of an expression and program, the
latter being a set of definitions of f- and g-functions. This pair is
usually called a <em>task</em>.</p><p>Let the task for a hypothetic supercompiler be the expression
<code>add(S(Z), S(S(Z)))</code> together with the definition of
<code>add</code> above. In this case, the work of a supercompiler is as
simple as sequential reduction of the initial expression to the target
expression <code>S(S(S(Z)))</code>, according to the rules of
<code>add</code>:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/add-1-2.png" width="400px"></p>
</div><p>However, to think of a supercompiler as of a mere expression
evaluator is a grave mistake. Let us consider what happens when it
encounters a <em>variable</em> that does not stand for some concrete
expression. For example, let the task be <code>add(S(S(Z)), b)</code>
with the same definition of <code>add</code>, where <code>b</code> is
understood as “any” expression:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/add-2-b.png" width="400px"></p>
</div><p>It <em>just</em> works!</p><p>A supercompiler saw the variable <code>b</code> when trying to reduce
<code>S(S(add(Z, b)))</code>, and then it just substituted
<code>y</code> (from the rule <code>add(Z, y)</code>) for this
<code>b</code>. After that, supercompilation has stopped because the
actual expression for <code>b</code> is unknown at this point. As a
result, we got <code>S(S(b))</code>, which is equivalent to the initial
expression.</p><p>Now consider what happens if there is a need to
<em>pattern-match</em> on an unknown variable. In this case, we cannot
just proceed with “direct” computation since there are several
possibilities of the form the variable may take. Suppose that the task
is <code>add(a, 2)</code> <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> with the same function
<code>add</code>. What a supercompiler does is that it <em>analyze</em>
the expression <code>add(a, 2)</code> according to all the possibilities
of <code>a</code>, which are either <code>Z</code> or
<code>S(v1)</code>, where <code>v1</code> is some fresh variable
identifier. The situation looks like this:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/add-a-2.png" width="600px"></p>
</div><p>A supercompiler has built an (incomplete) <em>process tree</em> that
describes the execution of <code>add(a, 2)</code> in a general sense. In
the first branch, <code>a</code> is substituted for <code>Z</code>
according to the first rule of <code>add</code>; in the second branch,
<code>a</code> is substituted for <code>S(v1)</code> according to the
second rule of <code>add</code>. The resulting two nodes are labelled
with expressions that resulted in reducing a particular substitution of
the parent expression.</p><p>However, the supercompilation is not complete yet: there is still a
node labelled as <code>S(add(v1, 2))</code>. A supercompiler decides to
<em>decompose</em> it, meaning to move <code>add(v1, 2)</code> out of
<code>S(...)</code> in the following way:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/add-a-2-decompose.png" width="600px"></p>
</div><p>After that, if we proceed with supercompiling
<code>add(v1, 2)</code>, we will eventually arrive at the initial
expression <code>add(a, 2)</code>. This is because the expressions
<code>add(v1, 2)</code> and <code>add(a, 2)</code> are <em>alpha
equivalent</em>, meaning that they only differ in the names of
variables. A supercompiler should be smart enough to detect this
situation of alpha equivalence and, instead of continuing infinite
supercompilation, just draw a back arrow from <code>add(v1, 2)</code> to
the initial node as depicted below:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/add-a-2-loop.png" width="600px"></p>
</div><p>Hooray, the supercompilation of <code>add(a, 2)</code> is now
complete!</p><p>What is left is to perform <em>residualization</em> – the process of
converting a process tree to an SLL task, a <em>self-sufficient
model</em> of the initial program. Every node in the graph (except for
leaf nodes) is transformed into a function whose parameters are the set
of free variables from the node expression; each function is given a
unique name. For example, if we see the node <code>add(a, 2)</code>
pointing to <code>2</code> and <code>S(add(v1, 2))</code>, we must
generate a new g-function of the following form:</p><p><span class="math display">\[
\begin{aligned}
g1(Z) &amp;= \dots; \\
g1(S(v1)) &amp;= \dots;
\end{aligned}
\]</span></p><p>We can complete the first branch by inserting <code>2</code> in place
of <code>...</code>:</p><p><span class="math display">\[
\begin{aligned}
g1(Z) &amp;= 2; \\
g1(S(v1)) &amp;= \dots;
\end{aligned}
\]</span></p><p>Since the second branch leads to a node that decomposes a
constructor, we generate a new f-function and call it inside
<code>S</code>:</p><p><span class="math display">\[
\begin{aligned}
g1(Z) &amp;= 2; \\
g1(S(v1)) &amp;= S(f1(v1)); \\
f1(v1) &amp;= \dots;
\end{aligned}
\]</span></p><p>According to the graph, the body of <code>f1</code> should be
<code>add(v1, 2)</code>, but since now <code>add</code> stands for
<code>g1</code>, the body will be <code>g1(v1)</code>:</p><p><span class="math display">\[
\begin{aligned}
g1(Z) &amp;= 2; \\
g1(S(v1)) &amp;= S(f1(v1)); \\
f1(v1) &amp;= g1(v1);
\end{aligned}
\]</span></p><p>Since <code>f1</code> is redundant, we can inline it as follows:</p><p><span class="math display">\[
\begin{aligned}
g1(Z) &amp;= 2; \\
g1(S(v1)) &amp;= S(g1(v1));
\end{aligned}
\]</span></p><p>This is the final residual <em>program</em>; the residual
<em>expression</em> will be <code>g1(a)</code>, since <code>a</code> is
the only free variable from the initial expression. As you can see, the
definition of <code>g1</code> is simpler than the original function
<code>add</code> in the sense that it accepts only one argument; the
second argument has been specialized to <code>2</code> during
supercompilation.</p><p>Perhaps a more interesting example would be specializing an
interpreter to a concrete program, obtaining a compiled “executable”. In
the partial computation literature, this is called the <em>first
Futamura projection</em> <a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p><p>Consider the following interpreter <code>eq</code> (also from <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>):</p><p><span class="math display">\[
\begin{aligned}
eq(Z, y) &amp;= eqZ(y); \\
eq(S(x), y) &amp;= eqS(y, x); \\
eqZ(Z) &amp;= True; \\
eqZ(S(x)) &amp;= False; \\
eqS(Z, x) &amp;= False; \\
eqS(S(y), x) &amp;= eq(x, y);
\end{aligned}
\]</span></p><p>which compares two Peano numbers for equality, resulting in either
<code>True</code> or <code>False</code>.</p><p>Now consider the expression <code>eq(S(S(Z)), x)</code> with the
above definition of <code>eq</code>; supercompilation will produce the
following residual program:</p><p><span class="math display">\[
\begin{aligned}
eqZ3(Z) &amp;= True; \\
eqZ3(S(v)) &amp;= False; \\
eqS2(Z) &amp;= False; \\
eqS2(S(v)) &amp;= eqZ3(v); \\
eqS1(Z) &amp;= False; \\
eqS1(S(v)) &amp;= eqS2(v);
\end{aligned}
\]</span></p><p>together with the residual expression <code>eqS1(x)</code>. In a
sense, we have obtained a compiled version of <code>eq</code>
specialized to <code>S(S(Z))</code>, because <code>eqS1</code>
pattern-matches only on an unknown variable <code>x</code> instead of
the known “program” <code>S(S(Z))</code>.</p><p>However, supercompilation is inherently more powerful than classical
partial evaluation. In Turchin’s own words <a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>:</p><blockquote>
<p>Although supercompilation includes partial evaluation, it does not
reduce to it. Supercompilation can lead to a very deep structural
transformation of the original program; it can improve the program even
if all the actual parameters in the function calls are variable. The
supercompilation process aims at the reduction of redundancy in the
original program, but this redundancy does not necessarily come from
fixed values of variables; it can result from nested loops, repeated
variables, and so on.</p>
</blockquote><p><br></p><p>That being said, a <a href="https://twitter.com/hirrolot/status/1741049231656280289">sufficiently
smart supercompiler</a> can transform a two-pass list mapping into a
single-pass algorithm, essentially performing <em>list fusion</em>:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/list-fusion.jpeg"></p>
</div><p>A similar example can be found in <em>“Rethinking
Supercompilation”</em> by Neil Mitchell <a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> and
in <a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> (section 6, <em>“Examples of
supercompilation”</em>).</p><hr><p>Although I have deliberately skipped a few important aspects of
supercompilation, most notably termination checking (see homeomorphic
embedding <a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> <a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>
<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>), the material presented in this
section should be enough to understand the rest of the text. An
interested reader may go through the references and also look into <a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> <a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>
<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> for some insight into a more
general topic of <em>metacomputation</em>. A more thorough introduction
to supercompilation can be found in <a href="https://themonadreader.files.wordpress.com/2014/04/super-final.pdf"><em>“Supercompilation:
Ideas and Methods”</em></a> by Ilya Klyuchnikov and Dimitur Krustev.</p><a class="header-link" href="#sat-and-dead-code-elimination"><h2 id="sat-and-dead-code-elimination">SAT and dead code
elimination</h2></a><p>Not let us consider how SAT can be reduced to the problem of <a href="https://en.wikipedia.org/wiki/Dead-code_elimination">dead code
elimination</a>.</p><p>Consider a language whose expressions are:</p><ul>
<li><code>If (x, m, n)</code>, where <code>x</code> is a variable,
<code>m</code> and <code>n</code> are expressions.</li>
<li><code>T</code> and <code>F</code>, which are constants.</li>
</ul><p>This language is enough to encode any SAT problem. We can encode each
clause in the formula as follows (in pseudocode):</p><p><span class="math display">\[
\begin{aligned}
OR(x, \dots) &amp;= If (x, T, \dots); \\
OR(NOT \ x, \dots) &amp;= If (x, \dots, T);
\end{aligned}
\]</span></p><p>Then <code>OR(x, OR(y, OR(NOT z, F)))</code> would correspond to “x
OR y OR NOT z”:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/if-x-y-not-z.png" width="550px"></p>
</div><p>Now consider the encoding of a conjunction of clauses <a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>:</p><p><span class="math display">\[
\begin{aligned}
AND(If(x, m, n), \dots) &amp;= If(x, AND(m, \dots), AND(n, \dots)); \\
AND(T, \dots) &amp;= \dots; \\
AND(F, \dots) &amp;= F;
\end{aligned}
\]</span></p><p>Then <code>AND(OR(x, F), AND(OR(NOT y, F), T))</code> would
correspond to “x AND NOT y”:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/x-and-not-y.png" width="550px"></p>
</div><p>Is the formula satisfiable? Yes, because we can assign <code>x</code>
to <code>T</code> and <code>y</code> to <code>F</code>.</p><p>Now consider the formula
<code>AND(OR(x, F), AND(OR(NOT x, F), T))</code>, which is equivalent to
“x AND NOT x”:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/x-and-not-x.png" width="550px"></p>
</div><p>Is the formula satisfiable? To figure out, let us remove <em>dead
paths</em> from the formula:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/if-x-f-f.png" width="550px"></p>
</div><p>We have replaced the lower <code>if x</code> node with its first
child <code>F</code> because <code>x</code> was already assigned
<code>T</code> in this path. Since there are no <code>T</code> leafs in
the resulting tree, it is correct to say that the formula is
unsatisfiable: with any value of <code>x</code> we will arrive at
<code>F</code>.</p><p>One more example is
<code>AND(OR(x, F), AND(OR(x, OR(y, F)), AND(OR(NOT x, F), T)))</code>,
which is equivalent to “x AND (y OR z) AND NOT x”:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/if-last-example.png" width="600px"></p>
</div><p>After removing dead paths:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/if-last-example-final.png" width="600px"></p>
</div><p>The general observation is that, after encoding a CNF formula as an
if-tree and removing dead paths from it, if there is at least one
<code>T</code> leaf, the initial formula is satisfiable; otherwise, the
formula is unsatisfiable because there is no path from the root that
will take us to <code>T</code>. Think about it for a moment.</p><p>Having this technique at our disposal, we can proceed to the key
section.</p><a class="header-link" href="#supercompilation-of-sat"><h2 id="supercompilation-of-sat">Supercompilation of SAT</h2></a><p><em>Positive supercompilation</em> is a particular model of
supercompilation that propagates only <em>positive information</em> when
doing case analysis. For example, when supercompiling
<code>add(a, 2)</code>, a positive supercompiler will substitute (i.e.,
propagate) <code>a=Z</code> and <code>a=S(v1)</code> to the respective
children nodes. On the other hand, <em>negative information</em> means
that some variable is <em>not</em> equal to a particular value (or
values); a typical example is the “default” case in a pattern-matching
construction. A <em>perfect supercompiler</em> is a supercompiler that
is able to propagate both positive and negative information.</p><p>In this post, we only deal with positive supercompilation. Consider
the schematic representation of the CNF formula “x AND NOT x” again:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/x-and-not-x.png" width="550px"></p>
</div><p>Imagine that <code>if</code>, <code>T</code>, and <code>F</code> are
SLL constructors, with <code>if</code> holding three arguments: two
branches and a variable, which is <code>T</code> in the first branch and
<code>F</code> in the second. If we analyze the uppermost
<code>if x</code>, we will get the following “process tree” <a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>:</p><div data-align="center">
<p><img src="../media/content/sat-supercompilation/if-x-f-f.png" width="550px"></p>
</div><p>Supercompilation acted as a dead code eliminator! This is because
<code>x=T</code> was propagated to the first branch of the uppermost
<code>if x</code>, resulting in the elimination of the branch
<code>T</code> of the innermost <code>if x</code>. The second uppermost
branch remains unchanged.</p><p>What if we somehow launch analysis of the whole if-tree? If so, we
would essentially eliminate all dead paths from the corresponding
expression, which is equivalent to solving the SAT problem! As I have
mentioned in the previous section, if there is at least one
<code>T</code> leaf in the final tree, the formula is satisfiable
because this <code>T</code> is reachable from the root. Otherwise (if
there is no <code>T</code>), the formula is unsatisfiable <a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>.</p><p>Here is a complete SAT solver written in SLL:</p><p><span class="math display">\[
\begin{aligned}
or(Var(x), rest) &amp;= If(x, T, rest); \\
or(Not(x), rest) &amp;= If(x, rest, T); \\
\\
and(If(x, m, n), rest) &amp;= If(x, and(m, rest), and(n, rest)); \\
and(T, rest) &amp;= rest; \\
and(F, rest) &amp;= F; \\
\\
solve(If(x, m, n)) &amp;= analyze(x, solve(m), solve(n)); \\
solve(T) &amp;= T; \\
solve(F) &amp;= F; \\
\\
analyze(T, m, n) &amp;= m; \\
analyze(F, m, n) &amp;= n;
\end{aligned}
\]</span></p><p>Without blank lines, it is 10 lines of code! This is probably the
simplest (and the slowest!) SAT solver in the history of humanity.</p><p>The functions <code>or</code> and <code>and</code> are the encodings
of the logical OR and AND operations, respectively. The function
<code>solve</code> is the main entry point of the solver, and
<code>analyze</code> is a helper function that selects one of the two
branches of an <code>if</code>-expression according to the value of the
first argument. Since <code>solve</code> traverses the whole expression
and invokes <code>analyze</code> for each <code>If (x, m, n)</code>, all
<code>If</code>-nodes in the expression are case-analyzed when
<code>solve(formula)</code> is being supercompiled.</p><p>To test the solver, I will use my own <a href="https://gist.github.com/hirrolot/35e3c40e49e01cfb11d67b6bcc67b23e">positive
supercompiler written in OCaml</a>. The definitions of <code>or</code>,
<code>and</code>, <code>solve</code>, and <code>analyze</code> will
be:</p><div class="sourceCode" id="cb1"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">let</span> g_rules =</span>
<span id="cb1-2"><a href="#cb1-2"></a>  [</span>
<span id="cb1-3"><a href="#cb1-3"></a>    ( <span class="st">"or"</span>,</span>
<span id="cb1-4"><a href="#cb1-4"></a>      [</span>
<span id="cb1-5"><a href="#cb1-5"></a>        ( (<span class="st">"Var"</span>, [ <span class="st">"x"</span> ]),</span>
<span id="cb1-6"><a href="#cb1-6"></a>          [ <span class="st">"rest"</span> ],</span>
<span id="cb1-7"><a href="#cb1-7"></a>          ctr_call (<span class="st">"If"</span>, [ Var <span class="st">"x"</span>; ctr_call (<span class="st">"T"</span>, []); Var <span class="st">"rest"</span> ]) );</span>
<span id="cb1-8"><a href="#cb1-8"></a>        ( (<span class="st">"Not"</span>, [ <span class="st">"x"</span> ]),</span>
<span id="cb1-9"><a href="#cb1-9"></a>          [ <span class="st">"rest"</span> ],</span>
<span id="cb1-10"><a href="#cb1-10"></a>          ctr_call (<span class="st">"If"</span>, [ Var <span class="st">"x"</span>; Var <span class="st">"rest"</span>; ctr_call (<span class="st">"T"</span>, []) ]) );</span>
<span id="cb1-11"><a href="#cb1-11"></a>      ] );</span>
<span id="cb1-12"><a href="#cb1-12"></a>    ( <span class="st">"and"</span>,</span>
<span id="cb1-13"><a href="#cb1-13"></a>      [</span>
<span id="cb1-14"><a href="#cb1-14"></a>        ( (<span class="st">"If"</span>, [ <span class="st">"x"</span>; <span class="st">"m"</span>; <span class="st">"n"</span> ]),</span>
<span id="cb1-15"><a href="#cb1-15"></a>          [ <span class="st">"rest"</span> ],</span>
<span id="cb1-16"><a href="#cb1-16"></a>          ctr_call</span>
<span id="cb1-17"><a href="#cb1-17"></a>            ( <span class="st">"If"</span>,</span>
<span id="cb1-18"><a href="#cb1-18"></a>              [</span>
<span id="cb1-19"><a href="#cb1-19"></a>                Var <span class="st">"x"</span>;</span>
<span id="cb1-20"><a href="#cb1-20"></a>                g_call (<span class="st">"and"</span>, Var <span class="st">"m"</span>, [ Var <span class="st">"rest"</span> ]);</span>
<span id="cb1-21"><a href="#cb1-21"></a>                g_call (<span class="st">"and"</span>, Var <span class="st">"n"</span>, [ Var <span class="st">"rest"</span> ]);</span>
<span id="cb1-22"><a href="#cb1-22"></a>              ] ) );</span>
<span id="cb1-23"><a href="#cb1-23"></a>        ((<span class="st">"T"</span>, []), [ <span class="st">"rest"</span> ], Var <span class="st">"rest"</span>);</span>
<span id="cb1-24"><a href="#cb1-24"></a>        ((<span class="st">"F"</span>, []), [ <span class="st">"rest"</span> ], ctr_call (<span class="st">"F"</span>, []));</span>
<span id="cb1-25"><a href="#cb1-25"></a>      ] );</span>
<span id="cb1-26"><a href="#cb1-26"></a>    ( <span class="st">"solve"</span>,</span>
<span id="cb1-27"><a href="#cb1-27"></a>      [</span>
<span id="cb1-28"><a href="#cb1-28"></a>        ( (<span class="st">"If"</span>, [ <span class="st">"x"</span>; <span class="st">"m"</span>; <span class="st">"n"</span> ]),</span>
<span id="cb1-29"><a href="#cb1-29"></a>          [],</span>
<span id="cb1-30"><a href="#cb1-30"></a>          g_call</span>
<span id="cb1-31"><a href="#cb1-31"></a>            ( <span class="st">"analyze"</span>,</span>
<span id="cb1-32"><a href="#cb1-32"></a>              Var <span class="st">"x"</span>,</span>
<span id="cb1-33"><a href="#cb1-33"></a>              [ g_call (<span class="st">"solve"</span>, Var <span class="st">"m"</span>, []); g_call (<span class="st">"solve"</span>, Var <span class="st">"n"</span>, []) ]</span>
<span id="cb1-34"><a href="#cb1-34"></a>            ) );</span>
<span id="cb1-35"><a href="#cb1-35"></a>        ((<span class="st">"T"</span>, []), [], ctr_call (<span class="st">"T"</span>, []));</span>
<span id="cb1-36"><a href="#cb1-36"></a>        ((<span class="st">"F"</span>, []), [], ctr_call (<span class="st">"F"</span>, []));</span>
<span id="cb1-37"><a href="#cb1-37"></a>      ] );</span>
<span id="cb1-38"><a href="#cb1-38"></a>    ( <span class="st">"analyze"</span>,</span>
<span id="cb1-39"><a href="#cb1-39"></a>      [ ((<span class="st">"T"</span>, []), [ <span class="st">"m"</span>; <span class="st">"n"</span> ], Var <span class="st">"m"</span>); ((<span class="st">"F"</span>, []), [ <span class="st">"m"</span>; <span class="st">"n"</span> ], Var <span class="st">"n"</span>) ]</span>
<span id="cb1-40"><a href="#cb1-40"></a>    );</span>
<span id="cb1-41"><a href="#cb1-41"></a>  ]</span></code></pre></div><p>And some helper functions in OCaml to conveniently construct CNF
formulas:</p><div class="sourceCode" id="cb2"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">let</span> <span class="kw">rec</span> clause = <span class="kw">function</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  | `Var x :: rest -&gt; g_call (<span class="st">"or"</span>, ctr_call (<span class="st">"Var"</span>, [ Var x ]), [ clause rest ])</span>
<span id="cb2-3"><a href="#cb2-3"></a>  | `Not x :: rest -&gt; g_call (<span class="st">"or"</span>, ctr_call (<span class="st">"Not"</span>, [ Var x ]), [ clause rest ])</span>
<span id="cb2-4"><a href="#cb2-4"></a>  | [] -&gt; ctr_call (<span class="st">"F"</span>, [])</span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="kw">let</span> <span class="kw">rec</span> formula = <span class="kw">function</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>  | hd :: rest -&gt; g_call (<span class="st">"and"</span>, hd, [ formula rest ])</span>
<span id="cb2-8"><a href="#cb2-8"></a>  | [] -&gt; ctr_call (<span class="st">"T"</span>, [])</span></code></pre></div><p>The function <code>check</code> calls <code>optimize</code>, which is
supercompilation + residualization, on a given <code>formula</code>, and
compares the resudual task with <code>expected</code>:</p><div class="sourceCode" id="cb3"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">let</span> check ~expected formula =</span>
<span id="cb3-2"><a href="#cb3-2"></a>  check ~equal:[%derive.eq: <span class="dt">string</span> * <span class="dt">string</span> <span class="dt">list</span>]</span>
<span id="cb3-3"><a href="#cb3-3"></a>    ~show:[%derive.show: <span class="dt">string</span> * <span class="dt">string</span> <span class="dt">list</span>] ~expected</span>
<span id="cb3-4"><a href="#cb3-4"></a>    ~actual:(optimize ~g_rules (g_call (<span class="st">"solve"</span>, formula, [])))</span></code></pre></div><p>Testing “x AND y”:</p><div class="sourceCode" id="cb4"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">let</span> () =</span>
<span id="cb4-2"><a href="#cb4-2"></a>  check</span>
<span id="cb4-3"><a href="#cb4-3"></a>    ~expected:</span>
<span id="cb4-4"><a href="#cb4-4"></a>      ( <span class="st">"g0(x, y)"</span>,</span>
<span id="cb4-5"><a href="#cb4-5"></a>        [</span>
<span id="cb4-6"><a href="#cb4-6"></a>          <span class="st">"g0(F(), y) = F()"</span>;</span>
<span id="cb4-7"><a href="#cb4-7"></a>          <span class="st">"g0(T(), y) = g1(y)"</span>;</span>
<span id="cb4-8"><a href="#cb4-8"></a>          <span class="st">"g1(F()) = F()"</span>;</span>
<span id="cb4-9"><a href="#cb4-9"></a>          <span class="st">"g1(T()) = T()"</span>;</span>
<span id="cb4-10"><a href="#cb4-10"></a>        ] )</span>
<span id="cb4-11"><a href="#cb4-11"></a>    (formula [ clause [ `Var <span class="st">"x"</span> ]; clause [ `Var <span class="st">"y"</span> ] ]);</span></code></pre></div><p>The residual function <code>g0</code> acts as the AND operation. The
formula is <strong>satisfiable</strong>.</p><p>Testing “(x OR y) AND NOT z”:</p><div class="sourceCode" id="cb5"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1"></a>  check</span>
<span id="cb5-2"><a href="#cb5-2"></a>    ~expected:</span>
<span id="cb5-3"><a href="#cb5-3"></a>      ( <span class="st">"g0(x, y, z)"</span>,</span>
<span id="cb5-4"><a href="#cb5-4"></a>        [</span>
<span id="cb5-5"><a href="#cb5-5"></a>          <span class="st">"g0(F(), y, z) = g1(y, z)"</span>;</span>
<span id="cb5-6"><a href="#cb5-6"></a>          <span class="st">"g0(T(), y, z) = g3(z)"</span>;</span>
<span id="cb5-7"><a href="#cb5-7"></a>          <span class="st">"g1(F(), z) = F()"</span>;</span>
<span id="cb5-8"><a href="#cb5-8"></a>          <span class="st">"g1(T(), z) = g2(z)"</span>;</span>
<span id="cb5-9"><a href="#cb5-9"></a>          <span class="st">"g2(F()) = T()"</span>;</span>
<span id="cb5-10"><a href="#cb5-10"></a>          <span class="st">"g2(T()) = F()"</span>;</span>
<span id="cb5-11"><a href="#cb5-11"></a>          <span class="st">"g3(F()) = T()"</span>;</span>
<span id="cb5-12"><a href="#cb5-12"></a>          <span class="st">"g3(T()) = F()"</span>;</span>
<span id="cb5-13"><a href="#cb5-13"></a>        ] )</span>
<span id="cb5-14"><a href="#cb5-14"></a>    (formula [ clause [ `Var <span class="st">"x"</span>; `Var <span class="st">"y"</span> ]; clause [ `Not <span class="st">"z"</span> ] ]);</span></code></pre></div><p>The formula is TRUE when either “x” or “y” are TRUE (or both), whilst
“z” must always be FALSE. The formula is
<strong>satisfiable</strong>.</p><p>Testing “(x OR NOT z) AND (y OR z OR NOT x)”:</p><div class="sourceCode" id="cb6"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1"></a>  check</span>
<span id="cb6-2"><a href="#cb6-2"></a>    ~expected:</span>
<span id="cb6-3"><a href="#cb6-3"></a>      ( <span class="st">"g0(x, y, z)"</span>,</span>
<span id="cb6-4"><a href="#cb6-4"></a>        [</span>
<span id="cb6-5"><a href="#cb6-5"></a>          <span class="st">"g0(F(), y, z) = g1(z, y)"</span>;</span>
<span id="cb6-6"><a href="#cb6-6"></a>          <span class="st">"g0(T(), y, z) = g3(y, z)"</span>;</span>
<span id="cb6-7"><a href="#cb6-7"></a>          <span class="st">"g1(F(), y) = g2(y)"</span>;</span>
<span id="cb6-8"><a href="#cb6-8"></a>          <span class="st">"g1(T(), y) = F()"</span>;</span>
<span id="cb6-9"><a href="#cb6-9"></a>          <span class="st">"g2(F()) = T()"</span>;</span>
<span id="cb6-10"><a href="#cb6-10"></a>          <span class="st">"g2(T()) = T()"</span>;</span>
<span id="cb6-11"><a href="#cb6-11"></a>          <span class="st">"g3(F(), z) = g4(z)"</span>;</span>
<span id="cb6-12"><a href="#cb6-12"></a>          <span class="st">"g3(T(), z) = T()"</span>;</span>
<span id="cb6-13"><a href="#cb6-13"></a>          <span class="st">"g4(F()) = F()"</span>;</span>
<span id="cb6-14"><a href="#cb6-14"></a>          <span class="st">"g4(T()) = T()"</span>;</span>
<span id="cb6-15"><a href="#cb6-15"></a>        ] )</span>
<span id="cb6-16"><a href="#cb6-16"></a>    (formula</span>
<span id="cb6-17"><a href="#cb6-17"></a>       [</span>
<span id="cb6-18"><a href="#cb6-18"></a>         clause [ `Var <span class="st">"x"</span>; `Not <span class="st">"z"</span> ]; clause [ `Var <span class="st">"y"</span>; `Var <span class="st">"z"</span>; `Not <span class="st">"x"</span> ];</span>
<span id="cb6-19"><a href="#cb6-19"></a>       ]);</span></code></pre></div><p>Ditto.</p><p>Testing “(a OR b) AND (NOT b OR NOT d) AND (c OR d) AND (NOT d OR NOT
e) AND (e OR NOT f) AND (f OR NOT g) AND (f OR g) AND (g OR NOT p) AND
(h OR NOT i) AND (NOT h OR NOT n) AND (i OR g) AND (i OR NOT g) AND (NOT
g OR NOT k) AND (g OR l) AND (k OR l) AND (m OR n) AND (n OR NOT o) AND
(o OR p)”:</p><details>
<summary>
Show the test case
</summary>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1"></a>  check</span>
<span id="cb7-2"><a href="#cb7-2"></a>    ~expected:</span>
<span id="cb7-3"><a href="#cb7-3"></a>      ( <span class="st">"g0(a, b, c, d, e, f, g, h, i, k, l, m, n, o, p)"</span>,</span>
<span id="cb7-4"><a href="#cb7-4"></a>        [</span>
<span id="cb7-5"><a href="#cb7-5"></a>          <span class="st">"g0(F(), b, c, d, e, f, g, h, i, k, l, m, n, o, p) = g1(b, c, d, e, </span><span class="ch">\</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="st">           f, g, h, i, k, l, m, n, o, p)"</span>;</span>
<span id="cb7-7"><a href="#cb7-7"></a>          <span class="st">"g0(T(), b, c, d, e, f, g, h, i, k, l, m, n, o, p) = g30(b, c, d, e, </span><span class="ch">\</span></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="st">           f, g, h, i, k, l, m, n, o, p)"</span>;</span>
<span id="cb7-9"><a href="#cb7-9"></a>          <span class="st">"g1(F(), c, d, e, f, g, h, i, k, l, m, n, o, p) = F()"</span>;</span>
<span id="cb7-10"><a href="#cb7-10"></a>          <span class="st">"g1(T(), c, d, e, f, g, h, i, k, l, m, n, o, p) = g2(d, c, e, f, g, </span><span class="ch">\</span></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="st">           h, i, k, l, m, n, o, p)"</span>;</span>
<span id="cb7-12"><a href="#cb7-12"></a>          <span class="st">"g10(F(), h, i, k, l, m, n, o) = g11(h, i, k, l, m, n, o)"</span>;</span>
<span id="cb7-13"><a href="#cb7-13"></a>          <span class="st">"g10(T(), h, i, k, l, m, n, o) = F()"</span>;</span>
<span id="cb7-14"><a href="#cb7-14"></a>          <span class="st">"g11(F(), i, k, l, m, n, o) = g12(i)"</span>;</span>
<span id="cb7-15"><a href="#cb7-15"></a>          <span class="st">"g11(T(), i, k, l, m, n, o) = g13(n, i, k, l, m, o)"</span>;</span>
<span id="cb7-16"><a href="#cb7-16"></a>          <span class="st">"g12(F()) = F()"</span>;</span>
<span id="cb7-17"><a href="#cb7-17"></a>          <span class="st">"g12(T()) = F()"</span>;</span>
<span id="cb7-18"><a href="#cb7-18"></a>          <span class="st">"g13(F(), i, k, l, m, o) = g14(i, k, l, m, o)"</span>;</span>
<span id="cb7-19"><a href="#cb7-19"></a>          <span class="st">"g13(T(), i, k, l, m, o) = F()"</span>;</span>
<span id="cb7-20"><a href="#cb7-20"></a>          <span class="st">"g14(F(), k, l, m, o) = F()"</span>;</span>
<span id="cb7-21"><a href="#cb7-21"></a>          <span class="st">"g14(T(), k, l, m, o) = g15(l, k, m, o)"</span>;</span>
<span id="cb7-22"><a href="#cb7-22"></a>          <span class="st">"g15(F(), k, m, o) = F()"</span>;</span>
<span id="cb7-23"><a href="#cb7-23"></a>          <span class="st">"g15(T(), k, m, o) = g16(k, m, o)"</span>;</span>
<span id="cb7-24"><a href="#cb7-24"></a>          <span class="st">"g16(F(), m, o) = g17(m, o)"</span>;</span>
<span id="cb7-25"><a href="#cb7-25"></a>          <span class="st">"g16(T(), m, o) = g19(m, o)"</span>;</span>
<span id="cb7-26"><a href="#cb7-26"></a>          <span class="st">"g17(F(), o) = F()"</span>;</span>
<span id="cb7-27"><a href="#cb7-27"></a>          <span class="st">"g17(T(), o) = g18(o)"</span>;</span>
<span id="cb7-28"><a href="#cb7-28"></a>          <span class="st">"g18(F()) = F()"</span>;</span>
<span id="cb7-29"><a href="#cb7-29"></a>          <span class="st">"g18(T()) = F()"</span>;</span>
<span id="cb7-30"><a href="#cb7-30"></a>          <span class="st">"g19(F(), o) = F()"</span>;</span>
<span id="cb7-31"><a href="#cb7-31"></a>          <span class="st">"g19(T(), o) = g20(o)"</span>;</span>
<span id="cb7-32"><a href="#cb7-32"></a>          <span class="st">"g2(F(), c, e, f, g, h, i, k, l, m, n, o, p) = g3(c, e, f, g, h, i, </span><span class="ch">\</span></span>
<span id="cb7-33"><a href="#cb7-33"></a><span class="st">           k, l, m, n, o, p)"</span>;</span>
<span id="cb7-34"><a href="#cb7-34"></a>          <span class="st">"g2(T(), c, e, f, g, h, i, k, l, m, n, o, p) = F()"</span>;</span>
<span id="cb7-35"><a href="#cb7-35"></a>          <span class="st">"g20(F()) = F()"</span>;</span>
<span id="cb7-36"><a href="#cb7-36"></a>          <span class="st">"g20(T()) = F()"</span>;</span>
<span id="cb7-37"><a href="#cb7-37"></a>          <span class="st">"g21(F(), i, k, l, m, n, o, p) = g22(i)"</span>;</span>
<span id="cb7-38"><a href="#cb7-38"></a>          <span class="st">"g21(T(), i, k, l, m, n, o, p) = g23(n, i, k, l, m, o, p)"</span>;</span>
<span id="cb7-39"><a href="#cb7-39"></a>          <span class="st">"g22(F()) = F()"</span>;</span>
<span id="cb7-40"><a href="#cb7-40"></a>          <span class="st">"g22(T()) = F()"</span>;</span>
<span id="cb7-41"><a href="#cb7-41"></a>          <span class="st">"g23(F(), i, k, l, m, o, p) = g24(i, k, l, m, o, p)"</span>;</span>
<span id="cb7-42"><a href="#cb7-42"></a>          <span class="st">"g23(T(), i, k, l, m, o, p) = F()"</span>;</span>
<span id="cb7-43"><a href="#cb7-43"></a>          <span class="st">"g24(F(), k, l, m, o, p) = F()"</span>;</span>
<span id="cb7-44"><a href="#cb7-44"></a>          <span class="st">"g24(T(), k, l, m, o, p) = g25(k, l, m, o, p)"</span>;</span>
<span id="cb7-45"><a href="#cb7-45"></a>          <span class="st">"g25(F(), l, m, o, p) = g26(l, m, o, p)"</span>;</span>
<span id="cb7-46"><a href="#cb7-46"></a>          <span class="st">"g25(T(), l, m, o, p) = F()"</span>;</span>
<span id="cb7-47"><a href="#cb7-47"></a>          <span class="st">"g26(F(), m, o, p) = F()"</span>;</span>
<span id="cb7-48"><a href="#cb7-48"></a>          <span class="st">"g26(T(), m, o, p) = g27(m, o, p)"</span>;</span>
<span id="cb7-49"><a href="#cb7-49"></a>          <span class="st">"g27(F(), o, p) = F()"</span>;</span>
<span id="cb7-50"><a href="#cb7-50"></a>          <span class="st">"g27(T(), o, p) = g28(o, p)"</span>;</span>
<span id="cb7-51"><a href="#cb7-51"></a>          <span class="st">"g28(F(), p) = g29(p)"</span>;</span>
<span id="cb7-52"><a href="#cb7-52"></a>          <span class="st">"g28(T(), p) = F()"</span>;</span>
<span id="cb7-53"><a href="#cb7-53"></a>          <span class="st">"g29(F()) = F()"</span>;</span>
<span id="cb7-54"><a href="#cb7-54"></a>          <span class="st">"g29(T()) = T()"</span>;</span>
<span id="cb7-55"><a href="#cb7-55"></a>          <span class="st">"g3(F(), e, f, g, h, i, k, l, m, n, o, p) = F()"</span>;</span>
<span id="cb7-56"><a href="#cb7-56"></a>          <span class="st">"g3(T(), e, f, g, h, i, k, l, m, n, o, p) = g4(e, f, g, h, i, k, l, </span><span class="ch">\</span></span>
<span id="cb7-57"><a href="#cb7-57"></a><span class="st">           m, n, o, p)"</span>;</span>
<span id="cb7-58"><a href="#cb7-58"></a>          <span class="st">"g30(F(), c, d, e, f, g, h, i, k, l, m, n, o, p) = g31(c, d, e, f, </span><span class="ch">\</span></span>
<span id="cb7-59"><a href="#cb7-59"></a><span class="st">           g, h, i, k, l, m, n, o, p)"</span>;</span>
<span id="cb7-60"><a href="#cb7-60"></a>          <span class="st">"g30(T(), c, d, e, f, g, h, i, k, l, m, n, o, p) = g66(d, c, e, f, </span><span class="ch">\</span></span>
<span id="cb7-61"><a href="#cb7-61"></a><span class="st">           g, h, i, k, l, m, n, o, p)"</span>;</span>
<span id="cb7-62"><a href="#cb7-62"></a>          <span class="st">"g31(F(), d, e, f, g, h, i, k, l, m, n, o, p) = g32(d, e, f, g)"</span>;</span>
<span id="cb7-63"><a href="#cb7-63"></a>          <span class="st">"g31(T(), d, e, f, g, h, i, k, l, m, n, o, p) = g36(d, e, f, g, h, </span><span class="ch">\</span></span>
<span id="cb7-64"><a href="#cb7-64"></a><span class="st">           i, k, l, m, n, o, p)"</span>;</span>
<span id="cb7-65"><a href="#cb7-65"></a>          <span class="st">"g32(F(), e, f, g) = F()"</span>;</span>
<span id="cb7-66"><a href="#cb7-66"></a>          <span class="st">"g32(T(), e, f, g) = g33(e, f, g)"</span>;</span>
<span id="cb7-67"><a href="#cb7-67"></a>          <span class="st">"g33(F(), f, g) = g34(f, g)"</span>;</span>
<span id="cb7-68"><a href="#cb7-68"></a>          <span class="st">"g33(T(), f, g) = F()"</span>;</span>
<span id="cb7-69"><a href="#cb7-69"></a>          <span class="st">"g34(F(), g) = g35(g)"</span>;</span>
<span id="cb7-70"><a href="#cb7-70"></a>          <span class="st">"g34(T(), g) = F()"</span>;</span>
<span id="cb7-71"><a href="#cb7-71"></a>          <span class="st">"g35(F()) = F()"</span>;</span>
<span id="cb7-72"><a href="#cb7-72"></a>          <span class="st">"g35(T()) = F()"</span>;</span>
<span id="cb7-73"><a href="#cb7-73"></a>          <span class="st">"g36(F(), e, f, g, h, i, k, l, m, n, o, p) = g37(e, f, g, h, i, k, </span><span class="ch">\</span></span>
<span id="cb7-74"><a href="#cb7-74"></a><span class="st">           l, m, n, o, p)"</span>;</span>
<span id="cb7-75"><a href="#cb7-75"></a>          <span class="st">"g36(T(), e, f, g, h, i, k, l, m, n, o, p) = g63(e, f, g)"</span>;</span>
<span id="cb7-76"><a href="#cb7-76"></a>          <span class="st">"g37(F(), f, g, h, i, k, l, m, n, o, p) = g38(f, g)"</span>;</span>
<span id="cb7-77"><a href="#cb7-77"></a>          <span class="st">"g37(T(), f, g, h, i, k, l, m, n, o, p) = g40(f, g, h, i, k, l, m, </span><span class="ch">\</span></span>
<span id="cb7-78"><a href="#cb7-78"></a><span class="st">           n, o, p)"</span>;</span>
<span id="cb7-79"><a href="#cb7-79"></a>          <span class="st">"g38(F(), g) = g39(g)"</span>;</span>
<span id="cb7-80"><a href="#cb7-80"></a>          <span class="st">"g38(T(), g) = F()"</span>;</span>
<span id="cb7-81"><a href="#cb7-81"></a>          <span class="st">"g39(F()) = F()"</span>;</span>
<span id="cb7-82"><a href="#cb7-82"></a>          <span class="st">"g39(T()) = F()"</span>;</span>
<span id="cb7-83"><a href="#cb7-83"></a>          <span class="st">"g4(F(), f, g, h, i, k, l, m, n, o, p) = g5(f, g)"</span>;</span>
<span id="cb7-84"><a href="#cb7-84"></a>          <span class="st">"g4(T(), f, g, h, i, k, l, m, n, o, p) = g7(f, g, h, i, k, l, m, n, </span><span class="ch">\</span></span>
<span id="cb7-85"><a href="#cb7-85"></a><span class="st">           o, p)"</span>;</span>
<span id="cb7-86"><a href="#cb7-86"></a>          <span class="st">"g40(F(), g, h, i, k, l, m, n, o, p) = g41(g)"</span>;</span>
<span id="cb7-87"><a href="#cb7-87"></a>          <span class="st">"g40(T(), g, h, i, k, l, m, n, o, p) = g42(g, h, i, k, l, m, n, o, p)"</span>;</span>
<span id="cb7-88"><a href="#cb7-88"></a>          <span class="st">"g41(F()) = F()"</span>;</span>
<span id="cb7-89"><a href="#cb7-89"></a>          <span class="st">"g41(T()) = F()"</span>;</span>
<span id="cb7-90"><a href="#cb7-90"></a>          <span class="st">"g42(F(), h, i, k, l, m, n, o, p) = g43(p, h, i, k, l, m, n, o)"</span>;</span>
<span id="cb7-91"><a href="#cb7-91"></a>          <span class="st">"g42(T(), h, i, k, l, m, n, o, p) = g54(h, i, k, l, m, n, o, p)"</span>;</span>
<span id="cb7-92"><a href="#cb7-92"></a>          <span class="st">"g43(F(), h, i, k, l, m, n, o) = g44(h, i, k, l, m, n, o)"</span>;</span>
<span id="cb7-93"><a href="#cb7-93"></a>          <span class="st">"g43(T(), h, i, k, l, m, n, o) = F()"</span>;</span>
<span id="cb7-94"><a href="#cb7-94"></a>          <span class="st">"g44(F(), i, k, l, m, n, o) = g45(i)"</span>;</span>
<span id="cb7-95"><a href="#cb7-95"></a>          <span class="st">"g44(T(), i, k, l, m, n, o) = g46(n, i, k, l, m, o)"</span>;</span>
<span id="cb7-96"><a href="#cb7-96"></a>          <span class="st">"g45(F()) = F()"</span>;</span>
<span id="cb7-97"><a href="#cb7-97"></a>          <span class="st">"g45(T()) = F()"</span>;</span>
<span id="cb7-98"><a href="#cb7-98"></a>          <span class="st">"g46(F(), i, k, l, m, o) = g47(i, k, l, m, o)"</span>;</span>
<span id="cb7-99"><a href="#cb7-99"></a>          <span class="st">"g46(T(), i, k, l, m, o) = F()"</span>;</span>
<span id="cb7-100"><a href="#cb7-100"></a>          <span class="st">"g47(F(), k, l, m, o) = F()"</span>;</span>
<span id="cb7-101"><a href="#cb7-101"></a>          <span class="st">"g47(T(), k, l, m, o) = g48(l, k, m, o)"</span>;</span>
<span id="cb7-102"><a href="#cb7-102"></a>          <span class="st">"g48(F(), k, m, o) = F()"</span>;</span>
<span id="cb7-103"><a href="#cb7-103"></a>          <span class="st">"g48(T(), k, m, o) = g49(k, m, o)"</span>;</span>
<span id="cb7-104"><a href="#cb7-104"></a>          <span class="st">"g49(F(), m, o) = g50(m, o)"</span>;</span>
<span id="cb7-105"><a href="#cb7-105"></a>          <span class="st">"g49(T(), m, o) = g52(m, o)"</span>;</span>
<span id="cb7-106"><a href="#cb7-106"></a>          <span class="st">"g5(F(), g) = g6(g)"</span>;</span>
<span id="cb7-107"><a href="#cb7-107"></a>          <span class="st">"g5(T(), g) = F()"</span>;</span>
<span id="cb7-108"><a href="#cb7-108"></a>          <span class="st">"g50(F(), o) = F()"</span>;</span>
<span id="cb7-109"><a href="#cb7-109"></a>          <span class="st">"g50(T(), o) = g51(o)"</span>;</span>
<span id="cb7-110"><a href="#cb7-110"></a>          <span class="st">"g51(F()) = F()"</span>;</span>
<span id="cb7-111"><a href="#cb7-111"></a>          <span class="st">"g51(T()) = F()"</span>;</span>
<span id="cb7-112"><a href="#cb7-112"></a>          <span class="st">"g52(F(), o) = F()"</span>;</span>
<span id="cb7-113"><a href="#cb7-113"></a>          <span class="st">"g52(T(), o) = g53(o)"</span>;</span>
<span id="cb7-114"><a href="#cb7-114"></a>          <span class="st">"g53(F()) = F()"</span>;</span>
<span id="cb7-115"><a href="#cb7-115"></a>          <span class="st">"g53(T()) = F()"</span>;</span>
<span id="cb7-116"><a href="#cb7-116"></a>          <span class="st">"g54(F(), i, k, l, m, n, o, p) = g55(i)"</span>;</span>
<span id="cb7-117"><a href="#cb7-117"></a>          <span class="st">"g54(T(), i, k, l, m, n, o, p) = g56(n, i, k, l, m, o, p)"</span>;</span>
<span id="cb7-118"><a href="#cb7-118"></a>          <span class="st">"g55(F()) = F()"</span>;</span>
<span id="cb7-119"><a href="#cb7-119"></a>          <span class="st">"g55(T()) = F()"</span>;</span>
<span id="cb7-120"><a href="#cb7-120"></a>          <span class="st">"g56(F(), i, k, l, m, o, p) = g57(i, k, l, m, o, p)"</span>;</span>
<span id="cb7-121"><a href="#cb7-121"></a>          <span class="st">"g56(T(), i, k, l, m, o, p) = F()"</span>;</span>
<span id="cb7-122"><a href="#cb7-122"></a>          <span class="st">"g57(F(), k, l, m, o, p) = F()"</span>;</span>
<span id="cb7-123"><a href="#cb7-123"></a>          <span class="st">"g57(T(), k, l, m, o, p) = g58(k, l, m, o, p)"</span>;</span>
<span id="cb7-124"><a href="#cb7-124"></a>          <span class="st">"g58(F(), l, m, o, p) = g59(l, m, o, p)"</span>;</span>
<span id="cb7-125"><a href="#cb7-125"></a>          <span class="st">"g58(T(), l, m, o, p) = F()"</span>;</span>
<span id="cb7-126"><a href="#cb7-126"></a>          <span class="st">"g59(F(), m, o, p) = F()"</span>;</span>
<span id="cb7-127"><a href="#cb7-127"></a>          <span class="st">"g59(T(), m, o, p) = g60(m, o, p)"</span>;</span>
<span id="cb7-128"><a href="#cb7-128"></a>          <span class="st">"g6(F()) = F()"</span>;</span>
<span id="cb7-129"><a href="#cb7-129"></a>          <span class="st">"g6(T()) = F()"</span>;</span>
<span id="cb7-130"><a href="#cb7-130"></a>          <span class="st">"g60(F(), o, p) = F()"</span>;</span>
<span id="cb7-131"><a href="#cb7-131"></a>          <span class="st">"g60(T(), o, p) = g61(o, p)"</span>;</span>
<span id="cb7-132"><a href="#cb7-132"></a>          <span class="st">"g61(F(), p) = g62(p)"</span>;</span>
<span id="cb7-133"><a href="#cb7-133"></a>          <span class="st">"g61(T(), p) = F()"</span>;</span>
<span id="cb7-134"><a href="#cb7-134"></a>          <span class="st">"g62(F()) = F()"</span>;</span>
<span id="cb7-135"><a href="#cb7-135"></a>          <span class="st">"g62(T()) = T()"</span>;</span>
<span id="cb7-136"><a href="#cb7-136"></a>          <span class="st">"g63(F(), f, g) = g64(f, g)"</span>;</span>
<span id="cb7-137"><a href="#cb7-137"></a>          <span class="st">"g63(T(), f, g) = F()"</span>;</span>
<span id="cb7-138"><a href="#cb7-138"></a>          <span class="st">"g64(F(), g) = g65(g)"</span>;</span>
<span id="cb7-139"><a href="#cb7-139"></a>          <span class="st">"g64(T(), g) = F()"</span>;</span>
<span id="cb7-140"><a href="#cb7-140"></a>          <span class="st">"g65(F()) = F()"</span>;</span>
<span id="cb7-141"><a href="#cb7-141"></a>          <span class="st">"g65(T()) = F()"</span>;</span>
<span id="cb7-142"><a href="#cb7-142"></a>          <span class="st">"g66(F(), c, e, f, g, h, i, k, l, m, n, o, p) = g67(c, e, f, g, h, </span><span class="ch">\</span></span>
<span id="cb7-143"><a href="#cb7-143"></a><span class="st">           i, k, l, m, n, o, p)"</span>;</span>
<span id="cb7-144"><a href="#cb7-144"></a>          <span class="st">"g66(T(), c, e, f, g, h, i, k, l, m, n, o, p) = F()"</span>;</span>
<span id="cb7-145"><a href="#cb7-145"></a>          <span class="st">"g67(F(), e, f, g, h, i, k, l, m, n, o, p) = F()"</span>;</span>
<span id="cb7-146"><a href="#cb7-146"></a>          <span class="st">"g67(T(), e, f, g, h, i, k, l, m, n, o, p) = g68(e, f, g, h, i, k, </span><span class="ch">\</span></span>
<span id="cb7-147"><a href="#cb7-147"></a><span class="st">           l, m, n, o, p)"</span>;</span>
<span id="cb7-148"><a href="#cb7-148"></a>          <span class="st">"g68(F(), f, g, h, i, k, l, m, n, o, p) = g69(f, g)"</span>;</span>
<span id="cb7-149"><a href="#cb7-149"></a>          <span class="st">"g68(T(), f, g, h, i, k, l, m, n, o, p) = g71(f, g, h, i, k, l, m, </span><span class="ch">\</span></span>
<span id="cb7-150"><a href="#cb7-150"></a><span class="st">           n, o, p)"</span>;</span>
<span id="cb7-151"><a href="#cb7-151"></a>          <span class="st">"g69(F(), g) = g70(g)"</span>;</span>
<span id="cb7-152"><a href="#cb7-152"></a>          <span class="st">"g69(T(), g) = F()"</span>;</span>
<span id="cb7-153"><a href="#cb7-153"></a>          <span class="st">"g7(F(), g, h, i, k, l, m, n, o, p) = g8(g)"</span>;</span>
<span id="cb7-154"><a href="#cb7-154"></a>          <span class="st">"g7(T(), g, h, i, k, l, m, n, o, p) = g9(g, h, i, k, l, m, n, o, p)"</span>;</span>
<span id="cb7-155"><a href="#cb7-155"></a>          <span class="st">"g70(F()) = F()"</span>;</span>
<span id="cb7-156"><a href="#cb7-156"></a>          <span class="st">"g70(T()) = F()"</span>;</span>
<span id="cb7-157"><a href="#cb7-157"></a>          <span class="st">"g71(F(), g, h, i, k, l, m, n, o, p) = g72(g)"</span>;</span>
<span id="cb7-158"><a href="#cb7-158"></a>          <span class="st">"g71(T(), g, h, i, k, l, m, n, o, p) = g73(g, h, i, k, l, m, n, o, p)"</span>;</span>
<span id="cb7-159"><a href="#cb7-159"></a>          <span class="st">"g72(F()) = F()"</span>;</span>
<span id="cb7-160"><a href="#cb7-160"></a>          <span class="st">"g72(T()) = F()"</span>;</span>
<span id="cb7-161"><a href="#cb7-161"></a>          <span class="st">"g73(F(), h, i, k, l, m, n, o, p) = g74(p, h, i, k, l, m, n, o)"</span>;</span>
<span id="cb7-162"><a href="#cb7-162"></a>          <span class="st">"g73(T(), h, i, k, l, m, n, o, p) = g85(h, i, k, l, m, n, o, p)"</span>;</span>
<span id="cb7-163"><a href="#cb7-163"></a>          <span class="st">"g74(F(), h, i, k, l, m, n, o) = g75(h, i, k, l, m, n, o)"</span>;</span>
<span id="cb7-164"><a href="#cb7-164"></a>          <span class="st">"g74(T(), h, i, k, l, m, n, o) = F()"</span>;</span>
<span id="cb7-165"><a href="#cb7-165"></a>          <span class="st">"g75(F(), i, k, l, m, n, o) = g76(i)"</span>;</span>
<span id="cb7-166"><a href="#cb7-166"></a>          <span class="st">"g75(T(), i, k, l, m, n, o) = g77(n, i, k, l, m, o)"</span>;</span>
<span id="cb7-167"><a href="#cb7-167"></a>          <span class="st">"g76(F()) = F()"</span>;</span>
<span id="cb7-168"><a href="#cb7-168"></a>          <span class="st">"g76(T()) = F()"</span>;</span>
<span id="cb7-169"><a href="#cb7-169"></a>          <span class="st">"g77(F(), i, k, l, m, o) = g78(i, k, l, m, o)"</span>;</span>
<span id="cb7-170"><a href="#cb7-170"></a>          <span class="st">"g77(T(), i, k, l, m, o) = F()"</span>;</span>
<span id="cb7-171"><a href="#cb7-171"></a>          <span class="st">"g78(F(), k, l, m, o) = F()"</span>;</span>
<span id="cb7-172"><a href="#cb7-172"></a>          <span class="st">"g78(T(), k, l, m, o) = g79(l, k, m, o)"</span>;</span>
<span id="cb7-173"><a href="#cb7-173"></a>          <span class="st">"g79(F(), k, m, o) = F()"</span>;</span>
<span id="cb7-174"><a href="#cb7-174"></a>          <span class="st">"g79(T(), k, m, o) = g80(k, m, o)"</span>;</span>
<span id="cb7-175"><a href="#cb7-175"></a>          <span class="st">"g8(F()) = F()"</span>;</span>
<span id="cb7-176"><a href="#cb7-176"></a>          <span class="st">"g8(T()) = F()"</span>;</span>
<span id="cb7-177"><a href="#cb7-177"></a>          <span class="st">"g80(F(), m, o) = g81(m, o)"</span>;</span>
<span id="cb7-178"><a href="#cb7-178"></a>          <span class="st">"g80(T(), m, o) = g83(m, o)"</span>;</span>
<span id="cb7-179"><a href="#cb7-179"></a>          <span class="st">"g81(F(), o) = F()"</span>;</span>
<span id="cb7-180"><a href="#cb7-180"></a>          <span class="st">"g81(T(), o) = g82(o)"</span>;</span>
<span id="cb7-181"><a href="#cb7-181"></a>          <span class="st">"g82(F()) = F()"</span>;</span>
<span id="cb7-182"><a href="#cb7-182"></a>          <span class="st">"g82(T()) = F()"</span>;</span>
<span id="cb7-183"><a href="#cb7-183"></a>          <span class="st">"g83(F(), o) = F()"</span>;</span>
<span id="cb7-184"><a href="#cb7-184"></a>          <span class="st">"g83(T(), o) = g84(o)"</span>;</span>
<span id="cb7-185"><a href="#cb7-185"></a>          <span class="st">"g84(F()) = F()"</span>;</span>
<span id="cb7-186"><a href="#cb7-186"></a>          <span class="st">"g84(T()) = F()"</span>;</span>
<span id="cb7-187"><a href="#cb7-187"></a>          <span class="st">"g85(F(), i, k, l, m, n, o, p) = g86(i)"</span>;</span>
<span id="cb7-188"><a href="#cb7-188"></a>          <span class="st">"g85(T(), i, k, l, m, n, o, p) = g87(n, i, k, l, m, o, p)"</span>;</span>
<span id="cb7-189"><a href="#cb7-189"></a>          <span class="st">"g86(F()) = F()"</span>;</span>
<span id="cb7-190"><a href="#cb7-190"></a>          <span class="st">"g86(T()) = F()"</span>;</span>
<span id="cb7-191"><a href="#cb7-191"></a>          <span class="st">"g87(F(), i, k, l, m, o, p) = g88(i, k, l, m, o, p)"</span>;</span>
<span id="cb7-192"><a href="#cb7-192"></a>          <span class="st">"g87(T(), i, k, l, m, o, p) = F()"</span>;</span>
<span id="cb7-193"><a href="#cb7-193"></a>          <span class="st">"g88(F(), k, l, m, o, p) = F()"</span>;</span>
<span id="cb7-194"><a href="#cb7-194"></a>          <span class="st">"g88(T(), k, l, m, o, p) = g89(k, l, m, o, p)"</span>;</span>
<span id="cb7-195"><a href="#cb7-195"></a>          <span class="st">"g89(F(), l, m, o, p) = g90(l, m, o, p)"</span>;</span>
<span id="cb7-196"><a href="#cb7-196"></a>          <span class="st">"g89(T(), l, m, o, p) = F()"</span>;</span>
<span id="cb7-197"><a href="#cb7-197"></a>          <span class="st">"g9(F(), h, i, k, l, m, n, o, p) = g10(p, h, i, k, l, m, n, o)"</span>;</span>
<span id="cb7-198"><a href="#cb7-198"></a>          <span class="st">"g9(T(), h, i, k, l, m, n, o, p) = g21(h, i, k, l, m, n, o, p)"</span>;</span>
<span id="cb7-199"><a href="#cb7-199"></a>          <span class="st">"g90(F(), m, o, p) = F()"</span>;</span>
<span id="cb7-200"><a href="#cb7-200"></a>          <span class="st">"g90(T(), m, o, p) = g91(m, o, p)"</span>;</span>
<span id="cb7-201"><a href="#cb7-201"></a>          <span class="st">"g91(F(), o, p) = F()"</span>;</span>
<span id="cb7-202"><a href="#cb7-202"></a>          <span class="st">"g91(T(), o, p) = g92(o, p)"</span>;</span>
<span id="cb7-203"><a href="#cb7-203"></a>          <span class="st">"g92(F(), p) = g93(p)"</span>;</span>
<span id="cb7-204"><a href="#cb7-204"></a>          <span class="st">"g92(T(), p) = F()"</span>;</span>
<span id="cb7-205"><a href="#cb7-205"></a>          <span class="st">"g93(F()) = F()"</span>;</span>
<span id="cb7-206"><a href="#cb7-206"></a>          <span class="st">"g93(T()) = T()"</span>;</span>
<span id="cb7-207"><a href="#cb7-207"></a>        ] )</span>
<span id="cb7-208"><a href="#cb7-208"></a>    (formula</span>
<span id="cb7-209"><a href="#cb7-209"></a>       [</span>
<span id="cb7-210"><a href="#cb7-210"></a>         clause [ `Var <span class="st">"a"</span>; `Var <span class="st">"b"</span> ];</span>
<span id="cb7-211"><a href="#cb7-211"></a>         clause [ `Not <span class="st">"b"</span>; `Not <span class="st">"d"</span> ];</span>
<span id="cb7-212"><a href="#cb7-212"></a>         clause [ `Var <span class="st">"c"</span>; `Var <span class="st">"d"</span> ];</span>
<span id="cb7-213"><a href="#cb7-213"></a>         clause [ `Not <span class="st">"d"</span>; `Not <span class="st">"e"</span> ];</span>
<span id="cb7-214"><a href="#cb7-214"></a>         clause [ `Var <span class="st">"e"</span>; `Not <span class="st">"f"</span> ];</span>
<span id="cb7-215"><a href="#cb7-215"></a>         clause [ `Var <span class="st">"f"</span>; `Not <span class="st">"g"</span> ];</span>
<span id="cb7-216"><a href="#cb7-216"></a>         clause [ `Var <span class="st">"f"</span>; `Var <span class="st">"g"</span> ];</span>
<span id="cb7-217"><a href="#cb7-217"></a>         clause [ `Var <span class="st">"g"</span>; `Not <span class="st">"p"</span> ];</span>
<span id="cb7-218"><a href="#cb7-218"></a>         clause [ `Var <span class="st">"h"</span>; `Not <span class="st">"i"</span> ];</span>
<span id="cb7-219"><a href="#cb7-219"></a>         clause [ `Not <span class="st">"h"</span>; `Not <span class="st">"n"</span> ];</span>
<span id="cb7-220"><a href="#cb7-220"></a>         clause [ `Var <span class="st">"i"</span>; `Var <span class="st">"g"</span> ];</span>
<span id="cb7-221"><a href="#cb7-221"></a>         clause [ `Var <span class="st">"i"</span>; `Not <span class="st">"g"</span> ];</span>
<span id="cb7-222"><a href="#cb7-222"></a>         clause [ `Not <span class="st">"g"</span>; `Not <span class="st">"k"</span> ];</span>
<span id="cb7-223"><a href="#cb7-223"></a>         clause [ `Var <span class="st">"g"</span>; `Var <span class="st">"l"</span> ];</span>
<span id="cb7-224"><a href="#cb7-224"></a>         clause [ `Var <span class="st">"k"</span>; `Var <span class="st">"l"</span> ];</span>
<span id="cb7-225"><a href="#cb7-225"></a>         clause [ `Var <span class="st">"m"</span>; `Var <span class="st">"n"</span> ];</span>
<span id="cb7-226"><a href="#cb7-226"></a>         clause [ `Var <span class="st">"n"</span>; `Not <span class="st">"o"</span> ];</span>
<span id="cb7-227"><a href="#cb7-227"></a>         clause [ `Var <span class="st">"o"</span>; `Var <span class="st">"p"</span> ];</span>
<span id="cb7-228"><a href="#cb7-228"></a>       ]);</span></code></pre></div>
</details><p>Ditto.</p><p>Testing “x AND NOT x”:</p><div class="sourceCode" id="cb8"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1"></a>  check</span>
<span id="cb8-2"><a href="#cb8-2"></a>    ~expected:(<span class="st">"g0(x)"</span>, [ <span class="st">"g0(F()) = F()"</span>; <span class="st">"g0(T()) = F()"</span> ])</span>
<span id="cb8-3"><a href="#cb8-3"></a>    (formula [ clause [ `Var <span class="st">"x"</span> ]; clause [ `Not <span class="st">"x"</span> ] ]);</span></code></pre></div><p>Since there is no path in <code>g0</code> that leads to
<code>T</code>, the formula is <strong>unsatisfiable</strong>.</p><p>Testing “x AND (y OR z) AND NOT x”:</p><div class="sourceCode" id="cb9"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1"></a>  check</span>
<span id="cb9-2"><a href="#cb9-2"></a>    ~expected:</span>
<span id="cb9-3"><a href="#cb9-3"></a>      ( <span class="st">"g0(x, y, z)"</span>,</span>
<span id="cb9-4"><a href="#cb9-4"></a>        [</span>
<span id="cb9-5"><a href="#cb9-5"></a>          <span class="st">"g0(F(), y, z) = F()"</span>;</span>
<span id="cb9-6"><a href="#cb9-6"></a>          <span class="st">"g0(T(), y, z) = g1(y, z)"</span>;</span>
<span id="cb9-7"><a href="#cb9-7"></a>          <span class="st">"g1(F(), z) = g2(z)"</span>;</span>
<span id="cb9-8"><a href="#cb9-8"></a>          <span class="st">"g1(T(), z) = F()"</span>;</span>
<span id="cb9-9"><a href="#cb9-9"></a>          <span class="st">"g2(F()) = F()"</span>;</span>
<span id="cb9-10"><a href="#cb9-10"></a>          <span class="st">"g2(T()) = F()"</span>;</span>
<span id="cb9-11"><a href="#cb9-11"></a>        ] )</span>
<span id="cb9-12"><a href="#cb9-12"></a>    (formula</span>
<span id="cb9-13"><a href="#cb9-13"></a>       [</span>
<span id="cb9-14"><a href="#cb9-14"></a>         clause [ `Var <span class="st">"x"</span> ]; clause [ `Var <span class="st">"y"</span>; `Var <span class="st">"z"</span> ]; clause [ `Not <span class="st">"x"</span> ];</span>
<span id="cb9-15"><a href="#cb9-15"></a>       ]);</span></code></pre></div><p>Ditto.</p><p>Testing “(x OR x OR x) AND (NOT x OR NOT x OR NOT x)”:</p><div class="sourceCode" id="cb10"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1"></a>  check</span>
<span id="cb10-2"><a href="#cb10-2"></a>    ~expected:(<span class="st">"g0(x)"</span>, [ <span class="st">"g0(F()) = F()"</span>; <span class="st">"g0(T()) = F()"</span> ])</span>
<span id="cb10-3"><a href="#cb10-3"></a>    (formula</span>
<span id="cb10-4"><a href="#cb10-4"></a>       [</span>
<span id="cb10-5"><a href="#cb10-5"></a>         clause [ `Var <span class="st">"x"</span>; `Var <span class="st">"x"</span>; `Var <span class="st">"x"</span> ];</span>
<span id="cb10-6"><a href="#cb10-6"></a>         clause [ `Not <span class="st">"x"</span>; `Not <span class="st">"x"</span>; `Not <span class="st">"x"</span> ];</span>
<span id="cb10-7"><a href="#cb10-7"></a>       ]);</span></code></pre></div><p>Ditto.</p><p>Testing “(x OR y OR z) AND (x OR y OR NOT z) AND (x OR NOT y OR z)
AND (x OR NOT y OR NOT z) AND (NOT x OR y OR z) AND (NOT x OR y OR NOT
z) AND (NOT x OR NOT y OR z) AND (NOT x OR NOT y OR NOT z)”:</p><div class="sourceCode" id="cb11"><pre class="sourceCode numberSource ocaml numberLines"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1"></a>  check</span>
<span id="cb11-2"><a href="#cb11-2"></a>    ~expected:</span>
<span id="cb11-3"><a href="#cb11-3"></a>      ( <span class="st">"g0(x, y, z)"</span>,</span>
<span id="cb11-4"><a href="#cb11-4"></a>        [</span>
<span id="cb11-5"><a href="#cb11-5"></a>          <span class="st">"g0(F(), y, z) = g1(y, z)"</span>;</span>
<span id="cb11-6"><a href="#cb11-6"></a>          <span class="st">"g0(T(), y, z) = g4(y, z)"</span>;</span>
<span id="cb11-7"><a href="#cb11-7"></a>          <span class="st">"g1(F(), z) = g2(z)"</span>;</span>
<span id="cb11-8"><a href="#cb11-8"></a>          <span class="st">"g1(T(), z) = g3(z)"</span>;</span>
<span id="cb11-9"><a href="#cb11-9"></a>          <span class="st">"g2(F()) = F()"</span>;</span>
<span id="cb11-10"><a href="#cb11-10"></a>          <span class="st">"g2(T()) = F()"</span>;</span>
<span id="cb11-11"><a href="#cb11-11"></a>          <span class="st">"g3(F()) = F()"</span>;</span>
<span id="cb11-12"><a href="#cb11-12"></a>          <span class="st">"g3(T()) = F()"</span>;</span>
<span id="cb11-13"><a href="#cb11-13"></a>          <span class="st">"g4(F(), z) = g5(z)"</span>;</span>
<span id="cb11-14"><a href="#cb11-14"></a>          <span class="st">"g4(T(), z) = g6(z)"</span>;</span>
<span id="cb11-15"><a href="#cb11-15"></a>          <span class="st">"g5(F()) = F()"</span>;</span>
<span id="cb11-16"><a href="#cb11-16"></a>          <span class="st">"g5(T()) = F()"</span>;</span>
<span id="cb11-17"><a href="#cb11-17"></a>          <span class="st">"g6(F()) = F()"</span>;</span>
<span id="cb11-18"><a href="#cb11-18"></a>          <span class="st">"g6(T()) = F()"</span>;</span>
<span id="cb11-19"><a href="#cb11-19"></a>        ] )</span>
<span id="cb11-20"><a href="#cb11-20"></a>    (formula</span>
<span id="cb11-21"><a href="#cb11-21"></a>       [</span>
<span id="cb11-22"><a href="#cb11-22"></a>         clause [ `Var <span class="st">"x"</span>; `Var <span class="st">"y"</span>; `Var <span class="st">"z"</span> ];</span>
<span id="cb11-23"><a href="#cb11-23"></a>         clause [ `Var <span class="st">"x"</span>; `Var <span class="st">"y"</span>; `Not <span class="st">"z"</span> ];</span>
<span id="cb11-24"><a href="#cb11-24"></a>         clause [ `Var <span class="st">"x"</span>; `Not <span class="st">"y"</span>; `Var <span class="st">"z"</span> ];</span>
<span id="cb11-25"><a href="#cb11-25"></a>         clause [ `Var <span class="st">"x"</span>; `Not <span class="st">"y"</span>; `Not <span class="st">"z"</span> ];</span>
<span id="cb11-26"><a href="#cb11-26"></a>         clause [ `Not <span class="st">"x"</span>; `Var <span class="st">"y"</span>; `Var <span class="st">"z"</span> ];</span>
<span id="cb11-27"><a href="#cb11-27"></a>         clause [ `Not <span class="st">"x"</span>; `Var <span class="st">"y"</span>; `Not <span class="st">"z"</span> ];</span>
<span id="cb11-28"><a href="#cb11-28"></a>         clause [ `Not <span class="st">"x"</span>; `Not <span class="st">"y"</span>; `Var <span class="st">"z"</span> ];</span>
<span id="cb11-29"><a href="#cb11-29"></a>         clause [ `Not <span class="st">"x"</span>; `Not <span class="st">"y"</span>; `Not <span class="st">"z"</span> ];</span>
<span id="cb11-30"><a href="#cb11-30"></a>       ])</span></code></pre></div><p>Ditto.</p><a class="header-link" href="#final-words"><h2 id="final-words">Final words</h2></a><p>In this essay, I have demonstrated how supercompilation can solve any
SAT problem with only 10 lines of code in SLL.</p><p>There are several theoretical and practical consequences of this
discovery:</p><ul>
<li><strong>Theoretically,</strong> this means that a positive
supercompiler can solve SAT “automatically” – possibly mixed with a
number of other optimizations and code transformations. In other words,
it is possible that supercompilation can optimize your code based on the
knowledge of a solution to a particular SAT problem.
<ul>
<li>A direct consequence of this is that supercompiling a particular
task can have exponential time and space complexity. This is both good
and bad: the good part is that supercompilation is very smart, and the
bad part is that it can be <em>too smart</em> to serve as a predictable
code optimizer.</li>
<li>Since it is generally believed that there is <a href="https://en.wikipedia.org/wiki/P_versus_NP_problem">no
polynomial-time algorithm</a> to solve SAT, positive supercompilation is
also likely not to have it.</li>
<li>Since SAT is an <a href="https://en.wikipedia.org/wiki/NP-complete">NP-complete
problem</a>, meaning that it is at least as hard as any other problem in
NP, supercompilation is also at least as hard as any other problem in
NP. In other words, supercompilation has enough expressive power to
solve any NP problem <em>during the process</em>.</li>
</ul></li>
<li><strong>Practically,</strong> using naive supercompilation as an
optimization pass would not be a good idea. However, since
supercompilation is a general method rather than a particular algorithm,
it should always be possible to restrict the expressive power of a
<em>particular</em> supercompiler to make it more predictable – albeit
less smart. See the technique of <em>speculative supercompilation</em>
from <a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>.
<ul>
<li>The SLL solver demonstrated in the previous section can serve as a
good stress test for a practical supercompiler.</li>
</ul></li>
</ul><p>Although the idea of supercompilation dates back to the 1970’s,
developing an industrial supercompiler is still an open problem.</p><p>If you find the post interesting, please share your thoughts in the
comments.</p><a class="header-link" href="#references"><h2 id="references">References</h2></a><section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1" role="doc-endnote"><p>Valentin F. Turchin. 1986. The
concept of a supercompiler. ACM Trans. Program. Lang. Syst. 8, 3 (July
1986), 292–325. https://doi.org/10.1145/5956.5957<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>This encoding is known as <a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano
arithmetic</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Klimov, Andrei &amp; Romanenko,
Sergei. (2018). Supercompilation: main principles and basic concepts.
Keldysh Institute Preprints. 1-36. 10.20948/prepr-2018-111.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>In the following example,
<code>2</code> stands for <code>S(S(Z))</code> in Peano arithmetic.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Futamura, Y. (1983). Partial
computation of programs. In: Goto, E., Furukawa, K., Nakajima, R.,
Nakata, I., Yonezawa, A. (eds) RIMS Symposia on Software Science and
Engineering. Lecture Notes in Computer Science, vol 147. Springer,
Berlin, Heidelberg. https://doi.org/10.1007/3-540-11980-9_13<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Klimov, Andrei &amp; Romanenko,
Sergei. (2018). Supercompilation: main principles and basic concepts.
Keldysh Institute Preprints. 1-36. 10.20948/prepr-2018-111.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>Klimov, Andrei &amp; Romanenko,
Sergei. (2018). Supercompilation: main principles and basic concepts.
Keldysh Institute Preprints. 1-36. 10.20948/prepr-2018-111.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>Neil Mitchell. 2010. Rethinking
supercompilation. SIGPLAN Not. 45, 9 (September 2010), 309–320.
https://doi.org/10.1145/1932681.1863588<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>Valentin F. Turchin. 1986. The
concept of a supercompiler. ACM Trans. Program. Lang. Syst. 8, 3 (July
1986), 292–325. https://doi.org/10.1145/5956.5957<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>Romanenko, Sergei. (2018).
Supercompilation: homeomorphic embedding, call-by-name, partial
evaluation. Keldysh Institute Preprints. 1-32.
10.20948/prepr-2018-209.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>Robert Glück and Morten Heine
Sørensen. 1996. A Roadmap to Metacomputation by Supercompilation. In
Selected Papers from the International Seminar on Partial Evaluation.
Springer-Verlag, Berlin, Heidelberg, 137–160.<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>Sørensen, M.H.B. (1998). Convergence
of program transformers in the metric space of trees. In: Jeuring, J.
(eds) Mathematics of Program Construction. MPC 1998. Lecture Notes in
Computer Science, vol 1422. Springer, Berlin, Heidelberg.
https://doi.org/10.1007/BFb0054297<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>Nemytykh, A.P., Pinchuk, V.A.,
Turchin, V.F. (1996). A Self-Applicable supercompiler. In: Danvy, O.,
Glück, R., Thiemann, P. (eds) Partial Evaluation. Lecture Notes in
Computer Science, vol 1110. Springer, Berlin, Heidelberg.
https://doi.org/10.1007/3-540-61580-6_16<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p>Glück, R. (1996). On the mechanics
of metasystem hierarchies in program transformation. In: Proietti, M.
(eds) Logic Program Synthesis and Transformation. LOPSTR 1995. Lecture
Notes in Computer Science, vol 1048. Springer, Berlin, Heidelberg.
https://doi.org/10.1007/3-540-60939-3_18<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p>Glück, R., Klimov, A.V. (1993).
Occam’s razor in metacomputation: the notion of a perfect process tree.
In: Cousot, P., Falaschi, M., Filé, G., Rauzy, A. (eds) Static Analysis.
WSA 1993. Lecture Notes in Computer Science, vol 724. Springer, Berlin,
Heidelberg. https://doi.org/10.1007/3-540-57264-3_34<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16" role="doc-endnote"><p>Note that this encoding results in
exponential blowup in code size because the first rule propagates
<code>...</code> to both branches.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17" role="doc-endnote"><p>This is not actually a process tree
because <code>x</code> must be the first argument in a syntactically
correct SLL expression. So in reality, the process tree would have three
branches: one for <code>x</code>, the other two for <code>x=T</code> and
<code>x=F</code>.<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18" role="doc-endnote"><p>Of course, a residual task is not
“officially” an answer to a decision problem (yes/no), but the answer
can be mechanically extracted from it.<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19" role="doc-endnote"><p>Jonsson, P. A. (2011). Time- and
size-efficient supercompilation (PhD dissertation, Luleå tekniska
universitet). Retrieved from
https://urn.kb.se/resolve?urn=urn:nbn:se:ltu:diva-26651<a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><script src="https://giscus.app/client.js" data-repo="hirrolot/hirrolot.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzMTQ4MzI2NDA=" data-category="Announcements" data-category-id="DIC_kwDOEsP3AM4CSEqw" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="https://hirrolot.github.io/giscus-theme.css" data-lang="en" data-loading="lazy" crossorigin="anonymous" async="">
</script></div></body></html>