<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang=""><head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="hirrolot">
  <title>Rust Is Hard, Or: The Misery of Mainstream Programming</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
  <link href="https://necolas.github.io/normalize.css/8.0.1/normalize.css" rel="stylesheet">

  <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Caveat&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Luxurious+Roman&amp;display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Alex+Brush&amp;display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="../myself.png" type="image/x-icon">
  <script src="../script.js"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<a class="header-link" href="#"><h1 class="title">Rust Is Hard, Or: The Misery of Mainstream
Programming</h1></a>
<p class="author">hirrolot</p>
<p class="date">Jun 2, 2022</p>
</header>
<div class="introduction">
<p class="discussions">
<a href="https://news.ycombinator.com/item?id=31601040">HN</a> · <a href="https://www.reddit.com/r/rust/comments/v3cktw/rust_is_hard_or_the_misery_of_mainstream/">r/rust</a>
· <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/v3clru/rust_is_hard_or_the_misery_of_mainstream/">r/ProgrammingLanguages</a>
</p>
<p><img src="../media/content/rust-is-hard-or-the-misery-of-mainstream-programming/rustaceans-meme.jpeg"></p>
<p>When you use Rust, it is sometimes outright preposterous how much
knowledge of language, and how much of programming ingenuity and
curiosity you need in order to accomplish the most trivial things. When
you feel particularly desperate, you go to <a href="https://github.com/rust-lang/rust/issues">rust/issues</a> and
search for a solution for your problem. Suddenly, you find an issue with
an explanation that it is theoretically impossible to design your API in
this way, owing to some subtle language bug. The issue is <span style="background-color: rgb(35, 134, 54); color: white; display: inline-block; padding: 5px 12px; border-radius: 28px; font-size: 16px; font-family: sans-serif;"><svg style="vertical-align: middle; margin-bottom: 3px;" height="16" class="octicon octicon-issue-opened" viewBox="0 0 16 16" version="1.1" width="16" aria-hidden="true"><path fill="#FFFFFF" d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill="#FFFFFF" fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg>
Open</span> and dated Apr 5, 2017.</p>
<p>I entered Rust four years ago. To this moment, I co-authored <a href="https://github.com/teloxide/teloxide">teloxide</a> and <a href="https://github.com/teloxide/dptree">dptree</a>, wrote several
publications and translated a number of language release announcements.
I also managed to write some production code in Rust, and had a chance
to speak at one online meetup dedicated to Rust. Still, from time to
time I find myself disputing with borrow checker and type system for no
practical reason. Yes, I am no longer stupefied by such errors as
<code>cannot return reference to temporary value</code> – over time, I
developed multiple heuristic strategies to cope with lifetimes…</p>
<p>But one recent situation has made me to <em>fail
ignominiously</em>.</p>
</div><nav id="TOC" role="doc-toc" style="display: block;"><h4 class="toc-title">Table of Contents</h4>
<ul>
<li><a href="#functions-that-handle-updates-first-try">Functions that
handle updates: First try</a></li>
<li><a href="#second-try-heterogenous-list">Second try: Heterogenous
list</a></li>
<li><a href="#third-try-using-arc">Third try: Using Arc</a></li>
<li><a href="#the-problem-with-rust">The problem with Rust</a></li>
<li><a href="#why-rust-is-so-hard">Why Rust is so hard?</a></li>
<li><a href="#how-things-can-be-different">How things can be
different?</a></li>
<li><a href="#waiting-for-better-future">Waiting for better
future</a></li>
<li><a href="#related-ideas">Related ideas</a></li>
<li><a href="#update-addressing-misinterpretations">Update: Addressing
misinterpretations</a></li>
</ul>
</nav>





























































































<div class="post-body"><a class="header-link" href="#functions-that-handle-updates-first-try"><h2 id="functions-that-handle-updates-first-try">Functions that handle
updates: First try</h2></a><p>We are programming a <del>blazing fast</del> messenger bot to make
people’s lives easier. Using long polling or webhooks, we obtain a
stream of server updates, one-by-one. For all updates, we have a vector
of handlers, each of which accepts a reference to an update and returns
a future resolving to <code>()</code>. <code>Dispatcher</code> owns the
handler vector and on each incoming update, it executes the handlers
sequentially.</p><p>Let us try to implement this. We will omit the execution of handlers
and focus only on the <code>push_handler</code> function. First try (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=77fa41ad76bd47211ba3778a7c41d3ae">playground</a>):</p><div class="sourceCode" id="cb1"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">use</span> <span class="pp">futures::future::</span>BoxFuture<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">use</span> <span class="pp">std::future::</span><span class="bu">Future</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">struct</span> Update<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">type</span> Handler <span class="op">=</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="cf">for</span><span class="op">&lt;</span><span class="ot">'a</span><span class="op">&gt;</span> <span class="bu">Fn</span>(<span class="op">&amp;</span><span class="ot">'a</span> Update) <span class="op">-&gt;</span> BoxFuture<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> ()<span class="op">&gt;</span> <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span><span class="op">&gt;;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">struct</span> Dispatcher(<span class="dt">Vec</span><span class="op">&lt;</span>Handler<span class="op">&gt;</span>)<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">impl</span> Dispatcher <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="kw">fn</span> push_handler<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> H<span class="op">,</span> Fut<span class="op">&gt;</span>(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> handler<span class="op">:</span> H)</span>
<span id="cb1-13"><a href="#cb1-13"></a>    <span class="kw">where</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>        H<span class="op">:</span> <span class="bu">Fn</span>(<span class="op">&amp;</span><span class="ot">'a</span> Update) <span class="op">-&gt;</span> Fut <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span> <span class="op">+</span> <span class="ot">'a</span><span class="op">,</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>        Fut<span class="op">:</span> <span class="bu">Future</span><span class="op">&lt;</span>Output <span class="op">=</span> ()<span class="op">&gt;</span> <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="ot">'a</span><span class="op">,</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>    <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>        <span class="kw">self</span><span class="op">.</span><span class="dv">0</span><span class="op">.</span>push(<span class="dt">Box</span><span class="pp">::</span>new(<span class="kw">move</span> <span class="op">|</span>upd<span class="op">|</span> <span class="dt">Box</span><span class="pp">::</span>pin(handler(upd))))<span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>    <span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="op">}</span></span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="kw">let</span> <span class="kw">mut</span> dp <span class="op">=</span> Dispatcher(<span class="pp">vec!</span>[])<span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a>    dp<span class="op">.</span>push_handler(<span class="op">|</span>upd<span class="op">|</span> <span class="kw">async</span> <span class="kw">move</span> <span class="op">{</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>        <span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span> upd)<span class="op">;</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27"></a><span class="op">}</span></span></code></pre></div><p>Here we represent each handler using a dynamically typed
<code>Fn</code> restricted by an <a href="https://doc.rust-lang.org/nomicon/hrtb.html">HRTB lifetime</a>
<code>for&lt;'a&gt;</code>, since we want a returning future to depend
on some <code>'a</code> from the <code>&amp;'a Update</code> function
parameter. Later, we define the <code>Dispatcher</code> type holding
<code>Vec&lt;Handler&gt;</code>. Inside <code>push_handler</code>, we
accept a statically typed, generic <code>H</code> returning
<code>Fut</code>; in order to push a value of this type to
<code>self.0</code>, we need to wrap <code>handler</code> into a new
boxed handler and transform the returning future to <a href="https://docs.rs/futures/latest/futures/future/type.BoxFuture.html"><code>BoxFuture</code></a>
from the <code>futures</code> crate using <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.pin"><code>Box::pin</code></a>.
Now let us see if the above solution works:</p><div class="sourceCode" id="cb2"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb2-1"><a href="#cb2-1"></a>error[E0312]: lifetime of reference outlives lifetime of borrowed content...</span>
<span id="cb2-2"><a href="#cb2-2"></a>  --&gt; src/main.rs:17:58</span>
<span id="cb2-3"><a href="#cb2-3"></a>   |</span>
<span id="cb2-4"><a href="#cb2-4"></a>17 |         self.0.push(Box::new(move |upd| Box::pin(handler(upd))));</span>
<span id="cb2-5"><a href="#cb2-5"></a>   |                                                          ^^^</span>
<span id="cb2-6"><a href="#cb2-6"></a>   |</span>
<span id="cb2-7"><a href="#cb2-7"></a>note: ...the reference is valid for the lifetime `'a` as defined here...</span>
<span id="cb2-8"><a href="#cb2-8"></a>  --&gt; src/main.rs:12:21</span>
<span id="cb2-9"><a href="#cb2-9"></a>   |</span>
<span id="cb2-10"><a href="#cb2-10"></a>12 |     fn push_handler&lt;'a, H, Fut&gt;(&amp;mut self, handler: H)</span>
<span id="cb2-11"><a href="#cb2-11"></a>   |                     ^^</span>
<span id="cb2-12"><a href="#cb2-12"></a>note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined here</span>
<span id="cb2-13"><a href="#cb2-13"></a>  --&gt; src/main.rs:17:30</span>
<span id="cb2-14"><a href="#cb2-14"></a>   |</span>
<span id="cb2-15"><a href="#cb2-15"></a>17 |         self.0.push(Box::new(move |upd| Box::pin(handler(upd))));</span>
<span id="cb2-16"><a href="#cb2-16"></a>   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></code></pre></div><p>Unfortunately, it does not work.</p><p>The reason is that <code>push_handler</code> accepts a
<em>concrete</em> lifetime <code>'a</code> that we try to boil down to
an HRTB lifetime <code>for&lt;'a&gt;</code>. By doing so, we try to
prove that <code>for&lt;'a, 'b&gt; 'a: 'b</code> (with <code>'b</code>
being <code>'a</code> from <code>push_handler</code>), which obviously
does not hold.</p><p>We can try to approach this differently: instead of the
<code>Fut</code> generic, we can force a user handler to return
<code>BoxFuture</code> bounded by <code>for&lt;'a&gt;</code> (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=241de07a19e739112d57cd8ef8442db2">playground</a>):</p><div class="sourceCode" id="cb3"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">use</span> <span class="pp">futures::future::</span>BoxFuture<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">struct</span> Update<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="kw">type</span> Handler <span class="op">=</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="cf">for</span><span class="op">&lt;</span><span class="ot">'a</span><span class="op">&gt;</span> <span class="bu">Fn</span>(<span class="op">&amp;</span><span class="ot">'a</span> Update) <span class="op">-&gt;</span> BoxFuture<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> ()<span class="op">&gt;</span> <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span><span class="op">&gt;;</span></span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="kw">struct</span> Dispatcher(<span class="dt">Vec</span><span class="op">&lt;</span>Handler<span class="op">&gt;</span>)<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="kw">impl</span> Dispatcher <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="kw">fn</span> push_handler<span class="op">&lt;</span>H<span class="op">&gt;</span>(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> handler<span class="op">:</span> H)</span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="kw">where</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>        H<span class="op">:</span> <span class="cf">for</span><span class="op">&lt;</span><span class="ot">'a</span><span class="op">&gt;</span> <span class="bu">Fn</span>(<span class="op">&amp;</span><span class="ot">'a</span> Update) <span class="op">-&gt;</span> BoxFuture<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> ()<span class="op">&gt;</span> <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span> <span class="op">+</span> <span class="ot">'static</span><span class="op">,</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>    <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>        <span class="kw">self</span><span class="op">.</span><span class="dv">0</span><span class="op">.</span>push(<span class="dt">Box</span><span class="pp">::</span>new(<span class="kw">move</span> <span class="op">|</span>upd<span class="op">|</span> <span class="dt">Box</span><span class="pp">::</span>pin(handler(upd))))<span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>    <span class="op">}</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="op">}</span></span>
<span id="cb3-18"><a href="#cb3-18"></a></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20"></a>    <span class="kw">let</span> <span class="kw">mut</span> dp <span class="op">=</span> Dispatcher(<span class="pp">vec!</span>[])<span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21"></a></span>
<span id="cb3-22"><a href="#cb3-22"></a>    dp<span class="op">.</span>push_handler(<span class="op">|</span>upd<span class="op">|</span> <span class="op">{</span></span>
<span id="cb3-23"><a href="#cb3-23"></a>        <span class="dt">Box</span><span class="pp">::</span>pin(<span class="kw">async</span> <span class="kw">move</span> <span class="op">{</span></span>
<span id="cb3-24"><a href="#cb3-24"></a>            <span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span> upd)<span class="op">;</span></span>
<span id="cb3-25"><a href="#cb3-25"></a>        <span class="op">}</span>)</span>
<span id="cb3-26"><a href="#cb3-26"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb3-27"><a href="#cb3-27"></a><span class="op">}</span></span></code></pre></div><p>It compiles fine now but the final API is defected: ideally, we do
not want a user to wrap each handler with <code>Box::pin</code>. After
all, this is one of the reasons why <code>push_handler</code> exists: it
transforms a statically typed handler into its functionally equivalent
counterpart in the dynamic type space. But what if we force handlers to
remain static?</p><p>We can accomplish it using heterogenous lists.</p><a class="header-link" href="#second-try-heterogenous-list"><h2 id="second-try-heterogenous-list">Second try: Heterogenous list</h2></a><p>A heterogenous list is indeed just a fancy name for a tuple. Thus, we
want something like <code>(H1, H2, H3, ...)</code>, where each
<code>H</code> is a different handler type. But at the same time, the
<code>push_handler</code> and <code>execute</code> operations require us
to be able to iterate on this tuple – a possibility that is missing in
vanilla Rust. It does not mean, though, that we cannot express a similar
thing via some freaky type machinery!</p><p>First of all, this is the representation of our heterogenous list (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d311df0efb8136c64b19c9f783e65cd1">playground</a>):</p><div class="sourceCode" id="cb4"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">struct</span> Dispatcher<span class="op">&lt;</span>H<span class="op">,</span> Tail<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>    handler<span class="op">:</span> H<span class="op">,</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    tail<span class="op">:</span> Tail<span class="op">,</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="op">}</span></span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="kw">struct</span> DispatcherEnd<span class="op">;</span></span></code></pre></div><p>If you think this is a bit senseless, you are not far from true. All
we want is to be able to construct types like
<code>Dispatcher&lt;H1, Dispatcher&lt;H2, Dispatcher&lt;H3, DispatcherEnd&gt;&gt;&gt;</code>,
an equivalent form of the <code>(H1, H2, H3)</code> tuple. With this in
mind, we can now define the <code>push_handler</code> function using
simple type-level induction:</p><div class="sourceCode" id="cb5"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">trait</span> PushHandler<span class="op">&lt;</span>NewH<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="kw">type</span> Out<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="kw">fn</span> push_handler(<span class="kw">self</span><span class="op">,</span> handler<span class="op">:</span> NewH) <span class="op">-&gt;</span> <span class="dt">Self</span><span class="pp">::</span>Out<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="op">}</span></span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="kw">impl</span><span class="op">&lt;</span>NewH<span class="op">&gt;</span> PushHandler<span class="op">&lt;</span>NewH<span class="op">&gt;</span> <span class="cf">for</span> DispatcherEnd <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="kw">type</span> Out <span class="op">=</span> Dispatcher<span class="op">&lt;</span>NewH<span class="op">,</span> DispatcherEnd<span class="op">&gt;;</span></span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="kw">fn</span> push_handler(<span class="kw">self</span><span class="op">,</span> handler<span class="op">:</span> NewH) <span class="op">-&gt;</span> <span class="dt">Self</span><span class="pp">::</span>Out <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>        Dispatcher <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>            handler<span class="op">,</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>            tail<span class="op">:</span> DispatcherEnd<span class="op">,</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>        <span class="op">}</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>    <span class="op">}</span></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="op">}</span></span>
<span id="cb5-16"><a href="#cb5-16"></a></span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="kw">impl</span><span class="op">&lt;</span>H<span class="op">,</span> Tail<span class="op">,</span> NewH<span class="op">&gt;</span> PushHandler<span class="op">&lt;</span>NewH<span class="op">&gt;</span> <span class="cf">for</span> Dispatcher<span class="op">&lt;</span>H<span class="op">,</span> Tail<span class="op">&gt;</span></span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="kw">where</span></span>
<span id="cb5-19"><a href="#cb5-19"></a>    Tail<span class="op">:</span> PushHandler<span class="op">&lt;</span>NewH<span class="op">&gt;,</span></span>
<span id="cb5-20"><a href="#cb5-20"></a><span class="op">{</span></span>
<span id="cb5-21"><a href="#cb5-21"></a>    <span class="kw">type</span> Out <span class="op">=</span> Dispatcher<span class="op">&lt;</span>H<span class="op">,</span> <span class="op">&lt;</span>Tail <span class="kw">as</span> PushHandler<span class="op">&lt;</span>NewH<span class="op">&gt;&gt;</span><span class="pp">::</span>Out<span class="op">&gt;;</span></span>
<span id="cb5-22"><a href="#cb5-22"></a></span>
<span id="cb5-23"><a href="#cb5-23"></a>    <span class="kw">fn</span> push_handler(<span class="kw">self</span><span class="op">,</span> handler<span class="op">:</span> NewH) <span class="op">-&gt;</span> <span class="dt">Self</span><span class="pp">::</span>Out <span class="op">{</span></span>
<span id="cb5-24"><a href="#cb5-24"></a>        Dispatcher <span class="op">{</span></span>
<span id="cb5-25"><a href="#cb5-25"></a>            handler<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>handler<span class="op">,</span></span>
<span id="cb5-26"><a href="#cb5-26"></a>            tail<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>tail<span class="op">.</span>push_handler(handler)<span class="op">,</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>        <span class="op">}</span></span>
<span id="cb5-28"><a href="#cb5-28"></a>    <span class="op">}</span></span>
<span id="cb5-29"><a href="#cb5-29"></a><span class="op">}</span></span></code></pre></div><p>If you are new to type-level induction, you can think of it as of
regular recursion, but applied to types (traits) instead of values:</p><ul>
<li>The <strong>base case</strong> is
<code>impl&lt;NewH&gt; PushHandler&lt;NewH&gt; for DispatcherEnd</code>.
Here we construct a dispatcher with only one handler.</li>
<li>The <strong>step case</strong> is
<code>impl&lt;H, Tail, NewH&gt; PushHandler&lt;NewH&gt; for Dispatcher&lt;H, Tail&gt;</code>.
Here we only propagate our induction to <code>self.tail</code>.</li>
</ul><p>We implement <code>execute</code> in the same way:</p><div class="sourceCode" id="cb6"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">trait</span> Execute<span class="op">&lt;</span><span class="ot">'a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="at">#[</span>must_use<span class="at">]</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="kw">fn</span> execute(<span class="op">&amp;</span><span class="ot">'a</span> <span class="kw">self</span><span class="op">,</span> upd<span class="op">:</span> <span class="op">&amp;</span><span class="ot">'a</span> Update) <span class="op">-&gt;</span> BoxFuture<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> ()<span class="op">&gt;;</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="op">}</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">'a</span><span class="op">&gt;</span> Execute<span class="op">&lt;</span><span class="ot">'a</span><span class="op">&gt;</span> <span class="cf">for</span> DispatcherEnd <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>    <span class="kw">fn</span> execute(<span class="op">&amp;</span><span class="ot">'a</span> <span class="kw">self</span><span class="op">,</span> _upd<span class="op">:</span> <span class="op">&amp;</span><span class="ot">'a</span> Update) <span class="op">-&gt;</span> BoxFuture<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> ()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>        <span class="dt">Box</span><span class="pp">::</span>pin(<span class="kw">async</span> <span class="op">{}</span>)</span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="op">}</span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="op">}</span></span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> H<span class="op">,</span> Fut<span class="op">,</span> Tail<span class="op">&gt;</span> Execute<span class="op">&lt;</span><span class="ot">'a</span><span class="op">&gt;</span> <span class="cf">for</span> Dispatcher<span class="op">&lt;</span>H<span class="op">,</span> Tail<span class="op">&gt;</span></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="kw">where</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>    H<span class="op">:</span> <span class="bu">Fn</span>(<span class="op">&amp;</span><span class="ot">'a</span> Update) <span class="op">-&gt;</span> Fut <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span> <span class="op">+</span> <span class="ot">'a</span><span class="op">,</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>    Fut<span class="op">:</span> <span class="bu">Future</span><span class="op">&lt;</span>Output <span class="op">=</span> ()<span class="op">&gt;</span> <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="ot">'a</span><span class="op">,</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>    Tail<span class="op">:</span> Execute<span class="op">&lt;</span><span class="ot">'a</span><span class="op">&gt;</span> <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span> <span class="op">+</span> <span class="ot">'a</span><span class="op">,</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="op">{</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>    <span class="kw">fn</span> execute(<span class="op">&amp;</span><span class="ot">'a</span> <span class="kw">self</span><span class="op">,</span> upd<span class="op">:</span> <span class="op">&amp;</span><span class="ot">'a</span> Update) <span class="op">-&gt;</span> BoxFuture<span class="op">&lt;</span><span class="ot">'a</span><span class="op">,</span> ()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>        <span class="dt">Box</span><span class="pp">::</span>pin(<span class="kw">async</span> <span class="kw">move</span> <span class="op">{</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>            (<span class="kw">self</span><span class="op">.</span>handler)(upd)<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>            <span class="kw">self</span><span class="op">.</span>tail<span class="op">.</span>execute(upd)<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb6-22"><a href="#cb6-22"></a>        <span class="op">}</span>)</span>
<span id="cb6-23"><a href="#cb6-23"></a>    <span class="op">}</span></span>
<span id="cb6-24"><a href="#cb6-24"></a><span class="op">}</span></span></code></pre></div><p>But that is not all we need. The final move is to abstract
<code>execute</code> <em>for all</em> lifetimes of updates, since our
implementation of <code>Execute&lt;'a&gt;</code> relies on some concrete
<code>'a</code>, whereas we want our dispatcher to handle updates of
variying lifetimes:</p><div class="sourceCode" id="cb7"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">async</span> <span class="kw">fn</span> execute<span class="op">&lt;</span>Dp<span class="op">&gt;</span>(dp<span class="op">:</span> Dp<span class="op">,</span> upd<span class="op">:</span> Update)</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">where</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    Dp<span class="op">:</span> <span class="cf">for</span><span class="op">&lt;</span><span class="ot">'a</span><span class="op">&gt;</span> Execute<span class="op">&lt;</span><span class="ot">'a</span><span class="op">&gt;,</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    dp<span class="op">.</span>execute(<span class="op">&amp;</span>upd)<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="op">}</span></span></code></pre></div><p>Fine, now we are ready to test our bizzare solution:</p><div class="sourceCode" id="cb8"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1"></a><span class="at">#[</span><span class="pp">tokio::</span>main<span class="at">]</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">async</span> <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="kw">let</span> dp <span class="op">=</span> DispatcherEnd<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="kw">let</span> dp <span class="op">=</span> dp<span class="op">.</span>push_handler(<span class="op">|</span>upd<span class="op">|</span> <span class="kw">async</span> <span class="kw">move</span> <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>        <span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span> upd)<span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>    execute(dp<span class="op">,</span> Update)<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="op">}</span></span></code></pre></div><p>But it does not work either:</p><div class="sourceCode" id="cb9"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb9-1"><a href="#cb9-1"></a>error: implementation of `Execute` is not general enough</span>
<span id="cb9-2"><a href="#cb9-2"></a>  --&gt; src/main.rs:83:5</span>
<span id="cb9-3"><a href="#cb9-3"></a>   |</span>
<span id="cb9-4"><a href="#cb9-4"></a>83 |     execute(dp, Update).await;</span>
<span id="cb9-5"><a href="#cb9-5"></a>   |     ^^^^^^^ implementation of `Execute` is not general enough</span>
<span id="cb9-6"><a href="#cb9-6"></a>   |</span>
<span id="cb9-7"><a href="#cb9-7"></a>   = note: `Dispatcher&lt;[closure@src/main.rs:80:30: 82:6], DispatcherEnd&gt;` must implement `Execute&lt;'0&gt;`, for any lifetime `'0`...</span>
<span id="cb9-8"><a href="#cb9-8"></a>   = note: ...but it actually implements `Execute&lt;'1&gt;`, for some specific lifetime `'1`</span></code></pre></div><p>Still think that programming with borrow checker is easy and
everybody can do it after some practice? Unfortunately, no matter how
much practice you have, you cannot cause the above code to compile. The
reason is this: the closure passed to <code>dp.push_handler</code>
accepts <code>upd</code> of a <em>concrete</em> lifetime
<code>'1</code>, but <code>execute</code> requires <code>Dp</code> to
implement <code>Execute&lt;'0&gt;</code> for <em>any</em> lifetime
<code>'0</code>, due to the HRTB bound introduced in the
<code>where</code> clause. However, if you try your luck with regular
functions, the code will compile:</p><div class="sourceCode" id="cb10"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1"></a><span class="at">#[</span><span class="pp">tokio::</span>main<span class="at">]</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw">async</span> <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="kw">let</span> dp <span class="op">=</span> DispatcherEnd<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="kw">async</span> <span class="kw">fn</span> dbg_update(upd<span class="op">:</span> <span class="op">&amp;</span>Update) <span class="op">{</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>        <span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span> upd)<span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="op">}</span></span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="kw">let</span> dp <span class="op">=</span> dp<span class="op">.</span>push_handler(dbg_update)<span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10"></a>    execute(dp<span class="op">,</span> Update)<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="op">}</span></span></code></pre></div><p>This will print <code>Update</code> to the standard output.</p><p>This particular behaviour of borrow checker may seem irrational –
and, in fact, it is; functions and closures differ not only in their
respective traits but also in how they handle lifetimes. While closures
that accept references are bounded by <em>specific</em> lifetimes,
functions such as our <code>dbg_update</code> accept
<code>&amp;'a Update</code> for <em>all</em> lifetimes <code>'a</code>.
This divergence is demonstrated by the following example code (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3ba11772d068d17b428029075308f405">playground</a>):</p><div class="sourceCode" id="cb11"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">let</span> dbg_update <span class="op">=</span> <span class="op">|</span>upd<span class="op">|</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span> upd)<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="op">};</span></span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="kw">let</span> upd <span class="op">=</span> Update<span class="op">;</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>    dbg_update(<span class="op">&amp;</span>upd)<span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="op">}</span></span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="op">{</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="kw">let</span> upd <span class="op">=</span> Update<span class="op">;</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>    dbg_update(<span class="op">&amp;</span>upd)<span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="op">}</span></span></code></pre></div><p>Due to calls to <code>dbg_update</code>, we obtain the following
compilation error:</p><div class="sourceCode" id="cb12"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb12-1"><a href="#cb12-1"></a>error[E0597]: `upd` does not live long enough</span>
<span id="cb12-2"><a href="#cb12-2"></a>  --&gt; src/main.rs:11:20</span>
<span id="cb12-3"><a href="#cb12-3"></a>   |</span>
<span id="cb12-4"><a href="#cb12-4"></a>11 |         dbg_update(&amp;upd);</span>
<span id="cb12-5"><a href="#cb12-5"></a>   |                    ^^^^ borrowed value does not live long enough</span>
<span id="cb12-6"><a href="#cb12-6"></a>12 |     }</span>
<span id="cb12-7"><a href="#cb12-7"></a>   |     - `upd` dropped here while still borrowed</span>
<span id="cb12-8"><a href="#cb12-8"></a>...</span>
<span id="cb12-9"><a href="#cb12-9"></a>16 |         dbg_update(&amp;upd);</span>
<span id="cb12-10"><a href="#cb12-10"></a>   |         ---------- borrow later used here</span></code></pre></div><p>This is because the <code>dbg_update</code> closure can handly only
one specific lifetime, whereas the lifetimes of the first and the second
<code>upd</code> are clearly different.</p><p>In contrast, <code>dbg_update</code> as a function works perfectly in
this scenario (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6b71d1fde5b00dd361c1e30eab6ea57c">playground</a>):</p><div class="sourceCode" id="cb13"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">fn</span> dbg_update_fn(upd<span class="op">:</span> <span class="op">&amp;</span>Update) <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span> upd)<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="op">}</span></span>
<span id="cb13-4"><a href="#cb13-4"></a></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>    <span class="kw">let</span> upd <span class="op">=</span> Update<span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>    dbg_update_fn(<span class="op">&amp;</span>upd)<span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="op">}</span></span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="op">{</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="kw">let</span> upd <span class="op">=</span> Update<span class="op">;</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>    dbg_update_fn(<span class="op">&amp;</span>upd)<span class="op">;</span></span>
<span id="cb13-13"><a href="#cb13-13"></a><span class="op">}</span></span></code></pre></div><p>We can even trace the exact signature of this function using the
handy <code>let () = ...;</code> idiom (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=0901c5082bec20168439fdea93cae938">playground</a>):</p><div class="sourceCode" id="cb14"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">fn</span> dbg_update_fn(upd<span class="op">:</span> <span class="op">&amp;</span>Update) <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>    <span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span> upd)<span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="op">}</span></span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="kw">let</span> () <span class="op">=</span> dbg_update_fn<span class="op">;</span></span></code></pre></div><p>The signature is <code>for&lt;'r&gt; fn(&amp;'r Update)</code>, as
expected:</p><div class="sourceCode" id="cb15"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb15-1"><a href="#cb15-1"></a>error[E0308]: mismatched types</span>
<span id="cb15-2"><a href="#cb15-2"></a> --&gt; src/main.rs:9:9</span>
<span id="cb15-3"><a href="#cb15-3"></a>  |</span>
<span id="cb15-4"><a href="#cb15-4"></a>9 |     let () = dbg_update_fn;</span>
<span id="cb15-5"><a href="#cb15-5"></a>  |         ^^   ------------- this expression has type `for&lt;'r&gt; fn(&amp;'r Update) {dbg_update_fn}`</span>
<span id="cb15-6"><a href="#cb15-6"></a>  |         |</span>
<span id="cb15-7"><a href="#cb15-7"></a>  |         expected fn item, found `()`</span>
<span id="cb15-8"><a href="#cb15-8"></a>  |</span>
<span id="cb15-9"><a href="#cb15-9"></a>  = note: expected fn item `for&lt;'r&gt; fn(&amp;'r Update) {dbg_update_fn}`</span>
<span id="cb15-10"><a href="#cb15-10"></a>           found unit type `()`</span></code></pre></div><p>That being said, this solution with a heterogenous list is not what
we want either: it is quite flummoxing, boilerplate, hacky, and does not
work with closures at all. Also, I do not recommend going too far with
complex type mechanics in Rust; if you suddenly encounter a type check
failure somewhere near the dispatcher type, I wish you good luck.
Imagine that you are maintaining a production system written in Rust and
you need to fix some critical bug as quickly as possible. You introduce
the necessary changes to your codebase and then see the following
compilation output:</p><div class="sourceCode" id="cb16"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb16-1"><a href="#cb16-1"></a>error[E0308]: mismatched types</span>
<span id="cb16-2"><a href="#cb16-2"></a>   --&gt; src/main.rs:123:9</span>
<span id="cb16-3"><a href="#cb16-3"></a>    |</span>
<span id="cb16-4"><a href="#cb16-4"></a>123 |     let () = dp;</span>
<span id="cb16-5"><a href="#cb16-5"></a>    |         ^^   -- this expression has type `Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update0}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update1}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update2}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update3}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update4}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update5}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update6}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update7}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update8}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update9}, DispatcherEnd&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;`</span>
<span id="cb16-6"><a href="#cb16-6"></a>    |         |</span>
<span id="cb16-7"><a href="#cb16-7"></a>    |         expected struct `Dispatcher`, found `()`</span>
<span id="cb16-8"><a href="#cb16-8"></a>    |</span>
<span id="cb16-9"><a href="#cb16-9"></a>    = note: expected struct `Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update0}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update1}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update2}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update3}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update4}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update5}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update6}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update7}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update8}, Dispatcher&lt;for&lt;'_&gt; fn(&amp;Update) -&gt; impl futures::Future&lt;Output = ()&gt; {dbg_update9}, DispatcherEnd&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;`</span>
<span id="cb16-10"><a href="#cb16-10"></a>            found unit type `()`</span></code></pre></div><p>(In a real-world scenario, the above error would probably be <a href="../media/content/rust-is-hard-or-the-misery-of-mainstream-programming/teloxide-error.txt">20x
bigger</a>.)</p><a class="header-link" href="#third-try-using-arc"><h2 id="third-try-using-arc">Third try: Using Arc</h2></a><p><img src="../media/content/rust-is-hard-or-the-misery-of-mainstream-programming/arc-meme.jpeg" width="580px"></p><p>When I was novice in Rust, I used to think that references are
simpler than smart pointers. Now I am using
<code>Rc</code>/<code>Arc</code> almost everywhere where using lifetimes
causes too much pain and performance is not a big deal. Believe or not,
all of the aforementioned problems were caused by that single lifetime
in <code>type Handler</code>, <code>'a</code>.</p><p>Let us just replace it with <code>Arc&lt;Update&gt;</code> (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=f2aed7fb232e9fac8743d4986820f3d3">playground</a>):</p><div class="sourceCode" id="cb17"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">use</span> <span class="pp">futures::future::</span>BoxFuture<span class="op">;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">use</span> <span class="pp">std::future::</span><span class="bu">Future</span><span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="kw">use</span> <span class="pp">std::sync::</span>Arc<span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="kw">struct</span> Update<span class="op">;</span></span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="kw">type</span> Handler <span class="op">=</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="bu">Fn</span>(Arc<span class="op">&lt;</span>Update<span class="op">&gt;</span>) <span class="op">-&gt;</span> BoxFuture<span class="op">&lt;</span><span class="ot">'static</span><span class="op">,</span> ()<span class="op">&gt;</span> <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span><span class="op">&gt;;</span></span>
<span id="cb17-9"><a href="#cb17-9"></a></span>
<span id="cb17-10"><a href="#cb17-10"></a><span class="kw">struct</span> Dispatcher(<span class="dt">Vec</span><span class="op">&lt;</span>Handler<span class="op">&gt;</span>)<span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11"></a></span>
<span id="cb17-12"><a href="#cb17-12"></a><span class="kw">impl</span> Dispatcher <span class="op">{</span></span>
<span id="cb17-13"><a href="#cb17-13"></a>    <span class="kw">fn</span> push_handler<span class="op">&lt;</span>H<span class="op">,</span> Fut<span class="op">&gt;</span>(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> handler<span class="op">:</span> H)</span>
<span id="cb17-14"><a href="#cb17-14"></a>    <span class="kw">where</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>        H<span class="op">:</span> <span class="bu">Fn</span>(Arc<span class="op">&lt;</span>Update<span class="op">&gt;</span>) <span class="op">-&gt;</span> Fut <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="bu">Sync</span> <span class="op">+</span> <span class="ot">'static</span><span class="op">,</span></span>
<span id="cb17-16"><a href="#cb17-16"></a>        Fut<span class="op">:</span> <span class="bu">Future</span><span class="op">&lt;</span>Output <span class="op">=</span> ()<span class="op">&gt;</span> <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="ot">'static</span><span class="op">,</span></span>
<span id="cb17-17"><a href="#cb17-17"></a>    <span class="op">{</span></span>
<span id="cb17-18"><a href="#cb17-18"></a>        <span class="kw">self</span><span class="op">.</span><span class="dv">0</span><span class="op">.</span>push(<span class="dt">Box</span><span class="pp">::</span>new(<span class="kw">move</span> <span class="op">|</span>upd<span class="op">|</span> <span class="dt">Box</span><span class="pp">::</span>pin(handler(upd))))<span class="op">;</span></span>
<span id="cb17-19"><a href="#cb17-19"></a>    <span class="op">}</span></span>
<span id="cb17-20"><a href="#cb17-20"></a><span class="op">}</span></span>
<span id="cb17-21"><a href="#cb17-21"></a></span>
<span id="cb17-22"><a href="#cb17-22"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb17-23"><a href="#cb17-23"></a>    <span class="kw">let</span> <span class="kw">mut</span> dp <span class="op">=</span> Dispatcher(<span class="pp">vec!</span>[])<span class="op">;</span></span>
<span id="cb17-24"><a href="#cb17-24"></a></span>
<span id="cb17-25"><a href="#cb17-25"></a>    dp<span class="op">.</span>push_handler(<span class="op">|</span>upd<span class="op">|</span> <span class="kw">async</span> <span class="kw">move</span> <span class="op">{</span></span>
<span id="cb17-26"><a href="#cb17-26"></a>        <span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span> upd)<span class="op">;</span></span>
<span id="cb17-27"><a href="#cb17-27"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb17-28"><a href="#cb17-28"></a><span class="op">}</span></span></code></pre></div><p>Hell yeah, it compiles! We even do not need to manually specify
<code>Arc&lt;Update&gt;</code> in each closure – type inference will do
the dirty work for us.</p><a class="header-link" href="#the-problem-with-rust"><h2 id="the-problem-with-rust">The problem with Rust</h2></a><p>“Fearless concurrency” – a formally correct but nonetheless
misleading statement. Yes, you no longer have <em>fear</em> of data
races, but you have <strong>PAIN</strong>, much pain.</p><p>Let me elaborate. In the previous sections, I have not even loaded
you with all the peculiarities and inadequacies of Rust that affected
the final solution – but there were plenty of them. First of all, notice
the heavy use of boxed futures: <em>all</em> of the aforementioned
<code>BoxFuture</code> types, as well as the corresponding
<code>Box::new</code> and <code>Box::pin</code> twiddling, were
irreplaceable by generics. If you know at least a little bit of Rust,
you know that <code>Vec</code> can only contain fixed-sized types, so
the occurrence of <code>BoxFuture</code> inside
<code>type Handler</code> makes sense; however, using
<code>BoxFuture</code> instead of an <code>async</code> function
signature in the <code>Execute</code> trait is not that apparent.</p><p>The awesome essay <em>“<a href="https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/">Why
async fn in traits are hard</a>”</em> by <a href="https://github.com/nikomatsakis">Niko Matsakis</a> explains why.
In short, at the moment of writing this blog post, it is impossible to
define <code>async fn</code> functions in traits; instead you should use
some type erasure alternative like the <a href="https://lib.rs/crates/async-trait"><code>async-trait</code></a>
crate or boxing futures manually, as in our examples. In fact,
<code>async-trait</code> performs quite a similar thing, but honestly I
avoid using it because it mangles compile-time errors with procedural
macros. The technique of returning <code>BoxFuture</code> also has
disadvantages – one of them is that you need not forget to specify
<code>#[must_use]</code> for <em>each</em> <code>async fn</code>,
otherwise the compiler would not warn you if you call
<code>execute</code> without <code>.await</code>ing it <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. In
essence, boxing static entities is so common that the
<code>futures</code> crate exposes other dynamic variants of common
traits, including <a href="https://docs.rs/futures/latest/futures/stream/type.BoxStream.html"><code>BoxStream</code></a>,
<a href="https://docs.rs/futures/latest/futures/future/type.LocalBoxFuture.html"><code>LocalBoxFuture</code></a>,
and <a href="https://docs.rs/futures/latest/futures/prelude/stream/type.LocalBoxStream.html"><code>LocalBoxStream</code></a>
(the last two come without the <code>Send</code> requirement).</p><p>Secondly, explicit type annotation for <code>upd</code> breaks
everything (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3b17c3a2e3f0eab0725f5762c49b1eb4">playground</a>):</p><div class="sourceCode" id="cb18"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">use</span> tokio<span class="op">;</span> <span class="co">// 1.18.2</span></span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="kw">struct</span> Update<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="at">#[</span><span class="pp">tokio::</span>main<span class="at">]</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="kw">async</span> <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb18-8"><a href="#cb18-8"></a>    <span class="kw">let</span> closure <span class="op">=</span> <span class="op">|</span>upd<span class="op">:</span> <span class="op">&amp;</span>Update<span class="op">|</span> <span class="kw">async</span> <span class="kw">move</span> <span class="op">{</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>        <span class="pp">println!</span>(<span class="st">"{:?}"</span><span class="op">,</span> upd)<span class="op">;</span></span>
<span id="cb18-10"><a href="#cb18-10"></a>    <span class="op">};</span></span>
<span id="cb18-11"><a href="#cb18-11"></a></span>
<span id="cb18-12"><a href="#cb18-12"></a>    closure(<span class="op">&amp;</span>Update)<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb18-13"><a href="#cb18-13"></a><span class="op">}</span></span></code></pre></div><p>Compiler output:</p><div class="sourceCode" id="cb19"><pre class="sourceCode numberSource code numberLines"><code class="sourceCode"><span id="cb19-1"><a href="#cb19-1"></a>error: lifetime may not live long enough</span>
<span id="cb19-2"><a href="#cb19-2"></a>  --&gt; src/main.rs:8:34</span>
<span id="cb19-3"><a href="#cb19-3"></a>   |</span>
<span id="cb19-4"><a href="#cb19-4"></a>8  |       let closure = |upd: &amp;Update| async move {</span>
<span id="cb19-5"><a href="#cb19-5"></a>   |  _________________________-______-_^</span>
<span id="cb19-6"><a href="#cb19-6"></a>   | |                         |      |</span>
<span id="cb19-7"><a href="#cb19-7"></a>   | |                         |      return type of closure `impl Future&lt;Output = ()&gt;` contains a lifetime `'2`</span>
<span id="cb19-8"><a href="#cb19-8"></a>   | |                         let's call the lifetime of this reference `'1`</span>
<span id="cb19-9"><a href="#cb19-9"></a>9  | |         println!("{:?}", upd);</span>
<span id="cb19-10"><a href="#cb19-10"></a>10 | |     };</span>
<span id="cb19-11"><a href="#cb19-11"></a>   | |_____^ returning this value requires that `'1` must outlive `'2`</span></code></pre></div><p>(Try to remove the type annotation <code>: &amp;Update</code> and the
compilation will succeed.)</p><p>If you have no idea what this error means, you are not alone – see <a href="https://github.com/rust-lang/rust/issues/70791">issue #70791</a>.
Looking at the list of issue labels reveals <code>C-Bug</code>, which
classifies the issue as a compiler bug. At the moment of writing this
post, rustc has <a href="https://web.archive.org/save/https://github.com/rust-lang/rust/labels/C-bug">3,107
open <code>C-bug</code> issues</a> and <a href="https://web.archive.org/web/20220601185940/https://github.com/rust-lang/rust/issues?q=is%3Aopen+label%3AC-bug+label%3AA-lifetimes">114
open <code>C-bug</code>+<code>A-lifetimes</code> issues</a>. Remember
that <code>async fn</code> worked for us but an equivalent closure did
not? – this is also a compiler bug, see <a href="https://github.com/rust-lang/rust/issues/70263">issue #70263</a>.
There are also many language-related issues dated earlier than 2020, see
<a href="https://github.com/rust-lang/rust/issues/41078">issue
#41078</a> and <a href="https://github.com/rust-lang/rust/issues/42940">issue
#42940</a>.</p><p>You see how our simple task of registering handlers has seamlessly
transcended into wandering in rustc issues with the hope to somehow
circumvent the language. Designing interfaces in Rust is like walking
through a minefield: in order to succeed, you need to balance on your
ideal interface and what features are available to you. Yes, I hear you.
No, it is not like in all other languages. When you program in some
stable production language (not Rust), you can typically foresee how
your imaginary interface would fit with language semantics; but when you
program in Rust, the process of designing APIs is affected by numerous
arbitrary language limitations like those we have seen so far. You
expect that borrow checker will validate your references and type system
will help you to deal with program entities, but you end up throwing
<code>Box</code>, <code>Pin</code>, and <code>Arc</code> here and there
and fighting with type system inexpressiveness.</p><p>To finish the section, this is the full implementation in Golang:</p><div class="code-annotation-container"><p class="code-annotation">
<code>dispatcher.go</code>
</p></div><div class="sourceCode" id="cb20"><pre class="sourceCode numberSource go numberLines"><code class="sourceCode go"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">package</span> main</span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="kw">import</span> <span class="st">"fmt"</span></span>
<span id="cb20-4"><a href="#cb20-4"></a></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="kw">type</span> Update <span class="kw">struct</span><span class="op">{}</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="kw">type</span> Handler <span class="kw">func</span><span class="op">(*</span>Update<span class="op">)</span></span>
<span id="cb20-7"><a href="#cb20-7"></a></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="kw">type</span> Dispatcher <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb20-9"><a href="#cb20-9"></a>    handlers <span class="op">[]</span>Handler</span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="op">}</span></span>
<span id="cb20-11"><a href="#cb20-11"></a></span>
<span id="cb20-12"><a href="#cb20-12"></a><span class="kw">func</span> <span class="op">(</span>dp <span class="op">*</span>Dispatcher<span class="op">)</span> pushHandler<span class="op">(</span>handler Handler<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-13"><a href="#cb20-13"></a>    dp<span class="op">.</span>handlers <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>dp<span class="op">.</span>handlers<span class="op">,</span> handler<span class="op">)</span></span>
<span id="cb20-14"><a href="#cb20-14"></a><span class="op">}</span></span>
<span id="cb20-15"><a href="#cb20-15"></a></span>
<span id="cb20-16"><a href="#cb20-16"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb20-17"><a href="#cb20-17"></a>    dp <span class="op">:=</span> Dispatcher<span class="op">{</span>handlers<span class="op">:</span> <span class="ot">nil</span><span class="op">}</span></span>
<span id="cb20-18"><a href="#cb20-18"></a>    dp<span class="op">.</span>pushHandler<span class="op">(</span><span class="kw">func</span><span class="op">(</span>upd <span class="op">*</span>Update<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-19"><a href="#cb20-19"></a>        fmt<span class="op">.</span>Println<span class="op">(</span>upd<span class="op">)</span></span>
<span id="cb20-20"><a href="#cb20-20"></a>    <span class="op">})</span></span>
<span id="cb20-21"><a href="#cb20-21"></a><span class="op">}</span></span></code></pre></div><a class="header-link" href="#why-rust-is-so-hard"><h2 id="why-rust-is-so-hard">Why Rust is so hard?</h2></a><p>Sometimes it is helpful to understand why shit happens. “Because X is
bad” is not an answer; “Because people that made X are bad” is not an
explanation either.</p><p>So why Rust is so hard?</p><p><strong>Rust is a systems language.</strong> To be a systems PL, it
is very important not to hide underlying computer memory management from
a programmer. For this reason, Rust pushes programmers to expose many
details that would be otherwise hidden in more high-level languages.
Examples: pointers, references and associated stuff, memory allocators,
different string types, <a href="https://en.wikipedia.org/wiki/Funarg_problem">different
<code>Fn</code> traits</a>, <a href="https://doc.rust-lang.org/std/pin/index.html"><code>std::pin</code></a>,
et cetera.</p><p><strong>Rust is a static language.</strong> This is better explained
in my previous essay <em>“<a href="why-static-languages-suffer-from-complexity.html">Why Static
Languages Suffer From Complexity</a>”</em>. To restate, languages with
static type systems (or equivalent functionality) tend to duplicate
their features on their <em>static</em> and <em>dynamic</em> levels,
thereby introducing <em>statics-dynamics biformity</em>. Transforming a
static abstraction into its dynamic counterpart is called
<em>upcasting</em>; the inverse process is called <em>downcasting</em>.
Inside <code>push_handler</code>, we have used upcasting to turn a
static handler into the dynamic <code>Handler</code> type to be pushed
to the final vector.</p><p>In addition, Rust is committed to making all these things intuitive
and memory safe. This kick-ass combination stresses the <a href="http://www.ats-lang.org/">human bounds</a> of computer language
design. From now it should be completely understandable why Rust feels
like a full of holes from time to time; in fact, it is almost a miracle
that it is functioning at all. A computer language is like a system of
tightly intertwined components: every time you introduce a new
linguistic abstraction, you have to make sure that it plays well with
the rest of the system to avoid bugs and inconsistencies. Perhaps we
should grant free health insurance or other life benefits to those who
develop such languages on full-time.</p><a class="header-link" href="#how-things-can-be-different"><h2 id="how-things-can-be-different">How things can be different?</h2></a><p>Now imagine that <strong>all of Rust’s issues dissapear</strong>.
Also, whole rustc and std are formally verified. It would be also fairly
nice to have a complete language specification with multiple tier-1
implementations, the same support for hardware platforms as of GCC,
stable ABI (though it is unclear how to deal with generics), and similar
stuff. That would probably be an ideal language for systems
programming.</p><p>Or imagine that <strong>Rust’s issues dissapear and it is now
completely high-level</strong>. That would kick the shit out of all
mainstream programming languages. Rust has adequate defaults, it
supports polymorphism, it has a very convenient package manager. I will
not enumerate here all the faults of mainstream PLs: cursed JavaScript
semantics, enterprise monstrosity of Java, <code>NULL</code> pointer
problems in C, uncontrollable UB of C++, numerous ways of doing the same
job in C#, et cetera. The modern programming language scene is rather a
freak show. Yet, you see, even with all of these drawbacks, people write
working software, while Rust (in its current state) is far from being
the most used PL. Moreover, my prediction is that Rust will never be as
popular as Java or Python. The reason is more social than technical: due
to the innate complexity of the language, there will always be fewer
professional software engineers in Rust than in Java or Python; to make
matters even worse, they will require higher salaries, mind you. As an
employer, you will have much more trouble finding good Rustaceans for
your business.</p><p>Finally, imagine that <strong>Rust’s issues dissapear, it is
high-level, and has uniform feature set.</strong> That would presumably
be close to the theoretical ideal of a high-level, general-purpose
programming language for the masses. Funnily enough, designing such a
language might turn out to be a less intimidating task than original
Rust, since we can hide all low-level details under an impenetrable
shell of a language runtime.</p><a class="header-link" href="#waiting-for-better-future"><h2 id="waiting-for-better-future">Waiting for better future</h2></a><p>So if I “figured out it all”, why should not I develop a sublime
version of Rust? I do not want to spend my next twenty years trying to
do so, given that the chance that my language will stand out is
infinitely small. I think the current set of most used production
languages is pretty random to some extent – we can always say why a
specific language got popular, but generally we cannot explain why
better alternatives sunk into oblivion. Backing from a big corporation?
Accidentally targeting an IT trend of the future? Again, the reasons are
rather social. Harsh reality: in life, sometimes hope plays a much more
vital role than all of your skills and self-dedication.</p><p>If you still want to create a PL of the future, I wish you good luck
and strong mental health. You are endlessly courageous and hopelessly
romantic.</p><p><img src="../media/content/rust-is-hard-or-the-misery-of-mainstream-programming/sad-keanu.jpeg"></p><a class="header-link" href="#related-ideas"><h2 id="related-ideas">Related ideas</h2></a><ul>
<li><em>“<a href="https://arxiv.org/pdf/2110.01098.pdf">Garbage
Collection Makes Rust Easier to Use: A Randomized Controlled Trial of
the Bronze Garbage Collector</a>”</em></li>
<li><em>“<a href="https://boats.gitlab.io/blog/post/shifgrethor-i/">Shifgrethor I:
Garbage collection as a Rust library</a>”</em></li>
<li><em>“<a href="https://without.boats/blog/revisiting-a-smaller-rust/">Revisiting
a ‘smaller Rust’</a>”</em></li>
<li><em>“<a href="https://graydon2.dreamwidth.org/307291.html">The Rust
I Wanted Had No Future</a>”</em></li>
<li><em>“<a href="https://news.ycombinator.com/item?id=39614433">Dada,
an Experiement by the Creators of Rust</a>”</em></li>
</ul><p>Feel free to contact me if you wish to extend this list.</p><a class="header-link" href="#update-addressing-misinterpretations"><h2 id="update-addressing-misinterpretations">Update: Addressing
misinterpretations</h2></a><p>Since publication, this post has gained 500+ upvotes on <a href="https://www.reddit.com/r/rust/comments/v3cktw/rust_is_hard_or_the_misery_of_mainstream/">r/rust</a>
and 700+ comments on <a href="https://news.ycombinator.com/item?id=31601040">HN</a>. I did not
expect such amount of attention. Unfortunately, before publishing
anything, it is very hard to predict all possible
misinterpretations.</p><p>Some people <a href="https://itsallaboutthebit.com/async-simple/">pointed out</a> that
the dispatcher example was concerned with the problems of library
maintainers, and that application programmers usually do not have to
deal with such peculiarities. They are right to some extent; however,
the reason I wrote this essay was mainly to talk about <em>programming
language design</em>.</p><p>Rust is ill-suited for generic <code>async</code> programming, this
is the gross true. When you enter <code>async</code>, you observe that
many other language features suddenly break down: references, closures,
type system, to name a few. From the perspective of language design,
this manifests a failure to design an orthogonal language <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. I
wanted to convey this observation in my post; I should have stated this
explicitly.</p><p>Additionally, how we write libraries reveals the true potential of a
language, since libraries tend to require more expressive features from
language designers – due to their generic nature. This also affects
mundane application programming: the more elegant libraries you have,
the more easily you can solve your tasks. Example: the abscence of <a href="https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html">GATs</a>
does not allow you to have a generic runtime interface and change Tokio
to something else in one line of code, as we do for loggers.</p><p>One gentleman also outlined a <a href="https://www.reddit.com/r/rust/comments/v3cktw/comment/ib0mp49/?utm_source=share&amp;utm_medium=web2x&amp;context=3">more
comprehensive list</a> of <code>async</code> Rust failures, including
function colouring, asynchronous <code>Drop</code>, and library code
duplication. I did not try to address all of these issues here –
otherwise the text would be bloated with too much information. However,
the list pretty much sums up all the bad things you have to deal with in
generic <code>async</code> code, such as library development.</p><section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1" role="doc-endnote"><p>Actually I forgot this
<code>#[must_use]</code> while writing the example and then did not
understand for a while why <code>stdout</code> was clean in the case of
two or more chained handlers. 🤡<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>A language is orthogonal when its
features “play well” with each other. E.g., arrays as function
parameters in C just boil down to pointers, which is admittedly not
orthogonal.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><script src="https://giscus.app/client.js" data-repo="hirrolot/hirrolot.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkzMTQ4MzI2NDA=" data-category="Announcements" data-category-id="DIC_kwDOEsP3AM4CSEqw" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="https://hirrolot.github.io/giscus-theme.css" data-lang="en" data-loading="lazy" crossorigin="anonymous" async="">
</script></div></body></html>