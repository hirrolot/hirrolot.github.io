<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="hirrolot’s Blog" />
  <title>What’s the Point of the C Preprocessor, Actually?</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="../style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <link href="https://fonts.googleapis.com/css2?family=Alata&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Caveat&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Lancelot&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="../myself.png" type="image/x-icon">
  <script src="../script.js"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">What’s the Point of the C Preprocessor, Actually?</h1>
<p class="author">hirrolot’s Blog</p>
<p class="date">Aug 3, 2021</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#macros-to-the-rescue">Macros to the rescue!</a></li>
<li><a href="#what-is-wrong-with-external-codegen">What is wrong with external codegen?</a></li>
<li><a href="#the-side-effects-of-aggressive-macros">The side effects of aggressive macros</a></li>
<li><a href="#final-words">Final words</a></li>
<li><a href="#afterword">Afterword</a></li>
<li><a href="#links">Links</a></li>
<li><a href="#references">References</a></li>
</ul>
</nav>
<p>“To do stuff that you cannot do with functions”<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> – virtually every C programmer would say.</p>
<p>Fair. But in fact, it is a bit more complicated.</p>
<p>As my experience with C and programming in general grew, I recognised more and more code patterns that I write by hand… that I am forced to write by hand. Most of the time, this occurred due to inadequacies of a programming language being used.</p>
<p>This is especially the case with C.</p>
<p>In C, I quite often find myself writing <a href="https://en.wikipedia.org/wiki/Virtual_method_table">virtual tables</a>, writing <a href="https://en.wikipedia.org/wiki/Tagged_union">tagged unions</a>… I distribute function pointers to their proper locations, I construct variants explicitly, checking whether data and a tag are consistent. In more high-level languages, these concepts are built-in; you do not need to explicitly state a memory layout, state exact instructions to construct the layout. This all is hidden under a nice interface.</p>
<p>We can do it in C too. <em>Take a look at the preprocessor</em>.</p>
<h2 id="macros-to-the-rescue">Macros to the rescue!</h2>
<p>In C, the only way to do metaprogramming is to use macros. Perhaps the reason we could not reify such abstractions as tagged unions till this moment is that C macros can only work with individual items but cannot operate on sequences thereof; put it simply, macros cannot loop or recurse. Therefore, without loops or recursion at our disposal, we could not generate something from a series of functions comprising some software interface, or from a series of variants comprising some tagged union. But we can enrich the preprocessor in such a way that it becomes possible. Read on.</p>
<p><a href="https://github.com/hirrolot/metalang99">Metalang99</a> is the solution I came up with.</p>
<p><del>Metalang99 is a language to write macros.</del> Sorry, it is a language to write recursive macros!</p>
<p>What was previously impossible soon became possible:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>datatype<span class="op">(</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    BinaryTree<span class="op">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>Leaf<span class="op">,</span> <span class="dt">int</span><span class="op">),</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>Node<span class="op">,</span> BinaryTree <span class="op">*,</span> <span class="dt">int</span><span class="op">,</span> BinaryTree <span class="op">*)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="dt">const</span> BinaryTree <span class="op">*</span>tree<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    match<span class="op">(*</span>tree<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        of<span class="op">(</span>Leaf<span class="op">,</span> x<span class="op">)</span> <span class="cf">return</span> <span class="op">*</span>x<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        of<span class="op">(</span>Node<span class="op">,</span> lhs<span class="op">,</span> x<span class="op">,</span> rhs<span class="op">)</span> <span class="cf">return</span> sum<span class="op">(*</span>lhs<span class="op">)</span> <span class="op">+</span> <span class="op">*</span>x <span class="op">+</span> sum<span class="op">(*</span>rhs<span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p class="adapted-from">
<a href="https://github.com/hirrolot/datatype99">Datatype99</a>, a library for tagged unions
</p>
<p>Oh, sorry again, I am a bit sleepy today. I forgot one crucial detail: to make the following code work, you must <code>#include &lt;datatype99.h&gt;</code>. Let me mend myself this time:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;interface99.h&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define State_INTERFACE               \</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="pp">    iFn(int, get, void *self);        \</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="pp">    iFn(void, set, void *self, int x);</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>interface<span class="op">(</span>State<span class="op">);</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> Num<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Num_State_get<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">((</span>Num <span class="op">*)</span>self<span class="op">)-&gt;</span>x<span class="op">;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Num_State_set<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>self<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">((</span>Num <span class="op">*)</span>self<span class="op">)-&gt;</span>x <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>impl<span class="op">(</span>State<span class="op">,</span> Num<span class="op">);</span></span></code></pre></div>
<p class="adapted-from">
<a href="https://github.com/hirrolot/interface99">Interface99</a>, a library for software interfaces
</p>
<p>Everything is correct now.</p>
<p>Everything you need to make it work is a one-liner <code>#include &lt;interface99.h&gt;</code>.</p>
<p>Believe it or not, <strong>this little detail is the exact purpose of the preprocessor</strong>. Let me explain it to you: preprocessor macros are <em>embedded</em> into the language for a reason. After all, macros are just a means for code generation, so why cannot we generate code using external tools, provided that they are often more advanced and so on? Because aside from being “advanced and so on,” they are also <em>less natural</em>.</p>
<h2 id="what-is-wrong-with-external-codegen">What is wrong with external codegen?</h2>
<p>The thing is that with native macros, you can interleave invocations thereof with the actual code, or business logic, or files in which you usually write your code. With third-party code generators, you cannot. You can only <code>fscanf</code> some code from <code>file.blah</code> and <code>fprintf</code> the generated code to <code>generated.h</code>. Okay, even if you had a ready C parser to read macro invocations of the form <code>X(...)</code> directly from <code>source.c</code>, where <code>X</code> is defined as <code>#define X(...) /* Consume all arguments! */</code> not to break the real compilation, where would you generate code? Please, do not tell me that you are going to <code>fprintf</code> right into <code>source.c</code>! Because you know, the placement of functions/types makes much sense in C, and you cannot <code>fprintf</code> the generated code for <code>X(...)</code> to <code>generated.h</code> and include it in <code>source.c</code>. The things might break apparently. And yes, you cannot just swallow the whole <code>source.c</code> and output <code>source-generated.c</code> somewhere because your IDE would then unironically say “goodbye good luck” to you – at least, constructions generated by such macros would no longer be visible when you write code.</p>
<p>That is, with third-party code generators, you are forced to separate the files in which you write ordinary code from the files to be fed to the code generator.</p>
<p>With native macros, you write code as usual.</p>
<p>With native macros, you do not violate the normal order in which linguistic constructions cooperate with each other. When you write <code>struct Vect { ... }</code>, you write it in the same file as <code>Vect_add</code>, <code>Vect_remove</code>, and so on. Why should you apparently write <code>datatype(T, ...)</code> in a separate file when it is also a linguistic construction? Elaborating further, why should we treat software interfaces as an alien spacecraft fallen to Earth?</p>
<p>With <a href="https://github.com/hirrolot/datatype99">Datatype99</a> and <a href="https://github.com/hirrolot/interface99">Interface99</a>, you generate the stuff in-place. Tagged unions and software interfaces are those kinds of abstractions to be considered as parts of the host language, i.e., C. Therefore, they should be treated in the same way as we treat <code>struct</code>, as we treat <code>union</code>, functions, and variables.</p>
<p>No, I am not claiming that external codegen is useless. It has applications in a build process and other areas; for example, sometimes it is perfectly fine to separate files <span class="citation" data-cites="openssl-safestack">(OpenSSL, n.d.)</span>. What I am trying to convey is to use the right tool for the job. But wait, the suggested libraries rely on <a href="https://github.com/hirrolot/metalang99#q-how-does-it-work">some heavy-duty macros</a>, and it is crystal clear that the vanilla C preprocessor is not meant for such kind of abuse, right?</p>
<p>This is the turning point of our spontaneous discussion.</p>
<h2 id="the-side-effects-of-aggressive-macros">The side effects of aggressive macros</h2>
<p>Instead of thinking philosophically, I encourage you to think pragmatically.</p>
<p>Instead of thinking about what is good and what is bad, I encourage you to think about <em>benefits</em> and possible <em>side effects</em>.</p>
<p>The <strong>benefits</strong> include more concise, safe, clean code.</p>
<p>The <strong>side effects</strong> <em>might</em> include scary compilation errors and preposterous compilation times.</p>
<p>Not really.</p>
<p>When I started designing Metalang99, I was aware of how metaprogramming can go insane. <em>Metalang99 is an attempt to make it less insane</em>. With some unhealthy curiosity, you might accidentally call Satan, and he will kindly produce gigabytes of error messages for you, dear. Not kidding, I experienced it on my own:</p>
<div data-align="center">
<p><img src="../media/whats-the-point-of-the-c-preprocessor-actually/error.png" /></p>
</div>
<p>In the above error, I asked a compiler to show a full backtrace of macro expansions. Most of the time, it is just a senseless bedsheet of macro definitions, so I always turn it down by <code>-ftrack-macro-expansion=0</code> (GCC) or <code>-fmacro-backtrace-limit=1</code> (Clang).</p>
<p>But how to produce errors that people understand?</p>
<p>This question is out of the scope bla-bla-bla. I will just show you some real errors you can get from Datatype99 real quick:</p>
<ul>
<li>
<p class="code-annotation">
<code>playground.c</code>
</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>datatype<span class="op">(</span>A<span class="op">,</span> <span class="op">(</span>Foo<span class="op">,</span> <span class="dt">int</span><span class="op">),</span> Bar<span class="op">(</span><span class="dt">int</span><span class="op">));</span></span></code></pre></div>
<p class="code-annotation">
<code>/bin/sh</code>
</p>
<pre><code>$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0
playground.c:3:1: error: static assertion failed: &quot;ML99_assertIsTuple: Bar(int) must be (x1, ..., xN)&quot;
    3 | datatype(A, (Foo, int), Bar(int));
      | ^~~~~~~~</code></pre>
</li>
<li>
<p class="code-annotation">
<code>playground.c</code>
</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>datatype<span class="op">(</span>A<span class="op">,</span> <span class="op">(</span>Foo<span class="op">,</span> <span class="dt">int</span><span class="op">)</span> <span class="op">(</span>Bar<span class="op">,</span> <span class="dt">int</span><span class="op">));</span></span></code></pre></div>
<p class="code-annotation">
<code>/bin/sh</code>
</p>
<pre><code>$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0
playground.c:3:1: error: static assertion failed: &quot;ML99_assertIsTuple: (Foo, int) (Bar, int) must be (x1, ..., xN), did you miss a comma?&quot;
    3 | datatype(A, (Foo, int) (Bar, int));
      | ^~~~~~~~</code></pre>
</li>
<li>
<p class="code-annotation">
<code>playground.c</code>
</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>datatype<span class="op">(</span>A<span class="op">,</span> <span class="op">(</span>Foo<span class="op">,</span> <span class="dt">int</span><span class="op">),</span> <span class="op">(</span>Bar<span class="op">,</span> <span class="dt">int</span><span class="op">),</span> <span class="co">/* trailing comma is prohibited */</span><span class="op">);</span></span></code></pre></div>
<p class="code-annotation">
<code>/bin/sh</code>
</p>
<pre><code>$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0
playground.c:3:1: error: static assertion failed: &quot;ML99_assertIsTuple: must be (x1, ..., xN)&quot;
    3 | datatype(A, (Foo, int), (Bar, int), /* trailing comma is prohibited */);
      | ^~~~~~~~</code></pre>
</li>
</ul>
<p>Looks nice?</p>
<p>I know how to break this wonderful world. Look:</p>
<p class="code-annotation">
<code>playground.c</code>
</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>datatype<span class="op">(</span>A<span class="op">,</span> <span class="op">(</span>Foo<span class="op">,</span> <span class="dt">int</span><span class="op">)</span> <span class="op">~,</span> <span class="op">(</span>Bar<span class="op">,</span> <span class="dt">int</span><span class="op">));</span></span></code></pre></div>
<p class="code-annotation">
<code>/bin/sh</code>
</p>
<pre><code>$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0
playground.c:3:1: error: static assertion failed: &quot;invalid term `ML99_PRIV_IF_0 ~(ML99_PRIV_listFromTuplesError, ML99_PRIV_listFromTuplesProgressAux) (DATATYPE99_PRIV_parseVariant, 2, (Foo, int) ~, (Bar, int), ~)`&quot;
    3 | datatype(A, (Foo, int) ~, (Bar, int));
      | ^~~~~~~~</code></pre>
<p>Looks less nice?</p>
<p>Bad news: it is impossible to handle all kinds of errors in macros gracefully. But we do not need to handle <em>all</em> of them. It would be sufficient to handle <em>most of them</em>. Now I shall convince you that even Rust, a language that sells itself as a language with comprehensible errors, even Rust sometimes produces complete nonsense:</p>
<p><img src="../media/whats-the-point-of-the-c-preprocessor-actually/big-boy.png" /></p>
<p>(Kindly given by <a href="https://github.com/WaffleLapkin">Waffle Lapkin</a>.)</p>
<details>
<summary>
Show more hordes of errors…
</summary>
<p><img src="../media/whats-the-point-of-the-c-preprocessor-actually/1.jpg" /> <img src="../media/whats-the-point-of-the-c-preprocessor-actually/2.jpg" /> <img src="../media/whats-the-point-of-the-c-preprocessor-actually/3.jpg" /> <img src="../media/whats-the-point-of-the-c-preprocessor-actually/4.jpg" /></p>
<p>(I believe some of them were on stable Rust.)</p>
</details>
<p>Even so, most of the time, Rust performs well enough.</p>
<p>Even so, most of the time, Datatype99 &amp; Inteface99 perform well enough.</p>
<p>Rust exemplifies perfectly that a <em>system need not be ideal to be practically useful</em>. The same holds for the macros: I rarely see complete nonsense from my macros, but whether you like it or not, it might happen. Surely, it is not a reason to abandon the whole approach; as you can see, your computer is still there, your terminal did not die under tons of error messages, and everything you need to do is just to carefully look at the macro invocation and perhaps run your compiler with <code>-E</code>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> The funny fact is that even in Rust, I was forced to <a href="https://github.com/dtolnay/cargo-expand">cargo-expand</a> some macros several times to get a sense of what is wrong, so why no one is saying that Rusty macros are totally unusable?</p>
<p>Regarding compilation times, they are <a href="https://hirrolot.github.io/posts/macros-on-steroids-or-how-can-pure-c-benefit-from-metaprogramming.html#the-compilation-times">just fine</a>.</p>
<h2 id="final-words">Final words</h2>
<p>Let me sum up.</p>
<p>The purpose of the preprocessor is to enable <em>seamless integration</em>.</p>
<p>The purpose of the preprocessor is to allow your macros to be conveniently interleaved with the rest of your code.</p>
<p>The purpose of the preprocessor is not to break the normal order in which linguistic abstractions cooperate with each other.</p>
<p><strong>The purpose of the preprocessor is to be natural</strong>…<br> and this is what external codegen cannot suggest, no matter how you try.</p>
<h2 id="afterword">Afterword</h2>
<ul>
<li><p>I wrote this blog post as a single answer to questions like “Your macros are nice, but the preprocessor is a wrong tool for them.” I found it a logical contradiction when people appeal to one unpleasant aspect to ruin the whole approach, provided that we have several examples in the industry when the method works just fine.</p></li>
<li><p>Before I started to implement Datatype99, I searched for prior art. There were only such projects as <a href="https://bitbucket.org/Macnaa/adt4c-with-polymorphism/src/master/">adt4c</a>. The problem with them is that they use external code generation; you can just compare how the same functionality is done using this approach and using Datatype99. Additionally, I made Datatype99 minimalistic, meaning that it provides <em>only</em> ADTs and nothing more – adt4c, on the contrary, comes with a type polymorphism implementation.</p></li>
<li><p>Before I started to implement Metalang99, I tried to use <a href="http://boost.org/libs/preprocessor">Boost/Preprocessor</a> <span class="citation" data-cites="poica">(hirrolot, n.d.a)</span>. Owing to its fundamental limitations, I abandoned the project. These drawbacks include macro bluepainting (when the preprocessor blocks macro recursion) and very poor diagnostics. I fixed both of them in Metalang99.</p></li>
<li><p>Some people state that these macros (Datatype99 &amp; Interface99) are opaque, meaning you do not know what they generate. It is simply not true; from the very beginning, I stated explicitly what they do generate <span class="citation" data-cites="dt99-semantics if99-semantics">(hirrolot, n.d.b, n.d.d)</span>; I do not try to fool you with a nifty interface and a bloody cannibalic massacre under the hood. I designed these libraries in such a way that they even do not require libc, they are FFI-friendly, and they do not impose any restrictions on your environment.</p></li>
<li><p>I do encourage you to use such well-documented and well-tested libraries as Datatype99 &amp; Interface99, but I discourage you from polluting your codebase with fancy macro-based DSLs implemented upon Metalang99. Currently, I do not see much need for Metalang99 except these libraries; they provide a facade for your APIs, <em>reuse them</em>, do not try to express something by defining more macros if you can do that with already existent linguistic abstractions. If you nonetheless decided to use recursive macros of Metalang99, at least use them sanely – always prove to yourself why you need more new macros instead of ordinary functions or/and just simpler macros, and you will thank me one day. Macros can only be a solution when you are “run out of your language”; please, do not.</p></li>
<li><p>If you ask me, “Why use C if there are Zig/Rust/C++/etc?” you can afford another language; this is cool but not always possible – you can find the information elsewhere in the Internet <span class="citation" data-cites="so-why-use-c dt99-why-use-c devault">(Simucal, n.d.; hirrolot, n.d.c; Drew DeVault, n.d.)</span>.</p></li>
</ul>
<h2 id="links">Links</h2>
<ul>
<li>Installation instructions for <a href="https://github.com/hirrolot/metalang99#getting-started">Metalang99</a>, <a href="https://github.com/hirrolot/datatype99#installation">Datatype99</a>, <a href="https://github.com/hirrolot/interface99#installation">Interface99</a>.</li>
<li>The <a href="../posts/macros-on-steroids-or-how-can-pure-c-benefit-from-metaprogramming.html">motivational post</a> for the above libraries.</li>
<li>The <a href="https://lists.sr.ht/~hirrolot/metalang99">mailing list</a> for the above libraries. Join and talk with us!</li>
</ul>
<h2 class="unnumbered" id="references">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-devault" class="csl-entry" role="doc-biblioentry">
Drew DeVault. n.d. <span>“Rust Is Not a Good C Replacement.”</span> <a href="https://drewdevault.com/2019/03/25/Rust-is-not-a-good-C-replacement.html">https://drewdevault.com/2019/03/25/Rust-is-not-a-good-C-replacement.html</a>.
</div>
<div id="ref-poica" class="csl-entry" role="doc-biblioentry">
hirrolot. n.d.a. <span>“A Research Programming Language on Top of C Macros.”</span> <a href="https://github.com/hirrolot/poica">https://github.com/hirrolot/poica</a>.
</div>
<div id="ref-dt99-semantics" class="csl-entry" role="doc-biblioentry">
———. n.d.b. <span>“Datatype99 Code Generation Semantics.”</span> <a href="https://github.com/hirrolot/datatype99#semantics">https://github.com/hirrolot/datatype99#semantics</a>.
</div>
<div id="ref-dt99-why-use-c" class="csl-entry" role="doc-biblioentry">
———. n.d.c. <span>“FAQ: Why Use C Instead of Rust/Zig/Whatever Else?”</span> <a href="https://github.com/hirrolot/datatype99#q-why-use-c-instead-of-rustzigwhatever-else">https://github.com/hirrolot/datatype99#q-why-use-c-instead-of-rustzigwhatever-else</a>.
</div>
<div id="ref-if99-semantics" class="csl-entry" role="doc-biblioentry">
———. n.d.d. <span>“Interface99 Code Generation Semantics.”</span> <a href="https://github.com/hirrolot/interface99#semantics">https://github.com/hirrolot/interface99#semantics</a>.
</div>
<div id="ref-openssl-safestack" class="csl-entry" role="doc-biblioentry">
OpenSSL. n.d. <span>“A Use Case for Generics in OpenSSL.”</span> <a href="https://github.com/openssl/openssl/blob/aff636a4893e24bdc686a00a13ae6199dd38d6aa/include/openssl/safestack.h.in">https://github.com/openssl/openssl/blob/aff636a4893e24bdc686a00a13ae6199dd38d6aa/include/openssl/safestack.h.in</a>.
</div>
<div id="ref-so-why-use-c" class="csl-entry" role="doc-biblioentry">
Simucal. n.d. <span>“Why Would Anybody Use C over C++?”</span> <a href="https://stackoverflow.com/questions/497786/why-would-anybody-use-c-over-c">https://stackoverflow.com/questions/497786/why-would-anybody-use-c-over-c</a>.
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>I believe that the C preprocessor was initially put into the language as a temporary workaround. With the preprocessor, you can do conditional compilation, foreach-macros, generics, etc. Nowadays, most of this stuff is done by “the right tools” but back in the 70’s, it was unclear how to solve such problems.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><code>-E</code> stands for “preprocess only.” It is supported at least by GCC and Clang but other compilers should have the same option as well (probably under a different name).<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<script src="https://utteranc.es/client.js" repo="hirrolot/hirrolot.github.io" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
</body>
</html>
