<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="hirrolot‚Äôs Blog" />
  <title>Macros on Steroids, Or: How Can Pure C Benefit From Metaprogramming</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
  <link rel="stylesheet" href="../style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

  <link href="https://fonts.googleapis.com/css2?family=Alata&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Caveat&display=swap" rel="stylesheet">
  <link rel="shortcut icon" href="../myself.png" type="image/x-icon">
  <script src="../script.js"></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Macros on Steroids, Or: How Can Pure C Benefit From Metaprogramming</h1>
<p class="author">hirrolot‚Äôs Blog</p>
<p class="date">Jul 22, 2021</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#the-three-kinds-of-code-repetition">The three kinds of code repetition</a></li>
<li><a href="#algebraic-data-types">Algebraic data types</a></li>
<li><a href="#software-interfaces">Software interfaces</a></li>
<li><a href="#what-about-the-compilation-errors">What about the compilation errors?</a></li>
<li><a href="#the-compilation-times">The compilation times?</a></li>
<li><a href="#final-words">Final words</a></li>
<li><a href="#links">Links</a></li>
<li><a href="#discussions">Discussions</a></li>
<li><a href="#references">References</a></li>
</ul>
</nav>
<p><em>This post has a <a href="../posts/whats-the-point-of-the-c-preprocessor-actually.html">followup</a>.</em></p>
<p>Have you ever envisioned the daily C preprocessor as a tool for some decent metaprogramming?</p>
<p>Have you ever envisioned the C preprocessor as a tool that can improve the correctness, clarity, and overall maintainability of your code, when used sanely?</p>
<p>I did. And I have done everything dependent on me to make it real.</p>
<p>Meet <a href="https://github.com/hirrolot/metalang99">Metalang99</a>, a simple functional language that allows you to create complex metaprograms. It represents a header-only macro library, so everything you need to set it up is <code>-Imetalang99/include</code> and a C99 compiler.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> However, today I shall focus only on two accompanying libraries ‚Äì <a href="https://github.com/hirrolot/datatype99">Datatype99</a> and <a href="https://github.com/hirrolot/interface99">Interface99</a>. Being implemented atop of Metalang99, they unleash the potential of preprocessor metaprogramming at the full scale, and therefore are more useful for an average C programmer.</p>
<p>I shall also address a few captious questions regarding compilation times, compilation errors, and applicability of my method to the real world.</p>
<p>Nuff said, let us dive into it!</p>
<h2 id="the-three-kinds-of-code-repetition">The three kinds of code repetition</h2>
<p>There is an important thing called <em>code repetition</em>. There are three kinds of it:<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<ol type="1">
<li>The repetition that can be avoided by using functions,</li>
<li>by using trivial macros,</li>
<li>by using macros with loops/recursion.</li>
</ol>
<p>Whenever you encounter repetition in your code, you try to eliminate it first by using functions, then by using macros. For example, instead of copy-pasting the same code of reading user data each time, we can reify it into the function <code>read_user</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> read_user<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>user<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Type user: &quot;</span><span class="op">);</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">bool</span> user_read <span class="op">=</span> scanf<span class="op">(</span><span class="st">&quot;%15s&quot;</span><span class="op">,</span> user<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>user_read<span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;New user %s</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> user<span class="op">);</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> amy<span class="op">[</span><span class="dv">16</span><span class="op">],</span> luke<span class="op">[</span><span class="dv">16</span><span class="op">];</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>read_user<span class="op">(</span>amy<span class="op">);</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>read_user<span class="op">(</span>luke<span class="op">);</span></span></code></pre></div>
<p>Sometimes you cannot avoid repetition through functions. Then you resort to macros:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define list_for_each(pos, head) \</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">    for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> list_head <span class="op">*</span>current<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>list_for_each<span class="op">(</span>current<span class="op">,</span> <span class="op">&amp;</span>self<span class="op">-&gt;</span>items<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Do something meaningful...</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p class="adapted-from">
<a href="https://github.com/torvalds/linux/blob/master/include/linux/list.h"><code>linux/include/linux/list.h</code></a>
</p>
<p>Going further, sometimes you cannot eliminate repetition through trivial macros (macros that cannot loop/recurse). Speaking technically, all macros in C are trivial since the preprocessor blocks macro recursion automatically <span class="citation" data-cites="bluepainting cloak-rec so-rec-macros-1 so-rec-macros-2">(C99 committee, n.d.; Paul Fultz II, n.d.; kokosing, n.d.; Vittorio Romeo, n.d.)</span>:</p>
<p class="code-annotation">
<code>rec.c</code>
</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define FOO(x, ...) x; FOO(__VA_ARGS__)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>FOO<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">)</span></span></code></pre></div>
<p class="code-annotation">
<code>/bin/sh</code><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>
</p>
<pre><code>$ clang rec.c -E -P -Weverything -std=c99
rec.c:3:1: warning: disabled expansion of recursive macro [-Wdisabled-macro-expansion]
FOO(1, 2, 3)
^
rec.c:1:24: note: expanded from macro &#39;FOO&#39;
#define FOO(x, ...) x; FOO(__VA_ARGS__)
                       ^

1; FOO(2, 3)
1 warning generated.</code></pre>
<p>What you are going to do with the following code snippet then?</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> BinaryTreeLeaf<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> BinaryTree <span class="op">*</span>lhs<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    BinaryTreeLeaf x<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> BinaryTree <span class="op">*</span>rhs<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> BinaryTreeNode<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="op">{</span> Leaf<span class="op">,</span> Node <span class="op">}</span> tag<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">union</span> <span class="op">{</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        BinaryTreeLeaf leaf<span class="op">;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        BinaryTreeNode node<span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> data<span class="op">;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> BinaryTree<span class="op">;</span></span></code></pre></div>
<p>Experienced C programmers might have noticed that the pattern is called a <a href="https://en.wikipedia.org/wiki/Tagged_union">tagged union</a>. It is described as follows:</p>
<pre><code>typedef struct {
    enum { &lt;tag&gt;... } tag;
    union { &lt;type&gt; &lt;tag&gt;... } data;
} &lt;name&gt;;</code></pre>
<p>See <code>&lt;tag&gt;...</code> and <code>&lt;type&gt; &lt;tag&gt;...</code>? These are the little monsters of code repetition. They cannot be generated even by a naive variadic macro,<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> since the tags (variant names) and the corresponding types are interleaved with each other. We may want to build some syntax sugar atop of bare tagged unions, but the thing is that <em>we cannot</em>. For example, this is how the same <code>BinaryTree</code> might look in Rust:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> BinaryTree <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    Leaf(<span class="dt">i32</span>)<span class="op">,</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    Node(<span class="dt">Box</span><span class="op">&lt;</span>BinaryTree<span class="op">&gt;,</span> <span class="dt">i32</span><span class="op">,</span> <span class="dt">Box</span><span class="op">&lt;</span>BinaryTree<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Another example: interfaces. Consider the <code>Airplane</code> interface:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>move_forward<span class="op">)(</span><span class="dt">void</span> <span class="op">*</span>self<span class="op">,</span> <span class="dt">int</span> distance<span class="op">);</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>move_back<span class="op">)(</span><span class="dt">void</span> <span class="op">*</span>self<span class="op">,</span> <span class="dt">int</span> distance<span class="op">);</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>move_up<span class="op">)(</span><span class="dt">void</span> <span class="op">*</span>self<span class="op">,</span> <span class="dt">int</span> distance<span class="op">);</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>move_down<span class="op">)(</span><span class="dt">void</span> <span class="op">*</span>self<span class="op">,</span> <span class="dt">int</span> distance<span class="op">);</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> AirplaneVTable<span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">// The definitions of `MyAirplane_*` methods here...</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> AirplaneVTable my_airplane <span class="op">=</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    MyAirplane_move_forward<span class="op">,</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    MyAirplane_move_back<span class="op">,</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    MyAirplane_move_up<span class="op">,</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    MyAirplane_move_down<span class="op">,</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Can you notice the repetition here? Right, in the definition of <code>AirplaneVTable my_airplane</code>. We already know the names of the interface methods, why do we need to specify them again? Why could not we just write <code>impl(Airplane, MyAirplane)</code> which will collect all methods‚Äô names and prepend <code>MyAirplane</code> to each one? In Rust:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Airplane <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> move_forward(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> distance<span class="op">:</span> <span class="dt">i32</span>)<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> move_back(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> distance<span class="op">:</span> <span class="dt">i32</span>)<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> move_up(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> distance<span class="op">:</span> <span class="dt">i32</span>)<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> move_down(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> distance<span class="op">:</span> <span class="dt">i32</span>)<span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Airplane <span class="kw">for</span> MyAirplane <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The definitions of `MyAirplane` methods here...</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>I think you already know the answer: because preprocessor macros cannot loop/recurse and, therefore, cannot iterate on unbounded sequences of arguments.</p>
<p>This is what Metalang99 is for.</p>
<p>Metalang99 is a <em>natural</em> extension to the preprocessor; it allows you to eliminate the third kind of code repetition ‚Äì by using macro iteration. This possibility has given rise to the complete support for <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a> and software interfaces, both of which we shall discuss in the next two sections. Reader, follow me!</p>
<h2 id="algebraic-data-types">Algebraic data types</h2>
<p>Recall to the aforementioned <code>BinaryTree</code> tagged union. With the aid of <a href="https://github.com/hirrolot/datatype99">Datatype99</a>, a library implemented atop of Metalang99, it can be defined as follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;datatype99.h&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>datatype<span class="op">(</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    BinaryTree<span class="op">,</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>Leaf<span class="op">,</span> <span class="dt">int</span><span class="op">),</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>Node<span class="op">,</span> BinaryTree <span class="op">*,</span> <span class="dt">int</span><span class="op">,</span> BinaryTree <span class="op">*)</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span></code></pre></div>
<p>And manipulated as follows:<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum<span class="op">(</span><span class="dt">const</span> BinaryTree <span class="op">*</span>tree<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    match<span class="op">(*</span>tree<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        of<span class="op">(</span>Leaf<span class="op">,</span> x<span class="op">)</span> <span class="cf">return</span> <span class="op">*</span>x<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        of<span class="op">(</span>Node<span class="op">,</span> lhs<span class="op">,</span> x<span class="op">,</span> rhs<span class="op">)</span> <span class="cf">return</span> sum<span class="op">(*</span>lhs<span class="op">)</span> <span class="op">+</span> <span class="op">*</span>x <span class="op">+</span> sum<span class="op">(*</span>rhs<span class="op">);</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The neat part is that not only such use of macros reduces boilerplate but also reduces the risk of a failure: you can no longer access <code>.rhs</code> if the binary tree is just <code>Leaf</code> (since the variable <code>rhs</code> merely has not been introduced to the scope after <code>of(Leaf, x)</code>), or construct <code>BinaryTree</code> with <code>.tag = Leaf</code> and data for <code>Node</code>.</p>
<p>If you want to observe the generated code, please follow <a href="https://godbolt.org/z/3TKn8T3Gj">godbolt</a>.</p>
<h2 id="software-interfaces">Software interfaces</h2>
<p>The same holds for the aforementioned <code>AirplaneVTable</code>. Here is how easy you can define it with <a href="https://github.com/hirrolot/interface99">Interface99</a>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;interface99.h&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define Airplane_INTERFACE                             \</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="pp">    iFn(void, move_forward, void *self, int distance); \</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="pp">    iFn(void, move_back, void *self, int distance);    \</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="pp">    iFn(void, move_up, void *self, int distance);      \</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="pp">    iFn(void, move_down, void *self, int distance);</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>interface<span class="op">(</span>Airplane<span class="op">);</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co">// The definitions of `MyAirplane_*` methods here...</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>implPrimary<span class="op">(</span>Airplane<span class="op">,</span> MyAirplane<span class="op">);</span></span></code></pre></div>
<p><code>implPrimary(Airplane, MyAirplane)</code> is the most noticeable part here; it deduces the methods‚Äô names from the context, freeing you from the burden of updating the definition each time you add/remove/rename an interface method.</p>
<p>At the end of the game, you will end up with this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">// interface(Airplane);</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> AirplaneVTable AirplaneVTable<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> Airplane Airplane<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> AirplaneVTable <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>move_forward<span class="op">)(</span><span class="dt">void</span> <span class="op">*</span>self<span class="op">,</span> <span class="dt">int</span> distance<span class="op">);</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>move_back<span class="op">)(</span><span class="dt">void</span> <span class="op">*</span>self<span class="op">,</span> <span class="dt">int</span> distance<span class="op">);</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>move_up<span class="op">)(</span><span class="dt">void</span> <span class="op">*</span>self<span class="op">,</span> <span class="dt">int</span> distance<span class="op">);</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>move_down<span class="op">)(</span><span class="dt">void</span> <span class="op">*</span>self<span class="op">,</span> <span class="dt">int</span> distance<span class="op">);</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Airplane <span class="op">{</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">*</span>self<span class="op">;</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> AirplaneVTable <span class="op">*</span>vptr<span class="op">;</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="co">// implPrimary(Airplane, MyAirplane);</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> AirplaneVTable MyAirplane_Airplane_impl <span class="op">=</span> <span class="op">{</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>move_forward <span class="op">=</span> MyAirplane_move_forward<span class="op">,</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>move_back <span class="op">=</span> MyAirplane_move_back<span class="op">,</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>move_up <span class="op">=</span> MyAirplane_move_up<span class="op">,</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>move_down <span class="op">=</span> MyAirplane_move_down<span class="op">,</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Pretty much the same as if you wrote by hand. <a href="https://en.wikipedia.org/wiki/Virtual_method_table">Virtual method tables</a> are so common that they are used almost in every medium/large-sized project in C:</p>
<ul>
<li><p><strong>The Linux kernel.</strong> It turns out that they use <a href="https://lwn.net/Articles/444910/">their own, informally specified</a> method dispatch technique, which is pretty similar to virtual tables.</p></li>
<li><p><strong>FFmpeg.</strong> In order to define a media codec, they <a href="https://github.com/FFmpeg/FFmpeg/blob/7af1a3cebef6d9654675252f57689d46ac17d1e9/libavcodec/libopusenc.c#L583">leverage</a> the <a href="https://github.com/FFmpeg/FFmpeg/blob/7af1a3cebef6d9654675252f57689d46ac17d1e9/libavcodec/codec.h#L197"><code>AVCodec</code></a> structure with some callback functions within.</p></li>
<li><p><strong>VLC.</strong> Likewise, they <a href="https://github.com/videolan/vlc/blob/923b582e8f10de38f285be54e92672ca8c1c1c0a/modules/codec/opus.c#L185">leverage</a> the <a href="https://github.com/videolan/vlc/blob/923b582e8f10de38f285be54e92672ca8c1c1c0a/include/vlc_codec.h#L100"><code>decoder_t</code></a> structure for a media decoder.</p></li>
</ul>
<p>Both Interface99 and Datatype99 reify informal software development patterns into utterly formal programmatic abstractions. Each time you write a separate function to perform a certain task several times, you conceptually do the same.</p>
<p>Both Interface99 and Datatype99 rely on heavy use of macros, which would not be possible without something like Metalang99.</p>
<h2 id="what-about-the-compilation-errors">What about the compilation errors?</h2>
<p>This all is good and fun, but what about the compilation errors? How do they look? Are they comprehensible at all?</p>
<p>I know how insane error messages can be with metaprogramming,<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> and how frustrating it can be to figure out what do they mean. While it is technically impossible to handle all kinds of syntax mismatches, I have put a huge effort to make most of the diagnostics comprehensible. Let us imagine that you have accidentally made a syntax mistake in a macro invocation. Then you will see something like this:<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p class="code-annotation">
<code>playground.c</code>
</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>datatype<span class="op">(</span>A<span class="op">,</span> <span class="op">(</span>Foo<span class="op">,</span> <span class="dt">int</span><span class="op">),</span> Bar<span class="op">(</span><span class="dt">int</span><span class="op">));</span></span></code></pre></div>
<p class="code-annotation">
<code>/bin/sh</code>
</p>
<pre><code>$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0
playground.c: In function ‚Äòml99_error_3‚Äô:
playground.c:3:1: error: call to ‚Äòml99_error_3‚Äô declared with attribute error: ML99_assertIsTuple: Bar(int) must be (x1, ..., xN)
    3 | datatype(A, (Foo, int), Bar(int));
      | ^~~~~~~~</code></pre>
<p>Or this:</p>
<p class="code-annotation">
<code>playground.c</code>
</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>datatype<span class="op">(</span>A<span class="op">,</span> <span class="op">(</span>Foo<span class="op">,</span> <span class="dt">int</span><span class="op">)</span> <span class="op">(</span>Bar<span class="op">,</span> <span class="dt">int</span><span class="op">));</span></span></code></pre></div>
<p class="code-annotation">
<code>/bin/sh</code>
</p>
<pre><code>$ gcc playground.c -Imetalang99/include -Idatatype99 -ftrack-macro-expansion=0
playground.c: In function ‚Äòml99_error_3‚Äô:
playground.c:3:1: error: call to ‚Äòml99_error_3‚Äô declared with attribute error: ML99_assertIsTuple: (Foo, int) (Bar, int) must be (x1, ..., xN), did you miss a comma?
    3 | datatype(A, (Foo, int) (Bar, int));
      | ^~~~~~~~</code></pre>
<p>If an error is not really in the syntax part, you will see something like this:</p>
<p class="code-annotation">
<code>playground.c</code>
</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>datatype<span class="op">(</span>Foo<span class="op">,</span> <span class="op">(</span>FooA<span class="op">,</span> NonExistingType<span class="op">));</span></span></code></pre></div>
<p class="code-annotation">
<code>/bin/sh</code>
</p>
<pre><code>playground.c:3:1: error: unknown type name ‚ÄòNonExistingType‚Äô
    3 | datatype(
      | ^~~~~~~~
playground.c:3:1: error: unknown type name ‚ÄòNonExistingType‚Äô
playground.c:3:1: error: unknown type name ‚ÄòNonExistingType‚Äô</code></pre>
<p>Or this:</p>
<p class="code-annotation">
<code>playground.c</code>
</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>match<span class="op">(*</span>tree<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    of<span class="op">(</span>Leaf<span class="op">,</span> x<span class="op">)</span> <span class="cf">return</span> <span class="op">*</span>x<span class="op">;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// of(Node, lhs, x, rhs) return sum(*lhs) + *x + sum(*rhs);</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p class="code-annotation">
<code>/bin/sh</code>
</p>
<pre><code>playground.c: In function ‚Äòsum‚Äô:
playground.c:6:5: warning: enumeration value ‚ÄòNodeTag‚Äô not handled in switch [-Wswitch]
    6 |     match(*tree) {
      |     ^~~~~</code></pre>
<p>Take a look at this example with Interface99:</p>
<p class="code-annotation">
<code>playground.c</code>
</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define Foo_INTERFACE iFn(void, foo, int x, int y);</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>interface<span class="op">(</span>Foo<span class="op">);</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> dummy<span class="op">;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> MyFoo<span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Missing `void MyFoo_Foo_foo(int x, int y)`.</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>impl<span class="op">(</span>Foo<span class="op">,</span> MyFoo<span class="op">);</span></span></code></pre></div>
<p class="code-annotation">
<code>/bin/sh</code>
</p>
<pre><code>playground.c:12:1: error: ‚ÄòMyFoo_Foo_foo‚Äô undeclared here (not in a function); did you mean ‚ÄòMyFoo_Foo_impl‚Äô?
   12 | impl(Foo, MyFoo);
      | ^~~~
      | MyFoo_Foo_impl</code></pre>
<p>When a macro failed, and I do not understand what is wrong just by looking at the console or by looking at its invocation (which is very rare), I observe the expansion with <code>-E</code>. This is where the formal specifications of Datatype99 and Interface99 come into play: even in the expanded code, I will not see something unexpected since the code generation semantics are fixed and laid out in their corresponding <code>README.md</code>s.</p>
<h2 id="the-compilation-times">The compilation times?</h2>
<p>The compilation times are not really an issue. Let us see how much it takes to compile <a href="https://github.com/hirrolot/datatype99/blob/master/examples/binary_tree.c"><code>datatype99/examples/binary_tree.c</code></a>:</p>
<p class="code-annotation">
<code>/bin/sh</code><a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>
</p>
<pre><code>$ time gcc examples/binary_tree.c -Imetalang99/include -I. -ftrack-macro-expansion=0

real    0m0,121s
user    0m0,107s
sys     0m0,011s</code></pre>
<p>This might be an issue only if you have a lot of macro stuff in header files. If so, I suggest to use a widely known technique called <a href="https://en.wikipedia.org/wiki/Precompiled_header">precompiled headers</a> so that they will be transformed into some compiler‚Äôs intermediate representation and then put into a cache instead of being unnecessarily re-compiled on each file inclusion.</p>
<h2 id="final-words">Final words</h2>
<p>As it usually goes in software engineering, macros are a trade-off: <em>will you continue writing boilerplate code, thereby slowing down the development process and increasing the risk of bugs, or will you start using powerful macros at the cost of the <a href="https://github.com/hirrolot/metalang99#q-how-does-it-work">great implementation complexity</a><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> and slightly less comprehensible errors?</em></p>
<p>If you stick to the first choice, are you sure that it would be easier to figure out what is wrong with the code at runtime rather than at compile-time, especially when unreified abstractions got intertwined with your business logic? Are you okay with the fact that more bugs will end up being hidden in deployed production code instead of being intelligently found by a compiler (as in static vs.¬†dynamic typing)?</p>
<p>If you stick to the second choice, are you sure your team will let you integrate all this metaprogramming machinery into your codebase, even if used indirectly? I have seen several groups of developers that had to review all third-party code they use<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> ‚Äì not every programmer can/want to review Metalang99. Not to be misunderstood, I have made Metalang99, Datatype99, and Interface99 in the most simple and clean way I could, but the very nature of the preprocessor really makes itself felt.<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a></p>
<p>The choice is up to you.</p>
<h2 id="links">Links</h2>
<ul>
<li>Installation instructions for <a href="https://github.com/hirrolot/metalang99#getting-started">Metalang99</a>, <a href="https://github.com/hirrolot/datatype99#installation">Datatype99</a>, <a href="https://github.com/hirrolot/interface99#installation">Interface99</a>.</li>
<li><a href="https://github.com/hirrolot/datatype99#q-why-use-c-instead-of-rustzigwhatever-else">Q: Why use C instead of Rust/Zig/whatever else?</a></li>
<li><a href="https://github.com/hirrolot/metalang99#q-why-not-third-party-code-generators">Q: Why not third-party code generators?</a></li>
</ul>
<h2 id="discussions">Discussions</h2>
<ul>
<li><a href="https://news.ycombinator.com/item?id=27919448">HN</a></li>
<li><a href="https://www.reddit.com/r/programming/comments/opefdc/macros_on_steroids_or_how_can_pure_c_benefit_from/">r/programming</a></li>
<li><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/opeez9/macros_on_steroids_or_how_can_pure_c_benefit_from/">r/ProgrammingLanguages</a></li>
<li><a href="https://www.reddit.com/r/C_Programming/comments/opeeo0/macros_on_steroids_or_how_can_pure_c_benefit_from/">r/C_Programming</a></li>
</ul>
<h2 class="unnumbered" id="references">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-bluepainting" class="csl-entry" role="doc-biblioentry">
C99 committee. n.d. <span>‚ÄúC99 Draft, Section 6.10.3.4, Paragraph 2 ‚Äì Rescanning and Further Replacement.‚Äù</span> <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf</a>.
</div>
<div id="ref-so-rec-macros-1" class="csl-entry" role="doc-biblioentry">
kokosing. n.d. <span>‚ÄúForeach Macro on Macros Arguments.‚Äù</span> <a href="https://stackoverflow.com/questions/6707148/foreach-macro-on-macros-arguments">https://stackoverflow.com/questions/6707148/foreach-macro-on-macros-arguments</a>.
</div>
<div id="ref-cloak-rec" class="csl-entry" role="doc-biblioentry">
Paul Fultz II. n.d. <span>‚ÄúCloak Wiki on Preprocessor Recursion.‚Äù</span> <a href="https://github.com/pfultz2/Cloak/wiki/C-Preprocessor-tricks,-tips,-and-idioms#recursion">https://github.com/pfultz2/Cloak/wiki/C-Preprocessor-tricks,-tips,-and-idioms#recursion</a>.
</div>
<div id="ref-so-rec-macros-2" class="csl-entry" role="doc-biblioentry">
Vittorio Romeo. n.d. <span>‚ÄúUnderstanding DEFER and OBSTRUCT Macros.‚Äù</span> <a href="https://stackoverflow.com/questions/29962560/understanding-defer-and-obstruct-macros">https://stackoverflow.com/questions/29962560/understanding-defer-and-obstruct-macros</a>.
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Speaking formally, both the C and C++ preprocessors can execute Metalang99 (they are identical except for C++20‚Äôs <a href="https://en.cppreference.com/w/cpp/preprocessor/replace"><code>__VA_OPT__</code></a>). Speaking pragmatically, only pure C can significantly benefit from it.<a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn2" role="doc-endnote"><p>Just for the purposes of this blog post! In reality, there might be many more than three.<a href="#fnref2" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn3" role="doc-endnote"><p><code>-E</code> stands for ‚Äúpreprocess only,‚Äù <code>-P</code> stands for ‚Äúdo not print included headers.‚Äù<a href="#fnref3" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn4" role="doc-endnote"><p>A <a href="https://en.cppreference.com/w/c/preprocessor/replace">variadic macro</a> is a macro that can accept an unbounded sequence of arguments.<a href="#fnref4" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn5" role="doc-endnote"><p>This is called <a href="https://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a>, a technique to destructure a sum type (tagged union) into its respective components.<a href="#fnref5" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn6" role="doc-endnote"><p>Hello, <a href="http://boost.org/libs/preprocessor">Boost/Preprocessor</a>!<a href="#fnref6" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn7" role="doc-endnote"><p>If you use GCC, you can see such neat errors right from the console. Otherwise, you have to preprocess your file with <code>-E</code> and search for Metalang99 errors by yourself.<a href="#fnref7" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn8" role="doc-endnote"><p>The GCC option <code>-ftrack-macro-expansion=0</code> means not to print a useless bedsheet of macro expansions. Also, it drastically speeds up compilation, so I recommend you to always use it with Metalang99. If you use Clang, you can specify <code>-fmacro-backtrace-limit=1</code> to achieve approximately the same effect.<a href="#fnref8" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn9" role="doc-endnote"><p>Do you remember about <a href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/">the law of leaky abstractions</a>, my friend? üòÅ<a href="#fnref9" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn10" role="doc-endnote"><p>Except for so-called ‚Äútrusted‚Äù libraries such as OpenSSL or glibc.<a href="#fnref10" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn11" role="doc-endnote"><p>A reviewer of Metalang99 should also has some basic familiarity with <a href="https://en.wikipedia.org/wiki/Programming_language_theory">programming language theory</a>; at least, a reviewer should understand such terms as an <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF grammar</a>, <a href="https://en.wikipedia.org/wiki/Operational_semantics">operational semantics</a>, <a href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>, and so on, in order to read the <a href="https://github.com/hirrolot/metalang99/blob/master/spec/spec.pdf">specification</a>.<a href="#fnref11" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>
<script src="https://utteranc.es/client.js" repo="hirrolot/hirrolot.github.io" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
</body>
</html>
